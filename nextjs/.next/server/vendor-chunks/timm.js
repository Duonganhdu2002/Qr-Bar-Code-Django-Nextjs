"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/timm";
exports.ids = ["vendor-chunks/timm"];
exports.modules = {

/***/ "(ssr)/./node_modules/timm/lib/timm.js":
/*!***************************************!*\
  !*** ./node_modules/timm/lib/timm.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.clone = clone;\nexports.addLast = addLast;\nexports.addFirst = addFirst;\nexports.removeLast = removeLast;\nexports.removeFirst = removeFirst;\nexports.insert = insert;\nexports.removeAt = removeAt;\nexports.replaceAt = replaceAt;\nexports.getIn = getIn;\nexports.set = set;\nexports.setIn = setIn;\nexports.update = update;\nexports.updateIn = updateIn;\nexports.merge = merge;\nexports.mergeDeep = mergeDeep;\nexports.mergeIn = mergeIn;\nexports.omit = omit;\nexports.addDefaults = addDefaults;\nexports[\"default\"] = void 0;\n/* eslint-disable @typescript-eslint/ban-types */ /*!\n * Timm\n *\n * Immutability helpers with fast reads and acceptable writes.\n *\n * @copyright Guillermo Grau Panea 2016\n * @license MIT\n */ const INVALID_ARGS = \"INVALID_ARGS\";\nconst IS_DEV = \"development\" !== \"production\";\n// ===============================================\n// ### Helpers\n// ===============================================\nfunction throwStr(msg) {\n    throw new Error(msg);\n}\nfunction getKeysAndSymbols(obj) {\n    const keys = Object.keys(obj);\n    if (Object.getOwnPropertySymbols) {\n        // @ts-ignore\n        return keys.concat(Object.getOwnPropertySymbols(obj));\n    }\n    return keys;\n}\nconst hasOwnProperty = {}.hasOwnProperty;\nfunction clone(obj0) {\n    // As array\n    if (Array.isArray(obj0)) return obj0.slice(); // As object\n    const obj = obj0;\n    const keys = getKeysAndSymbols(obj);\n    const out = {};\n    for(let i = 0; i < keys.length; i++){\n        const key = keys[i];\n        out[key] = obj[key];\n    } // @ts-ignore (see type tests)\n    return out;\n} // Custom guard\nfunction isObject(o) {\n    return o != null && typeof o === \"object\";\n} // _deepFreeze = (obj) ->\n//   Object.freeze obj\n//   for key in Object.getOwnPropertyNames obj\n//     val = obj[key]\n//     if isObject(val) and not Object.isFrozen val\n//       _deepFreeze val\n//   obj\n// ===============================================\n// -- ### Arrays\n// ===============================================\n// -- #### addLast()\n// -- Returns a new array with an appended item or items.\n// --\n// -- Usage: `addLast(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addLast(arr, 'c')\n// -- // ['a', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addLast(arr, ['c', 'd'])\n// -- // ['a', 'b', 'c', 'd']\n// -- ```\n// `array.concat(val)` also handles the scalar case,\n// but is apparently very slow\nfunction addLast(array, val) {\n    if (Array.isArray(val)) return array.concat(val);\n    return array.concat([\n        val\n    ]);\n} // -- #### addFirst()\n// -- Returns a new array with a prepended item or items.\n// --\n// -- Usage: `addFirst(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addFirst(arr, 'c')\n// -- // ['c', 'a', 'b']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addFirst(arr, ['c', 'd'])\n// -- // ['c', 'd', 'a', 'b']\n// -- ```\nfunction addFirst(array, val) {\n    if (Array.isArray(val)) return val.concat(array);\n    return [\n        val\n    ].concat(array);\n} // -- #### removeLast()\n// -- Returns a new array removing the last item.\n// --\n// -- Usage: `removeLast(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeLast(arr)\n// -- // ['a']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeLast(arr3) === arr3\n// -- // true\n// -- ```\nfunction removeLast(array) {\n    if (!array.length) return array;\n    return array.slice(0, array.length - 1);\n} // -- #### removeFirst()\n// -- Returns a new array removing the first item.\n// --\n// -- Usage: `removeFirst(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeFirst(arr)\n// -- // ['b']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeFirst(arr3) === arr3\n// -- // true\n// -- ```\nfunction removeFirst(array) {\n    if (!array.length) return array;\n    return array.slice(1);\n} // -- #### insert()\n// -- Returns a new array obtained by inserting an item or items\n// -- at a specified index.\n// --\n// -- Usage: `insert(array, idx, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = insert(arr, 1, 'd')\n// -- // ['a', 'd', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- insert(arr, 1, ['d', 'e'])\n// -- // ['a', 'd', 'e', 'b', 'c']\n// -- ```\nfunction insert(array, idx, val) {\n    return array.slice(0, idx).concat(Array.isArray(val) ? val : [\n        val\n    ]).concat(array.slice(idx));\n} // -- #### removeAt()\n// -- Returns a new array obtained by removing an item at\n// -- a specified index.\n// --\n// -- Usage: `removeAt(array, idx)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = removeAt(arr, 1)\n// -- // ['a', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- removeAt(arr, 4) === arr\n// -- // true\n// -- ```\nfunction removeAt(array, idx) {\n    if (idx >= array.length || idx < 0) return array;\n    return array.slice(0, idx).concat(array.slice(idx + 1));\n} // -- #### replaceAt()\n// -- Returns a new array obtained by replacing an item at\n// -- a specified index. If the provided item is the same as\n// -- (*referentially equal to*) the previous item at that position,\n// -- the original array is returned.\n// --\n// -- Usage: `replaceAt(array, idx, newItem)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = replaceAt(arr, 1, 'd')\n// -- // ['a', 'd', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- replaceAt(arr, 1, 'b') === arr\n// -- // true\n// -- ```\nfunction replaceAt(array, idx, newItem) {\n    if (array[idx] === newItem) return array;\n    const len = array.length;\n    const result = Array(len);\n    for(let i = 0; i < len; i++){\n        result[i] = array[i];\n    }\n    result[idx] = newItem;\n    return result;\n} // ===============================================\n// -- ### Collections (objects and arrays)\n// ===============================================\n// -- #### getIn()\n// -- Returns a value from an object at a given path. Works with\n// -- nested arrays and objects. If the path does not exist, it returns\n// -- `undefined`.\n// --\n// -- Usage: `getIn(obj, path)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: ['a', 'b', 'c'] }\n// -- getIn(obj, ['d', 'd1'])\n// -- // 3\n// -- getIn(obj, ['e', 1])\n// -- // 'b'\n// -- ```\nfunction getIn(obj, path) {\n    if (!Array.isArray(path)) {\n        throwStr(IS_DEV ? \"A path array should be provided when calling getIn()\" : INVALID_ARGS);\n    }\n    if (obj == null) return undefined;\n    let ptr = obj;\n    for(let i = 0; i < path.length; i++){\n        const key = path[i];\n        ptr = ptr != null ? ptr[key] : undefined;\n        if (ptr === undefined) return ptr;\n    }\n    return ptr;\n} // -- #### set()\n// -- Returns a new object with a modified attribute.\n// -- If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `set(obj, key, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = set(obj, 'b', 5)\n// -- // { a: 1, b: 5, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- set(obj, 'b', 2) === obj\n// -- // true\n// -- ```\n// When called with an undefined/null `obj`, `set()` returns either\n// a single-element array, or a single-key object\n// Implementation\nfunction set(obj0, key, val) {\n    let obj = obj0;\n    if (obj == null) obj = typeof key === \"number\" ? [] : {};\n    if (obj[key] === val) return obj;\n    const obj2 = clone(obj);\n    obj2[key] = val;\n    return obj2;\n} // -- #### setIn()\n// -- Returns a new object with a modified **nested** attribute.\n// --\n// -- Notes:\n// --\n// -- * If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// -- * If the path does not exist, it will be created before setting\n// -- the new value.\n// --\n// -- Usage: `setIn(obj, path, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 = setIn(obj, ['d', 'd1'], 4)\n// -- // { a: 1, b: 2, d: { d1: 4, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 === obj\n// -- // false\n// -- obj2.d === obj.d\n// -- // false\n// -- obj2.e === obj.e\n// -- // true\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = setIn(obj, ['d', 'd1'], 3)\n// -- // { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj3 === obj\n// -- // true\n// -- obj3.d === obj.d\n// -- // true\n// -- obj3.e === obj.e\n// -- // true\n// --\n// -- // ... unknown paths create intermediate keys. Numeric segments are treated as array indices:\n// -- setIn({ a: 3 }, ['unknown', 0, 'path'], 4)\n// -- // { a: 3, unknown: [{ path: 4 }] }\n// -- ```\nfunction setIn(obj, path, val) {\n    if (!path.length) return val;\n    return doSetIn(obj, path, val, 0);\n}\nfunction doSetIn(obj, path, val, idx) {\n    let newValue;\n    const key = path[idx];\n    if (idx === path.length - 1) {\n        newValue = val;\n    } else {\n        const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === \"number\" ? [] : {};\n        newValue = doSetIn(nestedObj, path, val, idx + 1);\n    }\n    return set(obj, key, newValue);\n} // -- #### update()\n// -- Returns a new object with a modified attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `update(obj, key, fnUpdate)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = update(obj, 'b', (val) => val + 1)\n// -- // { a: 1, b: 3, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- update(obj, 'b', (val) => val) === obj\n// -- // true\n// -- ```\nfunction update(obj, key, fnUpdate) {\n    const prevVal = obj == null ? undefined : obj[key];\n    const nextVal = fnUpdate(prevVal);\n    return set(obj, key, nextVal);\n} // -- #### updateIn()\n// -- Returns a new object with a modified **nested** attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `updateIn<T: ArrayOrObject>(obj: T, path: Array<Key>,\n// -- fnUpdate: (prevValue: any) => any): T`\n// --\n// -- ```js\n// -- obj = { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj2 = updateIn(obj, ['d', 'd1'], (val) => val + 1)\n// -- // { a: 1, d: { d1: 4, d2: 4 } }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = updateIn(obj, ['d', 'd1'], (val) => val)\n// -- // { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj3 === obj\n// -- // true\n// -- ```\nfunction updateIn(obj, path, fnUpdate) {\n    const prevVal = getIn(obj, path);\n    const nextVal = fnUpdate(prevVal);\n    return setIn(obj, path, nextVal);\n} // -- #### merge()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- Similar to `Object.assign()`, but immutable.\n// --\n// -- Usage:\n// --\n// -- * `merge(obj1, obj2)`\n// -- * `merge(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5 }\n// -- obj3 = merge(obj1, obj2)\n// -- // { a: 1, b: 2, c: 4, d: 5 }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- merge(obj1, { c: 3 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 1 arg\n// Implementation\nfunction merge(a, b, c, d, e, f, ...rest) {\n    return rest.length ? doMerge.call(null, false, false, a, b, c, d, e, f, ...rest) : doMerge(false, false, a, b, c, d, e, f);\n} // -- #### mergeDeep()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- If both the first and second entries are objects they are merged recursively.\n// -- Similar to `Object.assign()`, but immutable, and deeply merging.\n// --\n// -- Usage:\n// --\n// -- * `mergeDeep(obj1, obj2)`\n// -- * `mergeDeep(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: { a: 1 } }\n// -- obj2 = { b: 3, c: { b: 2 } }\n// -- obj3 = mergeDeep(obj1, obj2)\n// -- // { a: 1, b: 3, c: { a: 1, b: 2 }  }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeDeep(obj1, { c: { a: 1 } }) === obj1\n// -- // true\n// -- ```\nfunction mergeDeep(a, b, c, d, e, f, ...rest) {\n    return rest.length ? doMerge.call(null, false, true, a, b, c, d, e, f, ...rest) : doMerge(false, true, a, b, c, d, e, f);\n} // -- #### mergeIn()\n// -- Similar to `merge()`, but merging the value at a given nested path.\n// --\n// -- Usage examples:\n// --\n// -- * `mergeIn(obj1, path, obj2)`\n// -- * `mergeIn(obj1, path, ...objects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, d: { b: { d1: 3, d2: 4 } } }\n// -- obj2 = { d3: 5 }\n// -- obj3 = mergeIn(obj1, ['d', 'b'], obj2)\n// -- // { a: 1, d: { b: { d1: 3, d2: 4, d3: 5 } } }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeIn(obj1, ['d', 'b'], { d2: 4 }) === obj1\n// -- // true\n// -- ```\nfunction mergeIn(a, path, b, c, d, e, f, ...rest) {\n    let prevVal = getIn(a, path);\n    if (prevVal == null) prevVal = {};\n    let nextVal;\n    if (rest.length) {\n        nextVal = doMerge.call(null, false, false, prevVal, b, c, d, e, f, ...rest);\n    } else {\n        nextVal = doMerge(false, false, prevVal, b, c, d, e, f);\n    }\n    return setIn(a, path, nextVal);\n} // -- #### omit()\n// -- Returns an object excluding one or several attributes.\n// --\n// -- Usage: `omit(obj, attrs)`\n//\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3, d: 4 }\n// -- omit(obj, 'a')\n// -- // { b: 2, c: 3, d: 4 }\n// -- omit(obj, ['b', 'c'])\n// -- // { a: 1, d: 4 }\n// --\n// -- // The same object is returned if there are no changes:\n// -- omit(obj, 'z') === obj1\n// -- // true\n// -- ```\nfunction omit(obj, attrs) {\n    const omitList = Array.isArray(attrs) ? attrs : [\n        attrs\n    ];\n    let fDoSomething = false;\n    for(let i = 0; i < omitList.length; i++){\n        if (hasOwnProperty.call(obj, omitList[i])) {\n            fDoSomething = true;\n            break;\n        }\n    }\n    if (!fDoSomething) return obj;\n    const out = {};\n    const keys = getKeysAndSymbols(obj);\n    for(let i = 0; i < keys.length; i++){\n        const key = keys[i];\n        if (omitList.indexOf(key) >= 0) continue;\n        out[key] = obj[key];\n    }\n    return out;\n} // -- #### addDefaults()\n// -- Returns a new object built as follows: `undefined` keys in the first one\n// -- are filled in with the corresponding values from the second one\n// -- (even if they are `null`).\n// --\n// -- Usage:\n// --\n// -- * `addDefaults(obj, defaults)`\n// -- * `addDefaults(obj, ...defaultObjects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5, e: null }\n// -- obj3 = addDefaults(obj1, obj2)\n// -- // { a: 1, b: 2, c: 3, d: 5, e: null }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- addDefaults(obj1, { c: 4 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 2 args\n// Implementation and catch-all\nfunction addDefaults(a, b, c, d, e, f, ...rest) {\n    return rest.length ? doMerge.call(null, true, false, a, b, c, d, e, f, ...rest) : doMerge(true, false, a, b, c, d, e, f);\n}\nfunction doMerge(fAddDefaults, fDeep, first, ...rest) {\n    let out = first;\n    if (!(out != null)) {\n        throwStr(IS_DEV ? \"At least one object should be provided to merge()\" : INVALID_ARGS);\n    }\n    let fChanged = false;\n    for(let idx = 0; idx < rest.length; idx++){\n        const obj = rest[idx];\n        if (obj == null) continue;\n        const keys = getKeysAndSymbols(obj);\n        if (!keys.length) continue;\n        for(let j = 0; j <= keys.length; j++){\n            const key = keys[j];\n            if (fAddDefaults && out[key] !== undefined) continue;\n            let nextVal = obj[key];\n            if (fDeep && isObject(out[key]) && isObject(nextVal)) {\n                nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);\n            }\n            if (nextVal === undefined || nextVal === out[key]) continue;\n            if (!fChanged) {\n                fChanged = true;\n                out = clone(out);\n            }\n            out[key] = nextVal;\n        }\n    }\n    return out;\n} // ===============================================\n// ### Public API\n// ===============================================\nconst timm = {\n    clone,\n    addLast,\n    addFirst,\n    removeLast,\n    removeFirst,\n    insert,\n    removeAt,\n    replaceAt,\n    getIn,\n    set,\n    setIn,\n    update,\n    updateIn,\n    merge,\n    mergeDeep,\n    mergeIn,\n    omit,\n    addDefaults\n};\nvar _default = timm;\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7QUFDRjtBQUNBLElBQUkyRCxXQUFXRDtBQUNmN0Usa0JBQWUsR0FBRzhFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXItY29kZS8uL25vZGVfbW9kdWxlcy90aW1tL2xpYi90aW1tLmpzPzM4MDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLmFkZExhc3QgPSBhZGRMYXN0O1xuZXhwb3J0cy5hZGRGaXJzdCA9IGFkZEZpcnN0O1xuZXhwb3J0cy5yZW1vdmVMYXN0ID0gcmVtb3ZlTGFzdDtcbmV4cG9ydHMucmVtb3ZlRmlyc3QgPSByZW1vdmVGaXJzdDtcbmV4cG9ydHMuaW5zZXJ0ID0gaW5zZXJ0O1xuZXhwb3J0cy5yZW1vdmVBdCA9IHJlbW92ZUF0O1xuZXhwb3J0cy5yZXBsYWNlQXQgPSByZXBsYWNlQXQ7XG5leHBvcnRzLmdldEluID0gZ2V0SW47XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuc2V0SW4gPSBzZXRJbjtcbmV4cG9ydHMudXBkYXRlID0gdXBkYXRlO1xuZXhwb3J0cy51cGRhdGVJbiA9IHVwZGF0ZUluO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5tZXJnZURlZXAgPSBtZXJnZURlZXA7XG5leHBvcnRzLm1lcmdlSW4gPSBtZXJnZUluO1xuZXhwb3J0cy5vbWl0ID0gb21pdDtcbmV4cG9ydHMuYWRkRGVmYXVsdHMgPSBhZGREZWZhdWx0cztcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlcyAqL1xuXG4vKiFcbiAqIFRpbW1cbiAqXG4gKiBJbW11dGFiaWxpdHkgaGVscGVycyB3aXRoIGZhc3QgcmVhZHMgYW5kIGFjY2VwdGFibGUgd3JpdGVzLlxuICpcbiAqIEBjb3B5cmlnaHQgR3VpbGxlcm1vIEdyYXUgUGFuZWEgMjAxNlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmNvbnN0IElOVkFMSURfQVJHUyA9ICdJTlZBTElEX0FSR1MnO1xuY29uc3QgSVNfREVWID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vICMjIyBIZWxwZXJzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gdGhyb3dTdHIobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlzQW5kU3ltYm9scyhvYmopIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGtleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuY29uc3QgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gY2xvbmUob2JqMCkge1xuICAvLyBBcyBhcnJheVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmowKSkgcmV0dXJuIG9iajAuc2xpY2UoKTsgLy8gQXMgb2JqZWN0XG5cbiAgY29uc3Qgb2JqID0gb2JqMDtcbiAgY29uc3Qga2V5cyA9IGdldEtleXNBbmRTeW1ib2xzKG9iaik7XG4gIGNvbnN0IG91dCA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgb3V0W2tleV0gPSBvYmpba2V5XTtcbiAgfSAvLyBAdHMtaWdub3JlIChzZWUgdHlwZSB0ZXN0cylcblxuXG4gIHJldHVybiBvdXQ7XG59IC8vIEN1c3RvbSBndWFyZFxuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgcmV0dXJuIG8gIT0gbnVsbCAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCc7XG59IC8vIF9kZWVwRnJlZXplID0gKG9iaikgLT5cbi8vICAgT2JqZWN0LmZyZWV6ZSBvYmpcbi8vICAgZm9yIGtleSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBvYmpcbi8vICAgICB2YWwgPSBvYmpba2V5XVxuLy8gICAgIGlmIGlzT2JqZWN0KHZhbCkgYW5kIG5vdCBPYmplY3QuaXNGcm96ZW4gdmFsXG4vLyAgICAgICBfZGVlcEZyZWV6ZSB2YWxcbi8vICAgb2JqXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gLS0gIyMjIEFycmF5c1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIC0tICMjIyMgYWRkTGFzdCgpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggYW4gYXBwZW5kZWQgaXRlbSBvciBpdGVtcy5cbi8vIC0tXG4vLyAtLSBVc2FnZTogYGFkZExhc3QoYXJyYXksIHZhbClgXG4vLyAtLVxuLy8gLS0gYGBganNcbi8vIC0tIGFyciA9IFsnYScsICdiJ11cbi8vIC0tIGFycjIgPSBhZGRMYXN0KGFyciwgJ2MnKVxuLy8gLS0gLy8gWydhJywgJ2InLCAnYyddXG4vLyAtLSBhcnIyID09PSBhcnJcbi8vIC0tIC8vIGZhbHNlXG4vLyAtLSBhcnIzID0gYWRkTGFzdChhcnIsIFsnYycsICdkJ10pXG4vLyAtLSAvLyBbJ2EnLCAnYicsICdjJywgJ2QnXVxuLy8gLS0gYGBgXG4vLyBgYXJyYXkuY29uY2F0KHZhbClgIGFsc28gaGFuZGxlcyB0aGUgc2NhbGFyIGNhc2UsXG4vLyBidXQgaXMgYXBwYXJlbnRseSB2ZXJ5IHNsb3dcblxuXG5mdW5jdGlvbiBhZGRMYXN0KGFycmF5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgcmV0dXJuIGFycmF5LmNvbmNhdCh2YWwpO1xuICByZXR1cm4gYXJyYXkuY29uY2F0KFt2YWxdKTtcbn0gLy8gLS0gIyMjIyBhZGRGaXJzdCgpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggYSBwcmVwZW5kZWQgaXRlbSBvciBpdGVtcy5cbi8vIC0tXG4vLyAtLSBVc2FnZTogYGFkZEZpcnN0KGFycmF5LCB2YWwpYFxuLy8gLS1cbi8vIC0tIGBgYGpzXG4vLyAtLSBhcnIgPSBbJ2EnLCAnYiddXG4vLyAtLSBhcnIyID0gYWRkRmlyc3QoYXJyLCAnYycpXG4vLyAtLSAvLyBbJ2MnLCAnYScsICdiJ11cbi8vIC0tIGFycjIgPT09IGFyclxuLy8gLS0gLy8gZmFsc2Vcbi8vIC0tIGFycjMgPSBhZGRGaXJzdChhcnIsIFsnYycsICdkJ10pXG4vLyAtLSAvLyBbJ2MnLCAnZCcsICdhJywgJ2InXVxuLy8gLS0gYGBgXG5cblxuZnVuY3Rpb24gYWRkRmlyc3QoYXJyYXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSByZXR1cm4gdmFsLmNvbmNhdChhcnJheSk7XG4gIHJldHVybiBbdmFsXS5jb25jYXQoYXJyYXkpO1xufSAvLyAtLSAjIyMjIHJlbW92ZUxhc3QoKVxuLy8gLS0gUmV0dXJucyBhIG5ldyBhcnJheSByZW1vdmluZyB0aGUgbGFzdCBpdGVtLlxuLy8gLS1cbi8vIC0tIFVzYWdlOiBgcmVtb3ZlTGFzdChhcnJheSlgXG4vLyAtLVxuLy8gLS0gYGBganNcbi8vIC0tIGFyciA9IFsnYScsICdiJ11cbi8vIC0tIGFycjIgPSByZW1vdmVMYXN0KGFycilcbi8vIC0tIC8vIFsnYSddXG4vLyAtLSBhcnIyID09PSBhcnJcbi8vIC0tIC8vIGZhbHNlXG4vLyAtLVxuLy8gLS0gLy8gVGhlIHNhbWUgYXJyYXkgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSBhcnIzID0gW11cbi8vIC0tIHJlbW92ZUxhc3QoYXJyMykgPT09IGFycjNcbi8vIC0tIC8vIHRydWVcbi8vIC0tIGBgYFxuXG5cbmZ1bmN0aW9uIHJlbW92ZUxhc3QoYXJyYXkpIHtcbiAgaWYgKCFhcnJheS5sZW5ndGgpIHJldHVybiBhcnJheTtcbiAgcmV0dXJuIGFycmF5LnNsaWNlKDAsIGFycmF5Lmxlbmd0aCAtIDEpO1xufSAvLyAtLSAjIyMjIHJlbW92ZUZpcnN0KClcbi8vIC0tIFJldHVybnMgYSBuZXcgYXJyYXkgcmVtb3ZpbmcgdGhlIGZpcnN0IGl0ZW0uXG4vLyAtLVxuLy8gLS0gVXNhZ2U6IGByZW1vdmVGaXJzdChhcnJheSlgXG4vLyAtLVxuLy8gLS0gYGBganNcbi8vIC0tIGFyciA9IFsnYScsICdiJ11cbi8vIC0tIGFycjIgPSByZW1vdmVGaXJzdChhcnIpXG4vLyAtLSAvLyBbJ2InXVxuLy8gLS0gYXJyMiA9PT0gYXJyXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIGFycmF5IGlzIHJldHVybmVkIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VzOlxuLy8gLS0gYXJyMyA9IFtdXG4vLyAtLSByZW1vdmVGaXJzdChhcnIzKSA9PT0gYXJyM1xuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gYGBgXG5cblxuZnVuY3Rpb24gcmVtb3ZlRmlyc3QoYXJyYXkpIHtcbiAgaWYgKCFhcnJheS5sZW5ndGgpIHJldHVybiBhcnJheTtcbiAgcmV0dXJuIGFycmF5LnNsaWNlKDEpO1xufSAvLyAtLSAjIyMjIGluc2VydCgpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IGFycmF5IG9idGFpbmVkIGJ5IGluc2VydGluZyBhbiBpdGVtIG9yIGl0ZW1zXG4vLyAtLSBhdCBhIHNwZWNpZmllZCBpbmRleC5cbi8vIC0tXG4vLyAtLSBVc2FnZTogYGluc2VydChhcnJheSwgaWR4LCB2YWwpYFxuLy8gLS1cbi8vIC0tIGBgYGpzXG4vLyAtLSBhcnIgPSBbJ2EnLCAnYicsICdjJ11cbi8vIC0tIGFycjIgPSBpbnNlcnQoYXJyLCAxLCAnZCcpXG4vLyAtLSAvLyBbJ2EnLCAnZCcsICdiJywgJ2MnXVxuLy8gLS0gYXJyMiA9PT0gYXJyXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS0gaW5zZXJ0KGFyciwgMSwgWydkJywgJ2UnXSlcbi8vIC0tIC8vIFsnYScsICdkJywgJ2UnLCAnYicsICdjJ11cbi8vIC0tIGBgYFxuXG5cbmZ1bmN0aW9uIGluc2VydChhcnJheSwgaWR4LCB2YWwpIHtcbiAgcmV0dXJuIGFycmF5LnNsaWNlKDAsIGlkeCkuY29uY2F0KEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdKS5jb25jYXQoYXJyYXkuc2xpY2UoaWR4KSk7XG59IC8vIC0tICMjIyMgcmVtb3ZlQXQoKVxuLy8gLS0gUmV0dXJucyBhIG5ldyBhcnJheSBvYnRhaW5lZCBieSByZW1vdmluZyBhbiBpdGVtIGF0XG4vLyAtLSBhIHNwZWNpZmllZCBpbmRleC5cbi8vIC0tXG4vLyAtLSBVc2FnZTogYHJlbW92ZUF0KGFycmF5LCBpZHgpYFxuLy8gLS1cbi8vIC0tIGBgYGpzXG4vLyAtLSBhcnIgPSBbJ2EnLCAnYicsICdjJ11cbi8vIC0tIGFycjIgPSByZW1vdmVBdChhcnIsIDEpXG4vLyAtLSAvLyBbJ2EnLCAnYyddXG4vLyAtLSBhcnIyID09PSBhcnJcbi8vIC0tIC8vIGZhbHNlXG4vLyAtLVxuLy8gLS0gLy8gVGhlIHNhbWUgYXJyYXkgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSByZW1vdmVBdChhcnIsIDQpID09PSBhcnJcbi8vIC0tIC8vIHRydWVcbi8vIC0tIGBgYFxuXG5cbmZ1bmN0aW9uIHJlbW92ZUF0KGFycmF5LCBpZHgpIHtcbiAgaWYgKGlkeCA+PSBhcnJheS5sZW5ndGggfHwgaWR4IDwgMCkgcmV0dXJuIGFycmF5O1xuICByZXR1cm4gYXJyYXkuc2xpY2UoMCwgaWR4KS5jb25jYXQoYXJyYXkuc2xpY2UoaWR4ICsgMSkpO1xufSAvLyAtLSAjIyMjIHJlcGxhY2VBdCgpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IGFycmF5IG9idGFpbmVkIGJ5IHJlcGxhY2luZyBhbiBpdGVtIGF0XG4vLyAtLSBhIHNwZWNpZmllZCBpbmRleC4gSWYgdGhlIHByb3ZpZGVkIGl0ZW0gaXMgdGhlIHNhbWUgYXNcbi8vIC0tICgqcmVmZXJlbnRpYWxseSBlcXVhbCB0byopIHRoZSBwcmV2aW91cyBpdGVtIGF0IHRoYXQgcG9zaXRpb24sXG4vLyAtLSB0aGUgb3JpZ2luYWwgYXJyYXkgaXMgcmV0dXJuZWQuXG4vLyAtLVxuLy8gLS0gVXNhZ2U6IGByZXBsYWNlQXQoYXJyYXksIGlkeCwgbmV3SXRlbSlgXG4vLyAtLVxuLy8gLS0gYGBganNcbi8vIC0tIGFyciA9IFsnYScsICdiJywgJ2MnXVxuLy8gLS0gYXJyMiA9IHJlcGxhY2VBdChhcnIsIDEsICdkJylcbi8vIC0tIC8vIFsnYScsICdkJywgJ2MnXVxuLy8gLS0gYXJyMiA9PT0gYXJyXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlczpcbi8vIC0tIHJlcGxhY2VBdChhcnIsIDEsICdiJykgPT09IGFyclxuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gYGBgXG5cblxuZnVuY3Rpb24gcmVwbGFjZUF0KGFycmF5LCBpZHgsIG5ld0l0ZW0pIHtcbiAgaWYgKGFycmF5W2lkeF0gPT09IG5ld0l0ZW0pIHJldHVybiBhcnJheTtcbiAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBBcnJheShsZW4pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBhcnJheVtpXTtcbiAgfVxuXG4gIHJlc3VsdFtpZHhdID0gbmV3SXRlbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0gLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIC0tICMjIyBDb2xsZWN0aW9ucyAob2JqZWN0cyBhbmQgYXJyYXlzKVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIC0tICMjIyMgZ2V0SW4oKVxuLy8gLS0gUmV0dXJucyBhIHZhbHVlIGZyb20gYW4gb2JqZWN0IGF0IGEgZ2l2ZW4gcGF0aC4gV29ya3Mgd2l0aFxuLy8gLS0gbmVzdGVkIGFycmF5cyBhbmQgb2JqZWN0cy4gSWYgdGhlIHBhdGggZG9lcyBub3QgZXhpc3QsIGl0IHJldHVybnNcbi8vIC0tIGB1bmRlZmluZWRgLlxuLy8gLS1cbi8vIC0tIFVzYWdlOiBgZ2V0SW4ob2JqLCBwYXRoKWBcbi8vIC0tXG4vLyAtLSBgYGBqc1xuLy8gLS0gb2JqID0geyBhOiAxLCBiOiAyLCBkOiB7IGQxOiAzLCBkMjogNCB9LCBlOiBbJ2EnLCAnYicsICdjJ10gfVxuLy8gLS0gZ2V0SW4ob2JqLCBbJ2QnLCAnZDEnXSlcbi8vIC0tIC8vIDNcbi8vIC0tIGdldEluKG9iaiwgWydlJywgMV0pXG4vLyAtLSAvLyAnYidcbi8vIC0tIGBgYFxuXG5cbmZ1bmN0aW9uIGdldEluKG9iaiwgcGF0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICB0aHJvd1N0cihJU19ERVYgPyAnQSBwYXRoIGFycmF5IHNob3VsZCBiZSBwcm92aWRlZCB3aGVuIGNhbGxpbmcgZ2V0SW4oKScgOiBJTlZBTElEX0FSR1MpO1xuICB9XG5cbiAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuICBsZXQgcHRyID0gb2JqO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IHBhdGhbaV07XG4gICAgcHRyID0gcHRyICE9IG51bGwgPyBwdHJba2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAocHRyID09PSB1bmRlZmluZWQpIHJldHVybiBwdHI7XG4gIH1cblxuICByZXR1cm4gcHRyO1xufSAvLyAtLSAjIyMjIHNldCgpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIGEgbW9kaWZpZWQgYXR0cmlidXRlLlxuLy8gLS0gSWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIHRoZSBzYW1lIGFzICgqcmVmZXJlbnRpYWxseSBlcXVhbCB0byopXG4vLyAtLSB0aGUgcHJldmlvdXMgdmFsdWUsIHRoZSBvcmlnaW5hbCBvYmplY3QgaXMgcmV0dXJuZWQuXG4vLyAtLVxuLy8gLS0gVXNhZ2U6IGBzZXQob2JqLCBrZXksIHZhbClgXG4vLyAtLVxuLy8gLS0gYGBganNcbi8vIC0tIG9iaiA9IHsgYTogMSwgYjogMiwgYzogMyB9XG4vLyAtLSBvYmoyID0gc2V0KG9iaiwgJ2InLCA1KVxuLy8gLS0gLy8geyBhOiAxLCBiOiA1LCBjOiAzIH1cbi8vIC0tIG9iajIgPT09IG9ialxuLy8gLS0gLy8gZmFsc2Vcbi8vIC0tXG4vLyAtLSAvLyBUaGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSBzZXQob2JqLCAnYicsIDIpID09PSBvYmpcbi8vIC0tIC8vIHRydWVcbi8vIC0tIGBgYFxuLy8gV2hlbiBjYWxsZWQgd2l0aCBhbiB1bmRlZmluZWQvbnVsbCBgb2JqYCwgYHNldCgpYCByZXR1cm5zIGVpdGhlclxuLy8gYSBzaW5nbGUtZWxlbWVudCBhcnJheSwgb3IgYSBzaW5nbGUta2V5IG9iamVjdFxuXG5cbi8vIEltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiBzZXQob2JqMCwga2V5LCB2YWwpIHtcbiAgbGV0IG9iaiA9IG9iajA7XG4gIGlmIChvYmogPT0gbnVsbCkgb2JqID0gdHlwZW9mIGtleSA9PT0gJ251bWJlcicgPyBbXSA6IHt9O1xuICBpZiAob2JqW2tleV0gPT09IHZhbCkgcmV0dXJuIG9iajtcbiAgY29uc3Qgb2JqMiA9IGNsb25lKG9iaik7XG4gIG9iajJba2V5XSA9IHZhbDtcbiAgcmV0dXJuIG9iajI7XG59IC8vIC0tICMjIyMgc2V0SW4oKVxuLy8gLS0gUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBhIG1vZGlmaWVkICoqbmVzdGVkKiogYXR0cmlidXRlLlxuLy8gLS1cbi8vIC0tIE5vdGVzOlxuLy8gLS1cbi8vIC0tICogSWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIHRoZSBzYW1lIGFzICgqcmVmZXJlbnRpYWxseSBlcXVhbCB0byopXG4vLyAtLSB0aGUgcHJldmlvdXMgdmFsdWUsIHRoZSBvcmlnaW5hbCBvYmplY3QgaXMgcmV0dXJuZWQuXG4vLyAtLSAqIElmIHRoZSBwYXRoIGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsIGJlIGNyZWF0ZWQgYmVmb3JlIHNldHRpbmdcbi8vIC0tIHRoZSBuZXcgdmFsdWUuXG4vLyAtLVxuLy8gLS0gVXNhZ2U6IGBzZXRJbihvYmosIHBhdGgsIHZhbClgXG4vLyAtLVxuLy8gLS0gYGBganNcbi8vIC0tIG9iaiA9IHsgYTogMSwgYjogMiwgZDogeyBkMTogMywgZDI6IDQgfSwgZTogeyBlMTogJ2ZvbycsIGUyOiAnYmFyJyB9IH1cbi8vIC0tIG9iajIgPSBzZXRJbihvYmosIFsnZCcsICdkMSddLCA0KVxuLy8gLS0gLy8geyBhOiAxLCBiOiAyLCBkOiB7IGQxOiA0LCBkMjogNCB9LCBlOiB7IGUxOiAnZm9vJywgZTI6ICdiYXInIH0gfVxuLy8gLS0gb2JqMiA9PT0gb2JqXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS0gb2JqMi5kID09PSBvYmouZFxuLy8gLS0gLy8gZmFsc2Vcbi8vIC0tIG9iajIuZSA9PT0gb2JqLmVcbi8vIC0tIC8vIHRydWVcbi8vIC0tXG4vLyAtLSAvLyBUaGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSBvYmozID0gc2V0SW4ob2JqLCBbJ2QnLCAnZDEnXSwgMylcbi8vIC0tIC8vIHsgYTogMSwgYjogMiwgZDogeyBkMTogMywgZDI6IDQgfSwgZTogeyBlMTogJ2ZvbycsIGUyOiAnYmFyJyB9IH1cbi8vIC0tIG9iajMgPT09IG9ialxuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gb2JqMy5kID09PSBvYmouZFxuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gb2JqMy5lID09PSBvYmouZVxuLy8gLS0gLy8gdHJ1ZVxuLy8gLS1cbi8vIC0tIC8vIC4uLiB1bmtub3duIHBhdGhzIGNyZWF0ZSBpbnRlcm1lZGlhdGUga2V5cy4gTnVtZXJpYyBzZWdtZW50cyBhcmUgdHJlYXRlZCBhcyBhcnJheSBpbmRpY2VzOlxuLy8gLS0gc2V0SW4oeyBhOiAzIH0sIFsndW5rbm93bicsIDAsICdwYXRoJ10sIDQpXG4vLyAtLSAvLyB7IGE6IDMsIHVua25vd246IFt7IHBhdGg6IDQgfV0gfVxuLy8gLS0gYGBgXG5cblxuZnVuY3Rpb24gc2V0SW4ob2JqLCBwYXRoLCB2YWwpIHtcbiAgaWYgKCFwYXRoLmxlbmd0aCkgcmV0dXJuIHZhbDtcbiAgcmV0dXJuIGRvU2V0SW4ob2JqLCBwYXRoLCB2YWwsIDApO1xufVxuXG5mdW5jdGlvbiBkb1NldEluKG9iaiwgcGF0aCwgdmFsLCBpZHgpIHtcbiAgbGV0IG5ld1ZhbHVlO1xuICBjb25zdCBrZXkgPSBwYXRoW2lkeF07XG5cbiAgaWYgKGlkeCA9PT0gcGF0aC5sZW5ndGggLSAxKSB7XG4gICAgbmV3VmFsdWUgPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmVzdGVkT2JqID0gaXNPYmplY3Qob2JqKSAmJiBpc09iamVjdChvYmpba2V5XSkgPyBvYmpba2V5XSA6IHR5cGVvZiBwYXRoW2lkeCArIDFdID09PSAnbnVtYmVyJyA/IFtdIDoge307XG4gICAgbmV3VmFsdWUgPSBkb1NldEluKG5lc3RlZE9iaiwgcGF0aCwgdmFsLCBpZHggKyAxKTtcbiAgfVxuXG4gIHJldHVybiBzZXQob2JqLCBrZXksIG5ld1ZhbHVlKTtcbn0gLy8gLS0gIyMjIyB1cGRhdGUoKVxuLy8gLS0gUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBhIG1vZGlmaWVkIGF0dHJpYnV0ZSxcbi8vIC0tIGNhbGN1bGF0ZWQgdmlhIGEgdXNlci1wcm92aWRlZCBjYWxsYmFjayBiYXNlZCBvbiB0aGUgY3VycmVudCB2YWx1ZS5cbi8vIC0tIElmIHRoZSBjYWxjdWxhdGVkIHZhbHVlIGlzIHRoZSBzYW1lIGFzICgqcmVmZXJlbnRpYWxseSBlcXVhbCB0byopXG4vLyAtLSB0aGUgcHJldmlvdXMgdmFsdWUsIHRoZSBvcmlnaW5hbCBvYmplY3QgaXMgcmV0dXJuZWQuXG4vLyAtLVxuLy8gLS0gVXNhZ2U6IGB1cGRhdGUob2JqLCBrZXksIGZuVXBkYXRlKWBcbi8vIC0tXG4vLyAtLSBgYGBqc1xuLy8gLS0gb2JqID0geyBhOiAxLCBiOiAyLCBjOiAzIH1cbi8vIC0tIG9iajIgPSB1cGRhdGUob2JqLCAnYicsICh2YWwpID0+IHZhbCArIDEpXG4vLyAtLSAvLyB7IGE6IDEsIGI6IDMsIGM6IDMgfVxuLy8gLS0gb2JqMiA9PT0gb2JqXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlczpcbi8vIC0tIHVwZGF0ZShvYmosICdiJywgKHZhbCkgPT4gdmFsKSA9PT0gb2JqXG4vLyAtLSAvLyB0cnVlXG4vLyAtLSBgYGBcblxuXG5mdW5jdGlvbiB1cGRhdGUob2JqLCBrZXksIGZuVXBkYXRlKSB7XG4gIGNvbnN0IHByZXZWYWwgPSBvYmogPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9ialtrZXldO1xuICBjb25zdCBuZXh0VmFsID0gZm5VcGRhdGUocHJldlZhbCk7XG4gIHJldHVybiBzZXQob2JqLCBrZXksIG5leHRWYWwpO1xufSAvLyAtLSAjIyMjIHVwZGF0ZUluKClcbi8vIC0tIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggYSBtb2RpZmllZCAqKm5lc3RlZCoqIGF0dHJpYnV0ZSxcbi8vIC0tIGNhbGN1bGF0ZWQgdmlhIGEgdXNlci1wcm92aWRlZCBjYWxsYmFjayBiYXNlZCBvbiB0aGUgY3VycmVudCB2YWx1ZS5cbi8vIC0tIElmIHRoZSBjYWxjdWxhdGVkIHZhbHVlIGlzIHRoZSBzYW1lIGFzICgqcmVmZXJlbnRpYWxseSBlcXVhbCB0byopXG4vLyAtLSB0aGUgcHJldmlvdXMgdmFsdWUsIHRoZSBvcmlnaW5hbCBvYmplY3QgaXMgcmV0dXJuZWQuXG4vLyAtLVxuLy8gLS0gVXNhZ2U6IGB1cGRhdGVJbjxUOiBBcnJheU9yT2JqZWN0PihvYmo6IFQsIHBhdGg6IEFycmF5PEtleT4sXG4vLyAtLSBmblVwZGF0ZTogKHByZXZWYWx1ZTogYW55KSA9PiBhbnkpOiBUYFxuLy8gLS1cbi8vIC0tIGBgYGpzXG4vLyAtLSBvYmogPSB7IGE6IDEsIGQ6IHsgZDE6IDMsIGQyOiA0IH0gfVxuLy8gLS0gb2JqMiA9IHVwZGF0ZUluKG9iaiwgWydkJywgJ2QxJ10sICh2YWwpID0+IHZhbCArIDEpXG4vLyAtLSAvLyB7IGE6IDEsIGQ6IHsgZDE6IDQsIGQyOiA0IH0gfVxuLy8gLS0gb2JqMiA9PT0gb2JqXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlczpcbi8vIC0tIG9iajMgPSB1cGRhdGVJbihvYmosIFsnZCcsICdkMSddLCAodmFsKSA9PiB2YWwpXG4vLyAtLSAvLyB7IGE6IDEsIGQ6IHsgZDE6IDMsIGQyOiA0IH0gfVxuLy8gLS0gb2JqMyA9PT0gb2JqXG4vLyAtLSAvLyB0cnVlXG4vLyAtLSBgYGBcblxuXG5mdW5jdGlvbiB1cGRhdGVJbihvYmosIHBhdGgsIGZuVXBkYXRlKSB7XG4gIGNvbnN0IHByZXZWYWwgPSBnZXRJbihvYmosIHBhdGgpO1xuICBjb25zdCBuZXh0VmFsID0gZm5VcGRhdGUocHJldlZhbCk7XG4gIHJldHVybiBzZXRJbihvYmosIHBhdGgsIG5leHRWYWwpO1xufSAvLyAtLSAjIyMjIG1lcmdlKClcbi8vIC0tIFJldHVybnMgYSBuZXcgb2JqZWN0IGJ1aWx0IGFzIGZvbGxvd3M6IHRoZSBvdmVybGFwcGluZyBrZXlzIGZyb20gdGhlXG4vLyAtLSBzZWNvbmQgb25lIG92ZXJ3cml0ZSB0aGUgY29ycmVzcG9uZGluZyBlbnRyaWVzIGZyb20gdGhlIGZpcnN0IG9uZS5cbi8vIC0tIFNpbWlsYXIgdG8gYE9iamVjdC5hc3NpZ24oKWAsIGJ1dCBpbW11dGFibGUuXG4vLyAtLVxuLy8gLS0gVXNhZ2U6XG4vLyAtLVxuLy8gLS0gKiBgbWVyZ2Uob2JqMSwgb2JqMilgXG4vLyAtLSAqIGBtZXJnZShvYmoxLCAuLi5vYmplY3RzKWBcbi8vIC0tXG4vLyAtLSBUaGUgdW5tb2RpZmllZCBgb2JqMWAgaXMgcmV0dXJuZWQgaWYgYG9iajJgIGRvZXMgbm90ICpwcm92aWRlIHNvbWV0aGluZ1xuLy8gLS0gbmV3IHRvKiBgb2JqMWAsIGkuZS4gaWYgZWl0aGVyIG9mIHRoZSBmb2xsb3dpbmdcbi8vIC0tIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4vLyAtLVxuLy8gLS0gKiBgb2JqMmAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgXG4vLyAtLSAqIGBvYmoyYCBpcyBhbiBvYmplY3QsIGJ1dCBpdCBpcyBlbXB0eVxuLy8gLS0gKiBBbGwgYXR0cmlidXRlcyBvZiBgb2JqMmAgYXJlIGB1bmRlZmluZWRgXG4vLyAtLSAqIEFsbCBhdHRyaWJ1dGVzIG9mIGBvYmoyYCBhcmUgcmVmZXJlbnRpYWxseSBlcXVhbCB0byB0aGVcbi8vIC0tICAgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVzIG9mIGBvYmoxYFxuLy8gLS1cbi8vIC0tIE5vdGUgdGhhdCBgdW5kZWZpbmVkYCBhdHRyaWJ1dGVzIGluIGBvYmoyYCBkbyBub3QgbW9kaWZ5IHRoZVxuLy8gLS0gY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVzIGluIGBvYmoxYC5cbi8vIC0tXG4vLyAtLSBgYGBqc1xuLy8gLS0gb2JqMSA9IHsgYTogMSwgYjogMiwgYzogMyB9XG4vLyAtLSBvYmoyID0geyBjOiA0LCBkOiA1IH1cbi8vIC0tIG9iajMgPSBtZXJnZShvYmoxLCBvYmoyKVxuLy8gLS0gLy8geyBhOiAxLCBiOiAyLCBjOiA0LCBkOiA1IH1cbi8vIC0tIG9iajMgPT09IG9iajFcbi8vIC0tIC8vIGZhbHNlXG4vLyAtLVxuLy8gLS0gLy8gVGhlIHNhbWUgb2JqZWN0IGlzIHJldHVybmVkIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VzOlxuLy8gLS0gbWVyZ2Uob2JqMSwgeyBjOiAzIH0pID09PSBvYmoxXG4vLyAtLSAvLyB0cnVlXG4vLyAtLSBgYGBcbi8vIFNpZ25hdHVyZXM6XG4vLyAtIDEgYXJnXG5cblxuLy8gSW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIG1lcmdlKGEsIGIsIGMsIGQsIGUsIGYsIC4uLnJlc3QpIHtcbiAgcmV0dXJuIHJlc3QubGVuZ3RoID8gZG9NZXJnZS5jYWxsKG51bGwsIGZhbHNlLCBmYWxzZSwgYSwgYiwgYywgZCwgZSwgZiwgLi4ucmVzdCkgOiBkb01lcmdlKGZhbHNlLCBmYWxzZSwgYSwgYiwgYywgZCwgZSwgZik7XG59IC8vIC0tICMjIyMgbWVyZ2VEZWVwKClcbi8vIC0tIFJldHVybnMgYSBuZXcgb2JqZWN0IGJ1aWx0IGFzIGZvbGxvd3M6IHRoZSBvdmVybGFwcGluZyBrZXlzIGZyb20gdGhlXG4vLyAtLSBzZWNvbmQgb25lIG92ZXJ3cml0ZSB0aGUgY29ycmVzcG9uZGluZyBlbnRyaWVzIGZyb20gdGhlIGZpcnN0IG9uZS5cbi8vIC0tIElmIGJvdGggdGhlIGZpcnN0IGFuZCBzZWNvbmQgZW50cmllcyBhcmUgb2JqZWN0cyB0aGV5IGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuXG4vLyAtLSBTaW1pbGFyIHRvIGBPYmplY3QuYXNzaWduKClgLCBidXQgaW1tdXRhYmxlLCBhbmQgZGVlcGx5IG1lcmdpbmcuXG4vLyAtLVxuLy8gLS0gVXNhZ2U6XG4vLyAtLVxuLy8gLS0gKiBgbWVyZ2VEZWVwKG9iajEsIG9iajIpYFxuLy8gLS0gKiBgbWVyZ2VEZWVwKG9iajEsIC4uLm9iamVjdHMpYFxuLy8gLS1cbi8vIC0tIFRoZSB1bm1vZGlmaWVkIGBvYmoxYCBpcyByZXR1cm5lZCBpZiBgb2JqMmAgZG9lcyBub3QgKnByb3ZpZGUgc29tZXRoaW5nXG4vLyAtLSBuZXcgdG8qIGBvYmoxYCwgaS5lLiBpZiBlaXRoZXIgb2YgdGhlIGZvbGxvd2luZ1xuLy8gLS0gY29uZGl0aW9ucyBhcmUgdHJ1ZTpcbi8vIC0tXG4vLyAtLSAqIGBvYmoyYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGBcbi8vIC0tICogYG9iajJgIGlzIGFuIG9iamVjdCwgYnV0IGl0IGlzIGVtcHR5XG4vLyAtLSAqIEFsbCBhdHRyaWJ1dGVzIG9mIGBvYmoyYCBhcmUgYHVuZGVmaW5lZGBcbi8vIC0tICogQWxsIGF0dHJpYnV0ZXMgb2YgYG9iajJgIGFyZSByZWZlcmVudGlhbGx5IGVxdWFsIHRvIHRoZVxuLy8gLS0gICBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZXMgb2YgYG9iajFgXG4vLyAtLVxuLy8gLS0gTm90ZSB0aGF0IGB1bmRlZmluZWRgIGF0dHJpYnV0ZXMgaW4gYG9iajJgIGRvIG5vdCBtb2RpZnkgdGhlXG4vLyAtLSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZXMgaW4gYG9iajFgLlxuLy8gLS1cbi8vIC0tIGBgYGpzXG4vLyAtLSBvYmoxID0geyBhOiAxLCBiOiAyLCBjOiB7IGE6IDEgfSB9XG4vLyAtLSBvYmoyID0geyBiOiAzLCBjOiB7IGI6IDIgfSB9XG4vLyAtLSBvYmozID0gbWVyZ2VEZWVwKG9iajEsIG9iajIpXG4vLyAtLSAvLyB7IGE6IDEsIGI6IDMsIGM6IHsgYTogMSwgYjogMiB9ICB9XG4vLyAtLSBvYmozID09PSBvYmoxXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlczpcbi8vIC0tIG1lcmdlRGVlcChvYmoxLCB7IGM6IHsgYTogMSB9IH0pID09PSBvYmoxXG4vLyAtLSAvLyB0cnVlXG4vLyAtLSBgYGBcblxuXG5mdW5jdGlvbiBtZXJnZURlZXAoYSwgYiwgYywgZCwgZSwgZiwgLi4ucmVzdCkge1xuICByZXR1cm4gcmVzdC5sZW5ndGggPyBkb01lcmdlLmNhbGwobnVsbCwgZmFsc2UsIHRydWUsIGEsIGIsIGMsIGQsIGUsIGYsIC4uLnJlc3QpIDogZG9NZXJnZShmYWxzZSwgdHJ1ZSwgYSwgYiwgYywgZCwgZSwgZik7XG59IC8vIC0tICMjIyMgbWVyZ2VJbigpXG4vLyAtLSBTaW1pbGFyIHRvIGBtZXJnZSgpYCwgYnV0IG1lcmdpbmcgdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gbmVzdGVkIHBhdGguXG4vLyAtLVxuLy8gLS0gVXNhZ2UgZXhhbXBsZXM6XG4vLyAtLVxuLy8gLS0gKiBgbWVyZ2VJbihvYmoxLCBwYXRoLCBvYmoyKWBcbi8vIC0tICogYG1lcmdlSW4ob2JqMSwgcGF0aCwgLi4ub2JqZWN0cylgXG4vLyAtLVxuLy8gLS0gYGBganNcbi8vIC0tIG9iajEgPSB7IGE6IDEsIGQ6IHsgYjogeyBkMTogMywgZDI6IDQgfSB9IH1cbi8vIC0tIG9iajIgPSB7IGQzOiA1IH1cbi8vIC0tIG9iajMgPSBtZXJnZUluKG9iajEsIFsnZCcsICdiJ10sIG9iajIpXG4vLyAtLSAvLyB7IGE6IDEsIGQ6IHsgYjogeyBkMTogMywgZDI6IDQsIGQzOiA1IH0gfSB9XG4vLyAtLSBvYmozID09PSBvYmoxXG4vLyAtLSAvLyBmYWxzZVxuLy8gLS1cbi8vIC0tIC8vIFRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlczpcbi8vIC0tIG1lcmdlSW4ob2JqMSwgWydkJywgJ2InXSwgeyBkMjogNCB9KSA9PT0gb2JqMVxuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gYGBgXG5cblxuZnVuY3Rpb24gbWVyZ2VJbihhLCBwYXRoLCBiLCBjLCBkLCBlLCBmLCAuLi5yZXN0KSB7XG4gIGxldCBwcmV2VmFsID0gZ2V0SW4oYSwgcGF0aCk7XG4gIGlmIChwcmV2VmFsID09IG51bGwpIHByZXZWYWwgPSB7fTtcbiAgbGV0IG5leHRWYWw7XG5cbiAgaWYgKHJlc3QubGVuZ3RoKSB7XG4gICAgbmV4dFZhbCA9IGRvTWVyZ2UuY2FsbChudWxsLCBmYWxzZSwgZmFsc2UsIHByZXZWYWwsIGIsIGMsIGQsIGUsIGYsIC4uLnJlc3QpO1xuICB9IGVsc2Uge1xuICAgIG5leHRWYWwgPSBkb01lcmdlKGZhbHNlLCBmYWxzZSwgcHJldlZhbCwgYiwgYywgZCwgZSwgZik7XG4gIH1cblxuICByZXR1cm4gc2V0SW4oYSwgcGF0aCwgbmV4dFZhbCk7XG59IC8vIC0tICMjIyMgb21pdCgpXG4vLyAtLSBSZXR1cm5zIGFuIG9iamVjdCBleGNsdWRpbmcgb25lIG9yIHNldmVyYWwgYXR0cmlidXRlcy5cbi8vIC0tXG4vLyAtLSBVc2FnZTogYG9taXQob2JqLCBhdHRycylgXG4vL1xuLy8gLS0gYGBganNcbi8vIC0tIG9iaiA9IHsgYTogMSwgYjogMiwgYzogMywgZDogNCB9XG4vLyAtLSBvbWl0KG9iaiwgJ2EnKVxuLy8gLS0gLy8geyBiOiAyLCBjOiAzLCBkOiA0IH1cbi8vIC0tIG9taXQob2JqLCBbJ2InLCAnYyddKVxuLy8gLS0gLy8geyBhOiAxLCBkOiA0IH1cbi8vIC0tXG4vLyAtLSAvLyBUaGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSBvbWl0KG9iaiwgJ3onKSA9PT0gb2JqMVxuLy8gLS0gLy8gdHJ1ZVxuLy8gLS0gYGBgXG5cblxuZnVuY3Rpb24gb21pdChvYmosIGF0dHJzKSB7XG4gIGNvbnN0IG9taXRMaXN0ID0gQXJyYXkuaXNBcnJheShhdHRycykgPyBhdHRycyA6IFthdHRyc107XG4gIGxldCBmRG9Tb21ldGhpbmcgPSBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG9taXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBvbWl0TGlzdFtpXSkpIHtcbiAgICAgIGZEb1NvbWV0aGluZyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIWZEb1NvbWV0aGluZykgcmV0dXJuIG9iajtcbiAgY29uc3Qgb3V0ID0ge307XG4gIGNvbnN0IGtleXMgPSBnZXRLZXlzQW5kU3ltYm9scyhvYmopO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgaWYgKG9taXRMaXN0LmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICBvdXRba2V5XSA9IG9ialtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn0gLy8gLS0gIyMjIyBhZGREZWZhdWx0cygpXG4vLyAtLSBSZXR1cm5zIGEgbmV3IG9iamVjdCBidWlsdCBhcyBmb2xsb3dzOiBgdW5kZWZpbmVkYCBrZXlzIGluIHRoZSBmaXJzdCBvbmVcbi8vIC0tIGFyZSBmaWxsZWQgaW4gd2l0aCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMgZnJvbSB0aGUgc2Vjb25kIG9uZVxuLy8gLS0gKGV2ZW4gaWYgdGhleSBhcmUgYG51bGxgKS5cbi8vIC0tXG4vLyAtLSBVc2FnZTpcbi8vIC0tXG4vLyAtLSAqIGBhZGREZWZhdWx0cyhvYmosIGRlZmF1bHRzKWBcbi8vIC0tICogYGFkZERlZmF1bHRzKG9iaiwgLi4uZGVmYXVsdE9iamVjdHMpYFxuLy8gLS1cbi8vIC0tIGBgYGpzXG4vLyAtLSBvYmoxID0geyBhOiAxLCBiOiAyLCBjOiAzIH1cbi8vIC0tIG9iajIgPSB7IGM6IDQsIGQ6IDUsIGU6IG51bGwgfVxuLy8gLS0gb2JqMyA9IGFkZERlZmF1bHRzKG9iajEsIG9iajIpXG4vLyAtLSAvLyB7IGE6IDEsIGI6IDIsIGM6IDMsIGQ6IDUsIGU6IG51bGwgfVxuLy8gLS0gb2JqMyA9PT0gb2JqMVxuLy8gLS0gLy8gZmFsc2Vcbi8vIC0tXG4vLyAtLSAvLyBUaGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXM6XG4vLyAtLSBhZGREZWZhdWx0cyhvYmoxLCB7IGM6IDQgfSkgPT09IG9iajFcbi8vIC0tIC8vIHRydWVcbi8vIC0tIGBgYFxuLy8gU2lnbmF0dXJlczpcbi8vIC0gMiBhcmdzXG5cblxuLy8gSW1wbGVtZW50YXRpb24gYW5kIGNhdGNoLWFsbFxuZnVuY3Rpb24gYWRkRGVmYXVsdHMoYSwgYiwgYywgZCwgZSwgZiwgLi4ucmVzdCkge1xuICByZXR1cm4gcmVzdC5sZW5ndGggPyBkb01lcmdlLmNhbGwobnVsbCwgdHJ1ZSwgZmFsc2UsIGEsIGIsIGMsIGQsIGUsIGYsIC4uLnJlc3QpIDogZG9NZXJnZSh0cnVlLCBmYWxzZSwgYSwgYiwgYywgZCwgZSwgZik7XG59XG5cbmZ1bmN0aW9uIGRvTWVyZ2UoZkFkZERlZmF1bHRzLCBmRGVlcCwgZmlyc3QsIC4uLnJlc3QpIHtcbiAgbGV0IG91dCA9IGZpcnN0O1xuXG4gIGlmICghKG91dCAhPSBudWxsKSkge1xuICAgIHRocm93U3RyKElTX0RFViA/ICdBdCBsZWFzdCBvbmUgb2JqZWN0IHNob3VsZCBiZSBwcm92aWRlZCB0byBtZXJnZSgpJyA6IElOVkFMSURfQVJHUyk7XG4gIH1cblxuICBsZXQgZkNoYW5nZWQgPSBmYWxzZTtcblxuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCByZXN0Lmxlbmd0aDsgaWR4KyspIHtcbiAgICBjb25zdCBvYmogPSByZXN0W2lkeF07XG4gICAgaWYgKG9iaiA9PSBudWxsKSBjb250aW51ZTtcbiAgICBjb25zdCBrZXlzID0gZ2V0S2V5c0FuZFN5bWJvbHMob2JqKTtcbiAgICBpZiAoIWtleXMubGVuZ3RoKSBjb250aW51ZTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbal07XG4gICAgICBpZiAoZkFkZERlZmF1bHRzICYmIG91dFtrZXldICE9PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgbGV0IG5leHRWYWwgPSBvYmpba2V5XTtcblxuICAgICAgaWYgKGZEZWVwICYmIGlzT2JqZWN0KG91dFtrZXldKSAmJiBpc09iamVjdChuZXh0VmFsKSkge1xuICAgICAgICBuZXh0VmFsID0gZG9NZXJnZShmQWRkRGVmYXVsdHMsIGZEZWVwLCBvdXRba2V5XSwgbmV4dFZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0VmFsID09PSB1bmRlZmluZWQgfHwgbmV4dFZhbCA9PT0gb3V0W2tleV0pIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoIWZDaGFuZ2VkKSB7XG4gICAgICAgIGZDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgb3V0ID0gY2xvbmUob3V0KTtcbiAgICAgIH1cblxuICAgICAgb3V0W2tleV0gPSBuZXh0VmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAjIyMgUHVibGljIEFQSVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG5jb25zdCB0aW1tID0ge1xuICBjbG9uZSxcbiAgYWRkTGFzdCxcbiAgYWRkRmlyc3QsXG4gIHJlbW92ZUxhc3QsXG4gIHJlbW92ZUZpcnN0LFxuICBpbnNlcnQsXG4gIHJlbW92ZUF0LFxuICByZXBsYWNlQXQsXG4gIGdldEluLFxuICBzZXQsXG4gIHNldEluLFxuICB1cGRhdGUsXG4gIHVwZGF0ZUluLFxuICBtZXJnZSxcbiAgbWVyZ2VEZWVwLFxuICBtZXJnZUluLFxuICBvbWl0LFxuICBhZGREZWZhdWx0c1xufTtcbnZhciBfZGVmYXVsdCA9IHRpbW07XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjbG9uZSIsImFkZExhc3QiLCJhZGRGaXJzdCIsInJlbW92ZUxhc3QiLCJyZW1vdmVGaXJzdCIsImluc2VydCIsInJlbW92ZUF0IiwicmVwbGFjZUF0IiwiZ2V0SW4iLCJzZXQiLCJzZXRJbiIsInVwZGF0ZSIsInVwZGF0ZUluIiwibWVyZ2UiLCJtZXJnZURlZXAiLCJtZXJnZUluIiwib21pdCIsImFkZERlZmF1bHRzIiwiZGVmYXVsdCIsIklOVkFMSURfQVJHUyIsIklTX0RFViIsInByb2Nlc3MiLCJ0aHJvd1N0ciIsIm1zZyIsIkVycm9yIiwiZ2V0S2V5c0FuZFN5bWJvbHMiLCJvYmoiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiY29uY2F0IiwiaGFzT3duUHJvcGVydHkiLCJvYmowIiwiQXJyYXkiLCJpc0FycmF5Iiwic2xpY2UiLCJvdXQiLCJpIiwibGVuZ3RoIiwia2V5IiwiaXNPYmplY3QiLCJvIiwiYXJyYXkiLCJ2YWwiLCJpZHgiLCJuZXdJdGVtIiwibGVuIiwicmVzdWx0IiwicGF0aCIsInVuZGVmaW5lZCIsInB0ciIsIm9iajIiLCJkb1NldEluIiwibmV3VmFsdWUiLCJuZXN0ZWRPYmoiLCJmblVwZGF0ZSIsInByZXZWYWwiLCJuZXh0VmFsIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwicmVzdCIsImRvTWVyZ2UiLCJjYWxsIiwiYXR0cnMiLCJvbWl0TGlzdCIsImZEb1NvbWV0aGluZyIsImluZGV4T2YiLCJmQWRkRGVmYXVsdHMiLCJmRGVlcCIsImZpcnN0IiwiZkNoYW5nZWQiLCJqIiwidGltbSIsIl9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/timm/lib/timm.js\n");

/***/ })

};
;