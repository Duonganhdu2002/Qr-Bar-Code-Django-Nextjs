"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pixelmatch";
exports.ids = ["vendor-chunks/pixelmatch"];
exports.modules = {

/***/ "(ssr)/./node_modules/pixelmatch/index.js":
/*!******************************************!*\
  !*** ./node_modules/pixelmatch/index.js ***!
  \******************************************/
/***/ ((module) => {

eval("\nmodule.exports = pixelmatch;\nfunction pixelmatch(img1, img2, output, width, height, options) {\n    if (!options) options = {};\n    var threshold = options.threshold === undefined ? 0.1 : options.threshold;\n    // maximum acceptable square distance between two colors;\n    // 35215 is the maximum possible value for the YIQ difference metric\n    var maxDelta = 35215 * threshold * threshold, diff = 0;\n    // compare each pixel of one image against the other one\n    for(var y = 0; y < height; y++){\n        for(var x = 0; x < width; x++){\n            var pos = (y * width + x) * 4;\n            // squared YUV distance between colors at this pixel position\n            var delta = colorDelta(img1, img2, pos, pos);\n            // the color difference is above the threshold\n            if (delta > maxDelta) {\n                // check it's a real rendering difference or just anti-aliasing\n                if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) || antialiased(img2, x, y, width, height, img1))) {\n                    // one of the pixels is anti-aliasing; draw as yellow and do not count as difference\n                    if (output) drawPixel(output, pos, 255, 255, 0);\n                } else {\n                    // found substantial difference not caused by anti-aliasing; draw it as red\n                    if (output) drawPixel(output, pos, 255, 0, 0);\n                    diff++;\n                }\n            } else if (output) {\n                // pixels are similar; draw background as grayscale image blended with white\n                var val = blend(grayPixel(img1, pos), 0.1);\n                drawPixel(output, pos, val, val, val);\n            }\n        }\n    }\n    // return the number of different pixels\n    return diff;\n}\n// check if a pixel is likely a part of anti-aliasing;\n// based on \"Anti-aliased Pixel and Intensity Slope Detector\" paper by V. Vysniauskas, 2009\nfunction antialiased(img, x1, y1, width, height, img2) {\n    var x0 = Math.max(x1 - 1, 0), y0 = Math.max(y1 - 1, 0), x2 = Math.min(x1 + 1, width - 1), y2 = Math.min(y1 + 1, height - 1), pos = (y1 * width + x1) * 4, zeroes = 0, positives = 0, negatives = 0, min = 0, max = 0, minX, minY, maxX, maxY;\n    // go through 8 adjacent pixels\n    for(var x = x0; x <= x2; x++){\n        for(var y = y0; y <= y2; y++){\n            if (x === x1 && y === y1) continue;\n            // brightness delta between the center pixel and adjacent one\n            var delta = colorDelta(img, img, pos, (y * width + x) * 4, true);\n            // count the number of equal, darker and brighter adjacent pixels\n            if (delta === 0) zeroes++;\n            else if (delta < 0) negatives++;\n            else if (delta > 0) positives++;\n            // if found more than 2 equal siblings, it's definitely not anti-aliasing\n            if (zeroes > 2) return false;\n            if (!img2) continue;\n            // remember the darkest pixel\n            if (delta < min) {\n                min = delta;\n                minX = x;\n                minY = y;\n            }\n            // remember the brightest pixel\n            if (delta > max) {\n                max = delta;\n                maxX = x;\n                maxY = y;\n            }\n        }\n    }\n    if (!img2) return true;\n    // if there are no both darker and brighter pixels among siblings, it's not anti-aliasing\n    if (negatives === 0 || positives === 0) return false;\n    // if either the darkest or the brightest pixel has more than 2 equal siblings in both images\n    // (definitely not anti-aliased), this pixel is anti-aliased\n    return !antialiased(img, minX, minY, width, height) && !antialiased(img2, minX, minY, width, height) || !antialiased(img, maxX, maxY, width, height) && !antialiased(img2, maxX, maxY, width, height);\n}\n// calculate color difference according to the paper \"Measuring perceived color difference\n// using YIQ NTSC transmission color space in mobile applications\" by Y. Kotsarenko and F. Ramos\nfunction colorDelta(img1, img2, k, m, yOnly) {\n    var a1 = img1[k + 3] / 255, a2 = img2[m + 3] / 255, r1 = blend(img1[k + 0], a1), g1 = blend(img1[k + 1], a1), b1 = blend(img1[k + 2], a1), r2 = blend(img2[m + 0], a2), g2 = blend(img2[m + 1], a2), b2 = blend(img2[m + 2], a2), y = rgb2y(r1, g1, b1) - rgb2y(r2, g2, b2);\n    if (yOnly) return y; // brightness difference only\n    var i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2), q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);\n    return 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;\n}\nfunction rgb2y(r, g, b) {\n    return r * 0.29889531 + g * 0.58662247 + b * 0.11448223;\n}\nfunction rgb2i(r, g, b) {\n    return r * 0.59597799 - g * 0.27417610 - b * 0.32180189;\n}\nfunction rgb2q(r, g, b) {\n    return r * 0.21147017 - g * 0.52261711 + b * 0.31114694;\n}\n// blend semi-transparent color with white\nfunction blend(c, a) {\n    return 255 + (c - 255) * a;\n}\nfunction drawPixel(output, pos, r, g, b) {\n    output[pos + 0] = r;\n    output[pos + 1] = g;\n    output[pos + 2] = b;\n    output[pos + 3] = 255;\n}\nfunction grayPixel(img, i) {\n    var a = img[i + 3] / 255, r = blend(img[i + 0], a), g = blend(img[i + 1], a), b = blend(img[i + 2], a);\n    return rgb2y(r, g, b);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGl4ZWxtYXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLFNBQVNBLFdBQVdDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxPQUFPO0lBRTFELElBQUksQ0FBQ0EsU0FBU0EsVUFBVSxDQUFDO0lBRXpCLElBQUlDLFlBQVlELFFBQVFDLFNBQVMsS0FBS0MsWUFBWSxNQUFNRixRQUFRQyxTQUFTO0lBRXpFLHlEQUF5RDtJQUN6RCxvRUFBb0U7SUFDcEUsSUFBSUUsV0FBVyxRQUFRRixZQUFZQSxXQUMvQkcsT0FBTztJQUVYLHdEQUF3RDtJQUN4RCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sUUFBUU0sSUFBSztRQUM3QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVIsT0FBT1EsSUFBSztZQUU1QixJQUFJQyxNQUFNLENBQUNGLElBQUlQLFFBQVFRLENBQUFBLElBQUs7WUFFNUIsNkRBQTZEO1lBQzdELElBQUlFLFFBQVFDLFdBQVdkLE1BQU1DLE1BQU1XLEtBQUtBO1lBRXhDLDhDQUE4QztZQUM5QyxJQUFJQyxRQUFRTCxVQUFVO2dCQUNsQiwrREFBK0Q7Z0JBQy9ELElBQUksQ0FBQ0gsUUFBUVUsU0FBUyxJQUFLQyxDQUFBQSxZQUFZaEIsTUFBTVcsR0FBR0QsR0FBR1AsT0FBT0MsUUFBUUgsU0FDL0NlLFlBQVlmLE1BQU1VLEdBQUdELEdBQUdQLE9BQU9DLFFBQVFKLEtBQUksR0FBSTtvQkFDOUQsb0ZBQW9GO29CQUNwRixJQUFJRSxRQUFRZSxVQUFVZixRQUFRVSxLQUFLLEtBQUssS0FBSztnQkFFakQsT0FBTztvQkFDSCwyRUFBMkU7b0JBQzNFLElBQUlWLFFBQVFlLFVBQVVmLFFBQVFVLEtBQUssS0FBSyxHQUFHO29CQUMzQ0g7Z0JBQ0o7WUFFSixPQUFPLElBQUlQLFFBQVE7Z0JBQ2YsNEVBQTRF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QUN0QjtBQUVBLFNBQVNRLFVBQVVDLEdBQUcsRUFBRTZCLENBQUM7SUFDckIsSUFBSVEsSUFBSXJDLEdBQUcsQ0FBQzZCLElBQUksRUFBRSxHQUFHLEtBQ2pCSSxJQUFJbkMsTUFBTUUsR0FBRyxDQUFDNkIsSUFBSSxFQUFFLEVBQUVRLElBQ3RCSCxJQUFJcEMsTUFBTUUsR0FBRyxDQUFDNkIsSUFBSSxFQUFFLEVBQUVRLElBQ3RCRixJQUFJckMsTUFBTUUsR0FBRyxDQUFDNkIsSUFBSSxFQUFFLEVBQUVRO0lBQzFCLE9BQU9ULE1BQU1LLEdBQUdDLEdBQUdDO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXItY29kZS8uL25vZGVfbW9kdWxlcy9waXhlbG1hdGNoL2luZGV4LmpzP2Y3NTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBpeGVsbWF0Y2g7XG5cbmZ1bmN0aW9uIHBpeGVsbWF0Y2goaW1nMSwgaW1nMiwgb3V0cHV0LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG5cbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblxuICAgIHZhciB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCA9PT0gdW5kZWZpbmVkID8gMC4xIDogb3B0aW9ucy50aHJlc2hvbGQ7XG5cbiAgICAvLyBtYXhpbXVtIGFjY2VwdGFibGUgc3F1YXJlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGNvbG9ycztcbiAgICAvLyAzNTIxNSBpcyB0aGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBmb3IgdGhlIFlJUSBkaWZmZXJlbmNlIG1ldHJpY1xuICAgIHZhciBtYXhEZWx0YSA9IDM1MjE1ICogdGhyZXNob2xkICogdGhyZXNob2xkLFxuICAgICAgICBkaWZmID0gMDtcblxuICAgIC8vIGNvbXBhcmUgZWFjaCBwaXhlbCBvZiBvbmUgaW1hZ2UgYWdhaW5zdCB0aGUgb3RoZXIgb25lXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcblxuICAgICAgICAgICAgdmFyIHBvcyA9ICh5ICogd2lkdGggKyB4KSAqIDQ7XG5cbiAgICAgICAgICAgIC8vIHNxdWFyZWQgWVVWIGRpc3RhbmNlIGJldHdlZW4gY29sb3JzIGF0IHRoaXMgcGl4ZWwgcG9zaXRpb25cbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGNvbG9yRGVsdGEoaW1nMSwgaW1nMiwgcG9zLCBwb3MpO1xuXG4gICAgICAgICAgICAvLyB0aGUgY29sb3IgZGlmZmVyZW5jZSBpcyBhYm92ZSB0aGUgdGhyZXNob2xkXG4gICAgICAgICAgICBpZiAoZGVsdGEgPiBtYXhEZWx0YSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGl0J3MgYSByZWFsIHJlbmRlcmluZyBkaWZmZXJlbmNlIG9yIGp1c3QgYW50aS1hbGlhc2luZ1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5pbmNsdWRlQUEgJiYgKGFudGlhbGlhc2VkKGltZzEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGltZzIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFudGlhbGlhc2VkKGltZzIsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGltZzEpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmUgb2YgdGhlIHBpeGVscyBpcyBhbnRpLWFsaWFzaW5nOyBkcmF3IGFzIHllbGxvdyBhbmQgZG8gbm90IGNvdW50IGFzIGRpZmZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dCkgZHJhd1BpeGVsKG91dHB1dCwgcG9zLCAyNTUsIDI1NSwgMCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBzdWJzdGFudGlhbCBkaWZmZXJlbmNlIG5vdCBjYXVzZWQgYnkgYW50aS1hbGlhc2luZzsgZHJhdyBpdCBhcyByZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dCkgZHJhd1BpeGVsKG91dHB1dCwgcG9zLCAyNTUsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICBkaWZmKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIC8vIHBpeGVscyBhcmUgc2ltaWxhcjsgZHJhdyBiYWNrZ3JvdW5kIGFzIGdyYXlzY2FsZSBpbWFnZSBibGVuZGVkIHdpdGggd2hpdGVcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gYmxlbmQoZ3JheVBpeGVsKGltZzEsIHBvcyksIDAuMSk7XG4gICAgICAgICAgICAgICAgZHJhd1BpeGVsKG91dHB1dCwgcG9zLCB2YWwsIHZhbCwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVudCBwaXhlbHNcbiAgICByZXR1cm4gZGlmZjtcbn1cblxuLy8gY2hlY2sgaWYgYSBwaXhlbCBpcyBsaWtlbHkgYSBwYXJ0IG9mIGFudGktYWxpYXNpbmc7XG4vLyBiYXNlZCBvbiBcIkFudGktYWxpYXNlZCBQaXhlbCBhbmQgSW50ZW5zaXR5IFNsb3BlIERldGVjdG9yXCIgcGFwZXIgYnkgVi4gVnlzbmlhdXNrYXMsIDIwMDlcblxuZnVuY3Rpb24gYW50aWFsaWFzZWQoaW1nLCB4MSwgeTEsIHdpZHRoLCBoZWlnaHQsIGltZzIpIHtcbiAgICB2YXIgeDAgPSBNYXRoLm1heCh4MSAtIDEsIDApLFxuICAgICAgICB5MCA9IE1hdGgubWF4KHkxIC0gMSwgMCksXG4gICAgICAgIHgyID0gTWF0aC5taW4oeDEgKyAxLCB3aWR0aCAtIDEpLFxuICAgICAgICB5MiA9IE1hdGgubWluKHkxICsgMSwgaGVpZ2h0IC0gMSksXG4gICAgICAgIHBvcyA9ICh5MSAqIHdpZHRoICsgeDEpICogNCxcbiAgICAgICAgemVyb2VzID0gMCxcbiAgICAgICAgcG9zaXRpdmVzID0gMCxcbiAgICAgICAgbmVnYXRpdmVzID0gMCxcbiAgICAgICAgbWluID0gMCxcbiAgICAgICAgbWF4ID0gMCxcbiAgICAgICAgbWluWCwgbWluWSwgbWF4WCwgbWF4WTtcblxuICAgIC8vIGdvIHRocm91Z2ggOCBhZGphY2VudCBwaXhlbHNcbiAgICBmb3IgKHZhciB4ID0geDA7IHggPD0geDI7IHgrKykge1xuICAgICAgICBmb3IgKHZhciB5ID0geTA7IHkgPD0geTI7IHkrKykge1xuICAgICAgICAgICAgaWYgKHggPT09IHgxICYmIHkgPT09IHkxKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gYnJpZ2h0bmVzcyBkZWx0YSBiZXR3ZWVuIHRoZSBjZW50ZXIgcGl4ZWwgYW5kIGFkamFjZW50IG9uZVxuICAgICAgICAgICAgdmFyIGRlbHRhID0gY29sb3JEZWx0YShpbWcsIGltZywgcG9zLCAoeSAqIHdpZHRoICsgeCkgKiA0LCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gY291bnQgdGhlIG51bWJlciBvZiBlcXVhbCwgZGFya2VyIGFuZCBicmlnaHRlciBhZGphY2VudCBwaXhlbHNcbiAgICAgICAgICAgIGlmIChkZWx0YSA9PT0gMCkgemVyb2VzKys7XG4gICAgICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIG5lZ2F0aXZlcysrO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEgPiAwKSBwb3NpdGl2ZXMrKztcblxuICAgICAgICAgICAgLy8gaWYgZm91bmQgbW9yZSB0aGFuIDIgZXF1YWwgc2libGluZ3MsIGl0J3MgZGVmaW5pdGVseSBub3QgYW50aS1hbGlhc2luZ1xuICAgICAgICAgICAgaWYgKHplcm9lcyA+IDIpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKCFpbWcyKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGRhcmtlc3QgcGl4ZWxcbiAgICAgICAgICAgIGlmIChkZWx0YSA8IG1pbikge1xuICAgICAgICAgICAgICAgIG1pbiA9IGRlbHRhO1xuICAgICAgICAgICAgICAgIG1pblggPSB4O1xuICAgICAgICAgICAgICAgIG1pblkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGJyaWdodGVzdCBwaXhlbFxuICAgICAgICAgICAgaWYgKGRlbHRhID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgbWF4WCA9IHg7XG4gICAgICAgICAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWltZzIpIHJldHVybiB0cnVlO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIGJvdGggZGFya2VyIGFuZCBicmlnaHRlciBwaXhlbHMgYW1vbmcgc2libGluZ3MsIGl0J3Mgbm90IGFudGktYWxpYXNpbmdcbiAgICBpZiAobmVnYXRpdmVzID09PSAwIHx8IHBvc2l0aXZlcyA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gaWYgZWl0aGVyIHRoZSBkYXJrZXN0IG9yIHRoZSBicmlnaHRlc3QgcGl4ZWwgaGFzIG1vcmUgdGhhbiAyIGVxdWFsIHNpYmxpbmdzIGluIGJvdGggaW1hZ2VzXG4gICAgLy8gKGRlZmluaXRlbHkgbm90IGFudGktYWxpYXNlZCksIHRoaXMgcGl4ZWwgaXMgYW50aS1hbGlhc2VkXG4gICAgcmV0dXJuICghYW50aWFsaWFzZWQoaW1nLCBtaW5YLCBtaW5ZLCB3aWR0aCwgaGVpZ2h0KSAmJiAhYW50aWFsaWFzZWQoaW1nMiwgbWluWCwgbWluWSwgd2lkdGgsIGhlaWdodCkpIHx8XG4gICAgICAgICAgICghYW50aWFsaWFzZWQoaW1nLCBtYXhYLCBtYXhZLCB3aWR0aCwgaGVpZ2h0KSAmJiAhYW50aWFsaWFzZWQoaW1nMiwgbWF4WCwgbWF4WSwgd2lkdGgsIGhlaWdodCkpO1xufVxuXG4vLyBjYWxjdWxhdGUgY29sb3IgZGlmZmVyZW5jZSBhY2NvcmRpbmcgdG8gdGhlIHBhcGVyIFwiTWVhc3VyaW5nIHBlcmNlaXZlZCBjb2xvciBkaWZmZXJlbmNlXG4vLyB1c2luZyBZSVEgTlRTQyB0cmFuc21pc3Npb24gY29sb3Igc3BhY2UgaW4gbW9iaWxlIGFwcGxpY2F0aW9uc1wiIGJ5IFkuIEtvdHNhcmVua28gYW5kIEYuIFJhbW9zXG5cbmZ1bmN0aW9uIGNvbG9yRGVsdGEoaW1nMSwgaW1nMiwgaywgbSwgeU9ubHkpIHtcbiAgICB2YXIgYTEgPSBpbWcxW2sgKyAzXSAvIDI1NSxcbiAgICAgICAgYTIgPSBpbWcyW20gKyAzXSAvIDI1NSxcblxuICAgICAgICByMSA9IGJsZW5kKGltZzFbayArIDBdLCBhMSksXG4gICAgICAgIGcxID0gYmxlbmQoaW1nMVtrICsgMV0sIGExKSxcbiAgICAgICAgYjEgPSBibGVuZChpbWcxW2sgKyAyXSwgYTEpLFxuXG4gICAgICAgIHIyID0gYmxlbmQoaW1nMlttICsgMF0sIGEyKSxcbiAgICAgICAgZzIgPSBibGVuZChpbWcyW20gKyAxXSwgYTIpLFxuICAgICAgICBiMiA9IGJsZW5kKGltZzJbbSArIDJdLCBhMiksXG5cbiAgICAgICAgeSA9IHJnYjJ5KHIxLCBnMSwgYjEpIC0gcmdiMnkocjIsIGcyLCBiMik7XG5cbiAgICBpZiAoeU9ubHkpIHJldHVybiB5OyAvLyBicmlnaHRuZXNzIGRpZmZlcmVuY2Ugb25seVxuXG4gICAgdmFyIGkgPSByZ2IyaShyMSwgZzEsIGIxKSAtIHJnYjJpKHIyLCBnMiwgYjIpLFxuICAgICAgICBxID0gcmdiMnEocjEsIGcxLCBiMSkgLSByZ2IycShyMiwgZzIsIGIyKTtcblxuICAgIHJldHVybiAwLjUwNTMgKiB5ICogeSArIDAuMjk5ICogaSAqIGkgKyAwLjE5NTcgKiBxICogcTtcbn1cblxuZnVuY3Rpb24gcmdiMnkociwgZywgYikgeyByZXR1cm4gciAqIDAuMjk4ODk1MzEgKyBnICogMC41ODY2MjI0NyArIGIgKiAwLjExNDQ4MjIzOyB9XG5mdW5jdGlvbiByZ2IyaShyLCBnLCBiKSB7IHJldHVybiByICogMC41OTU5Nzc5OSAtIGcgKiAwLjI3NDE3NjEwIC0gYiAqIDAuMzIxODAxODk7IH1cbmZ1bmN0aW9uIHJnYjJxKHIsIGcsIGIpIHsgcmV0dXJuIHIgKiAwLjIxMTQ3MDE3IC0gZyAqIDAuNTIyNjE3MTEgKyBiICogMC4zMTExNDY5NDsgfVxuXG4vLyBibGVuZCBzZW1pLXRyYW5zcGFyZW50IGNvbG9yIHdpdGggd2hpdGVcbmZ1bmN0aW9uIGJsZW5kKGMsIGEpIHtcbiAgICByZXR1cm4gMjU1ICsgKGMgLSAyNTUpICogYTtcbn1cblxuZnVuY3Rpb24gZHJhd1BpeGVsKG91dHB1dCwgcG9zLCByLCBnLCBiKSB7XG4gICAgb3V0cHV0W3BvcyArIDBdID0gcjtcbiAgICBvdXRwdXRbcG9zICsgMV0gPSBnO1xuICAgIG91dHB1dFtwb3MgKyAyXSA9IGI7XG4gICAgb3V0cHV0W3BvcyArIDNdID0gMjU1O1xufVxuXG5mdW5jdGlvbiBncmF5UGl4ZWwoaW1nLCBpKSB7XG4gICAgdmFyIGEgPSBpbWdbaSArIDNdIC8gMjU1LFxuICAgICAgICByID0gYmxlbmQoaW1nW2kgKyAwXSwgYSksXG4gICAgICAgIGcgPSBibGVuZChpbWdbaSArIDFdLCBhKSxcbiAgICAgICAgYiA9IGJsZW5kKGltZ1tpICsgMl0sIGEpO1xuICAgIHJldHVybiByZ2IyeShyLCBnLCBiKTtcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicGl4ZWxtYXRjaCIsImltZzEiLCJpbWcyIiwib3V0cHV0Iiwid2lkdGgiLCJoZWlnaHQiLCJvcHRpb25zIiwidGhyZXNob2xkIiwidW5kZWZpbmVkIiwibWF4RGVsdGEiLCJkaWZmIiwieSIsIngiLCJwb3MiLCJkZWx0YSIsImNvbG9yRGVsdGEiLCJpbmNsdWRlQUEiLCJhbnRpYWxpYXNlZCIsImRyYXdQaXhlbCIsInZhbCIsImJsZW5kIiwiZ3JheVBpeGVsIiwiaW1nIiwieDEiLCJ5MSIsIngwIiwiTWF0aCIsIm1heCIsInkwIiwieDIiLCJtaW4iLCJ5MiIsInplcm9lcyIsInBvc2l0aXZlcyIsIm5lZ2F0aXZlcyIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJrIiwibSIsInlPbmx5IiwiYTEiLCJhMiIsInIxIiwiZzEiLCJiMSIsInIyIiwiZzIiLCJiMiIsInJnYjJ5IiwiaSIsInJnYjJpIiwicSIsInJnYjJxIiwiciIsImciLCJiIiwiYyIsImEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pixelmatch/index.js\n");

/***/ })

};
;