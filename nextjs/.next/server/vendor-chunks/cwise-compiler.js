"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cwise-compiler";
exports.ids = ["vendor-chunks/cwise-compiler"];
exports.modules = {

/***/ "(ssr)/./node_modules/cwise-compiler/compiler.js":
/*!*************************************************!*\
  !*** ./node_modules/cwise-compiler/compiler.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar createThunk = __webpack_require__(/*! ./lib/thunk.js */ \"(ssr)/./node_modules/cwise-compiler/lib/thunk.js\");\nfunction Procedure() {\n    this.argTypes = [];\n    this.shimArgs = [];\n    this.arrayArgs = [];\n    this.arrayBlockIndices = [];\n    this.scalarArgs = [];\n    this.offsetArgs = [];\n    this.offsetArgIndex = [];\n    this.indexArgs = [];\n    this.shapeArgs = [];\n    this.funcName = \"\";\n    this.pre = null;\n    this.body = null;\n    this.post = null;\n    this.debug = false;\n}\nfunction compileCwise(user_args) {\n    //Create procedure\n    var proc = new Procedure();\n    //Parse blocks\n    proc.pre = user_args.pre;\n    proc.body = user_args.body;\n    proc.post = user_args.post;\n    //Parse arguments\n    var proc_args = user_args.args.slice(0);\n    proc.argTypes = proc_args;\n    for(var i = 0; i < proc_args.length; ++i){\n        var arg_type = proc_args[i];\n        if (arg_type === \"array\" || typeof arg_type === \"object\" && arg_type.blockIndices) {\n            proc.argTypes[i] = \"array\";\n            proc.arrayArgs.push(i);\n            proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);\n            proc.shimArgs.push(\"array\" + i);\n            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {\n                throw new Error(\"cwise: pre() block may not reference array args\");\n            }\n            if (i < proc.post.args.length && proc.post.args[i].count > 0) {\n                throw new Error(\"cwise: post() block may not reference array args\");\n            }\n        } else if (arg_type === \"scalar\") {\n            proc.scalarArgs.push(i);\n            proc.shimArgs.push(\"scalar\" + i);\n        } else if (arg_type === \"index\") {\n            proc.indexArgs.push(i);\n            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {\n                throw new Error(\"cwise: pre() block may not reference array index\");\n            }\n            if (i < proc.body.args.length && proc.body.args[i].lvalue) {\n                throw new Error(\"cwise: body() block may not write to array index\");\n            }\n            if (i < proc.post.args.length && proc.post.args[i].count > 0) {\n                throw new Error(\"cwise: post() block may not reference array index\");\n            }\n        } else if (arg_type === \"shape\") {\n            proc.shapeArgs.push(i);\n            if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {\n                throw new Error(\"cwise: pre() block may not write to array shape\");\n            }\n            if (i < proc.body.args.length && proc.body.args[i].lvalue) {\n                throw new Error(\"cwise: body() block may not write to array shape\");\n            }\n            if (i < proc.post.args.length && proc.post.args[i].lvalue) {\n                throw new Error(\"cwise: post() block may not write to array shape\");\n            }\n        } else if (typeof arg_type === \"object\" && arg_type.offset) {\n            proc.argTypes[i] = \"offset\";\n            proc.offsetArgs.push({\n                array: arg_type.array,\n                offset: arg_type.offset\n            });\n            proc.offsetArgIndex.push(i);\n        } else {\n            throw new Error(\"cwise: Unknown argument type \" + proc_args[i]);\n        }\n    }\n    //Make sure at least one array argument was specified\n    if (proc.arrayArgs.length <= 0) {\n        throw new Error(\"cwise: No array arguments specified\");\n    }\n    //Make sure arguments are correct\n    if (proc.pre.args.length > proc_args.length) {\n        throw new Error(\"cwise: Too many arguments in pre() block\");\n    }\n    if (proc.body.args.length > proc_args.length) {\n        throw new Error(\"cwise: Too many arguments in body() block\");\n    }\n    if (proc.post.args.length > proc_args.length) {\n        throw new Error(\"cwise: Too many arguments in post() block\");\n    }\n    //Check debug flag\n    proc.debug = !!user_args.printCode || !!user_args.debug;\n    //Retrieve name\n    proc.funcName = user_args.funcName || \"cwise\";\n    //Read in block size\n    proc.blockSize = user_args.blockSize || 64;\n    return createThunk(proc);\n}\nmodule.exports = compileCwise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvY29tcGlsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxjQUFjQyxtQkFBT0EsQ0FBQyx3RUFBZ0I7QUFFMUMsU0FBU0M7SUFDUCxJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO0lBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLEVBQUU7SUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtJQUNuQixJQUFJLENBQUNDLGlCQUFpQixHQUFHLEVBQUU7SUFDM0IsSUFBSSxDQUFDQyxVQUFVLEdBQUcsRUFBRTtJQUNwQixJQUFJLENBQUNDLFVBQVUsR0FBRyxFQUFFO0lBQ3BCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLEVBQUU7SUFDeEIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtJQUNuQixJQUFJLENBQUNDLFNBQVMsR0FBRyxFQUFFO0lBQ25CLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLElBQUksQ0FBQ0MsR0FBRyxHQUFHO0lBQ1gsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDWixJQUFJLENBQUNDLElBQUksR0FBRztJQUNaLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0FBQ2Y7QUFFQSxTQUFTQyxhQUFhQyxTQUFTO0lBQzdCLGtCQUFrQjtJQUNsQixJQUFJQyxPQUFPLElBQUlqQjtJQUVmLGNBQWM7SUFDZGlCLEtBQUtOLEdBQUcsR0FBTUssVUFBVUwsR0FBRztJQUMzQk0sS0FBS0wsSUFBSSxHQUFLSSxVQUFVSixJQUFJO0lBQzVCSyxLQUFLSixJQUFJLEdBQUtHLFVBQVVILElBQUk7SUFFNUIsaUJBQWlCO0lBQ2pCLElBQUlLLFlBQVlGLFVBQVVHLElBQUksQ0FBQ0MsS0FBSyxDQUFDO0lBQ3JDSCxLQUFLaEIsUUFBUSxHQUFHaUI7SUFDaEIsSUFBSSxJQUFJRyxJQUFFLEdBQUdBLElBQUVILFVBQVVJLE1BQU0sRUFBRSxFQUFFRCxFQUFHO1FBQ3BDLElBQUlFLFdBQVdMLFNB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TUFBTSxJQUFJTSxNQUFNLGtDQUFrQ1QsU0FBUyxDQUFDRyxFQUFFO1FBQ2hFO0lBQ0Y7SUFFQSxxREFBcUQ7SUFDckQsSUFBR0osS0FBS2QsU0FBUyxDQUFDbUIsTUFBTSxJQUFJLEdBQUc7UUFDN0IsTUFBTSxJQUFJSyxNQUFNO0lBQ2xCO0lBRUEsaUNBQWlDO0lBQ2pDLElBQUdWLEtBQUtOLEdBQUcsQ0FBQ1EsSUFBSSxDQUFDRyxNQUFNLEdBQUdKLFVBQVVJLE1BQU0sRUFBRTtRQUMxQyxNQUFNLElBQUlLLE1BQU07SUFDbEI7SUFDQSxJQUFHVixLQUFLTCxJQUFJLENBQUNPLElBQUksQ0FBQ0csTUFBTSxHQUFHSixVQUFVSSxNQUFNLEVBQUU7UUFDM0MsTUFBTSxJQUFJSyxNQUFNO0lBQ2xCO0lBQ0EsSUFBR1YsS0FBS0osSUFBSSxDQUFDTSxJQUFJLENBQUNHLE1BQU0sR0FBR0osVUFBVUksTUFBTSxFQUFFO1FBQzNDLE1BQU0sSUFBSUssTUFBTTtJQUNsQjtJQUVBLGtCQUFrQjtJQUNsQlYsS0FBS0gsS0FBSyxHQUFHLENBQUMsQ0FBQ0UsVUFBVWUsU0FBUyxJQUFJLENBQUMsQ0FBQ2YsVUFBVUYsS0FBSztJQUV2RCxlQUFlO0lBQ2ZHLEtBQUtQLFFBQVEsR0FBR00sVUFBVU4sUUFBUSxJQUFJO0lBRXRDLG9CQUFvQjtJQUNwQk8sS0FBS2UsU0FBUyxHQUFHaEIsVUFBVWdCLFNBQVMsSUFBSTtJQUV4QyxPQUFPbEMsWUFBWW1CO0FBQ3JCO0FBRUFnQixPQUFPQyxPQUFPLEdBQUduQiIsInNvdXJjZXMiOlsid2VicGFjazovL3FyLWNvZGUvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvY29tcGlsZXIuanM/ZjZlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG52YXIgY3JlYXRlVGh1bmsgPSByZXF1aXJlKFwiLi9saWIvdGh1bmsuanNcIilcblxuZnVuY3Rpb24gUHJvY2VkdXJlKCkge1xuICB0aGlzLmFyZ1R5cGVzID0gW11cbiAgdGhpcy5zaGltQXJncyA9IFtdXG4gIHRoaXMuYXJyYXlBcmdzID0gW11cbiAgdGhpcy5hcnJheUJsb2NrSW5kaWNlcyA9IFtdXG4gIHRoaXMuc2NhbGFyQXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJnSW5kZXggPSBbXVxuICB0aGlzLmluZGV4QXJncyA9IFtdXG4gIHRoaXMuc2hhcGVBcmdzID0gW11cbiAgdGhpcy5mdW5jTmFtZSA9IFwiXCJcbiAgdGhpcy5wcmUgPSBudWxsXG4gIHRoaXMuYm9keSA9IG51bGxcbiAgdGhpcy5wb3N0ID0gbnVsbFxuICB0aGlzLmRlYnVnID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29tcGlsZUN3aXNlKHVzZXJfYXJncykge1xuICAvL0NyZWF0ZSBwcm9jZWR1cmVcbiAgdmFyIHByb2MgPSBuZXcgUHJvY2VkdXJlKClcbiAgXG4gIC8vUGFyc2UgYmxvY2tzXG4gIHByb2MucHJlICAgID0gdXNlcl9hcmdzLnByZVxuICBwcm9jLmJvZHkgICA9IHVzZXJfYXJncy5ib2R5XG4gIHByb2MucG9zdCAgID0gdXNlcl9hcmdzLnBvc3RcblxuICAvL1BhcnNlIGFyZ3VtZW50c1xuICB2YXIgcHJvY19hcmdzID0gdXNlcl9hcmdzLmFyZ3Muc2xpY2UoMClcbiAgcHJvYy5hcmdUeXBlcyA9IHByb2NfYXJnc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jX2FyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXJnX3R5cGUgPSBwcm9jX2FyZ3NbaV1cbiAgICBpZihhcmdfdHlwZSA9PT0gXCJhcnJheVwiIHx8ICh0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUuYmxvY2tJbmRpY2VzKSkge1xuICAgICAgcHJvYy5hcmdUeXBlc1tpXSA9IFwiYXJyYXlcIlxuICAgICAgcHJvYy5hcnJheUFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5hcnJheUJsb2NrSW5kaWNlcy5wdXNoKGFyZ190eXBlLmJsb2NrSW5kaWNlcyA/IGFyZ190eXBlLmJsb2NrSW5kaWNlcyA6IDApXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJhcnJheVwiICsgaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQ+MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2NhbGFyXCIpIHtcbiAgICAgIHByb2Muc2NhbGFyQXJncy5wdXNoKGkpXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJzY2FsYXJcIiArIGkpXG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcImluZGV4XCIpIHtcbiAgICAgIHByb2MuaW5kZXhBcmdzLnB1c2goaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJzaGFwZVwiKSB7XG4gICAgICBwcm9jLnNoYXBlQXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5vZmZzZXQpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcIm9mZnNldFwiXG4gICAgICBwcm9jLm9mZnNldEFyZ3MucHVzaCh7IGFycmF5OiBhcmdfdHlwZS5hcnJheSwgb2Zmc2V0OmFyZ190eXBlLm9mZnNldCB9KVxuICAgICAgcHJvYy5vZmZzZXRBcmdJbmRleC5wdXNoKGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBVbmtub3duIGFyZ3VtZW50IHR5cGUgXCIgKyBwcm9jX2FyZ3NbaV0pXG4gICAgfVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgYXJyYXkgYXJndW1lbnQgd2FzIHNwZWNpZmllZFxuICBpZihwcm9jLmFycmF5QXJncy5sZW5ndGggPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBObyBhcnJheSBhcmd1bWVudHMgc3BlY2lmaWVkXCIpXG4gIH1cbiAgXG4gIC8vTWFrZSBzdXJlIGFyZ3VtZW50cyBhcmUgY29ycmVjdFxuICBpZihwcm9jLnByZS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHByZSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5ib2R5LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gYm9keSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5wb3N0LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gcG9zdCgpIGJsb2NrXCIpXG4gIH1cblxuICAvL0NoZWNrIGRlYnVnIGZsYWdcbiAgcHJvYy5kZWJ1ZyA9ICEhdXNlcl9hcmdzLnByaW50Q29kZSB8fCAhIXVzZXJfYXJncy5kZWJ1Z1xuICBcbiAgLy9SZXRyaWV2ZSBuYW1lXG4gIHByb2MuZnVuY05hbWUgPSB1c2VyX2FyZ3MuZnVuY05hbWUgfHwgXCJjd2lzZVwiXG4gIFxuICAvL1JlYWQgaW4gYmxvY2sgc2l6ZVxuICBwcm9jLmJsb2NrU2l6ZSA9IHVzZXJfYXJncy5ibG9ja1NpemUgfHwgNjRcblxuICByZXR1cm4gY3JlYXRlVGh1bmsocHJvYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlQ3dpc2VcbiJdLCJuYW1lcyI6WyJjcmVhdGVUaHVuayIsInJlcXVpcmUiLCJQcm9jZWR1cmUiLCJhcmdUeXBlcyIsInNoaW1BcmdzIiwiYXJyYXlBcmdzIiwiYXJyYXlCbG9ja0luZGljZXMiLCJzY2FsYXJBcmdzIiwib2Zmc2V0QXJncyIsIm9mZnNldEFyZ0luZGV4IiwiaW5kZXhBcmdzIiwic2hhcGVBcmdzIiwiZnVuY05hbWUiLCJwcmUiLCJib2R5IiwicG9zdCIsImRlYnVnIiwiY29tcGlsZUN3aXNlIiwidXNlcl9hcmdzIiwicHJvYyIsInByb2NfYXJncyIsImFyZ3MiLCJzbGljZSIsImkiLCJsZW5ndGgiLCJhcmdfdHlwZSIsImJsb2NrSW5kaWNlcyIsInB1c2giLCJjb3VudCIsIkVycm9yIiwibHZhbHVlIiwib2Zmc2V0IiwiYXJyYXkiLCJwcmludENvZGUiLCJibG9ja1NpemUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cwise-compiler/compiler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cwise-compiler/lib/compile.js":
/*!****************************************************!*\
  !*** ./node_modules/cwise-compiler/lib/compile.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar uniq = __webpack_require__(/*! uniq */ \"(ssr)/./node_modules/uniq/uniq.js\");\n// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)\n// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of \"pointers\" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.\nfunction innerFill(order, proc, body) {\n    var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;\n    for(i = 0; i < dimension; ++i){\n        vars.push([\n            \"i\",\n            i,\n            \"=0\"\n        ].join(\"\"));\n    }\n    //Compute scan deltas\n    for(j = 0; j < nargs; ++j){\n        for(i = 0; i < dimension; ++i){\n            pidx = idx;\n            idx = order[i];\n            if (i === 0) {\n                vars.push([\n                    \"d\",\n                    j,\n                    \"s\",\n                    i,\n                    \"=t\",\n                    j,\n                    \"p\",\n                    idx\n                ].join(\"\"));\n            } else {\n                vars.push([\n                    \"d\",\n                    j,\n                    \"s\",\n                    i,\n                    \"=(t\",\n                    j,\n                    \"p\",\n                    idx,\n                    \"-s\",\n                    pidx,\n                    \"*t\",\n                    j,\n                    \"p\",\n                    pidx,\n                    \")\"\n                ].join(\"\"));\n            }\n        }\n    }\n    if (vars.length > 0) {\n        code.push(\"var \" + vars.join(\",\"));\n    }\n    //Scan loop\n    for(i = dimension - 1; i >= 0; --i){\n        idx = order[i];\n        code.push([\n            \"for(i\",\n            i,\n            \"=0;i\",\n            i,\n            \"<s\",\n            idx,\n            \";++i\",\n            i,\n            \"){\"\n        ].join(\"\"));\n    }\n    //Push body of inner loop\n    code.push(body);\n    //Advance scan pointers\n    for(i = 0; i < dimension; ++i){\n        pidx = idx;\n        idx = order[i];\n        for(j = 0; j < nargs; ++j){\n            code.push([\n                \"p\",\n                j,\n                \"+=d\",\n                j,\n                \"s\",\n                i\n            ].join(\"\"));\n        }\n        if (has_index) {\n            if (i > 0) {\n                code.push([\n                    \"index[\",\n                    pidx,\n                    \"]-=s\",\n                    pidx\n                ].join(\"\"));\n            }\n            code.push([\n                \"++index[\",\n                idx,\n                \"]\"\n            ].join(\"\"));\n        }\n        code.push(\"}\");\n    }\n    return code.join(\"\\n\");\n}\n// Generate \"outer\" loops that loop over blocks of data, applying \"inner\" loops to the blocks by manipulating the local variables in such a way that the inner loop only \"sees\" the current block.\n// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.\n//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and \"shape\" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.\nfunction outerFill(matched, order, proc, body) {\n    var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];\n    for(var i = 0; i < nargs; ++i){\n        code.push([\n            \"var offset\",\n            i,\n            \"=p\",\n            i\n        ].join(\"\"));\n    }\n    //Generate loops for unmatched dimensions\n    // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)\n    // TODO: It would be nice if the order in which these loops are placed would also be somehow \"optimal\" (at the very least we should check that it really doesn't hurt us if they're not).\n    for(var i = matched; i < dimension; ++i){\n        code.push([\n            \"for(var j\" + i + \"=SS[\",\n            order[i],\n            \"]|0;j\",\n            i,\n            \">0;){\"\n        ].join(\"\")) // Iterate back to front\n        ;\n        code.push([\n            \"if(j\",\n            i,\n            \"<\",\n            blockSize,\n            \"){\"\n        ].join(\"\")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).\n        ;\n        code.push([\n            \"s\",\n            order[i],\n            \"=j\",\n            i\n        ].join(\"\"));\n        code.push([\n            \"j\",\n            i,\n            \"=0\"\n        ].join(\"\"));\n        code.push([\n            \"}else{s\",\n            order[i],\n            \"=\",\n            blockSize\n        ].join(\"\"));\n        code.push([\n            \"j\",\n            i,\n            \"-=\",\n            blockSize,\n            \"}\"\n        ].join(\"\"));\n        if (has_index) {\n            code.push([\n                \"index[\",\n                order[i],\n                \"]=j\",\n                i\n            ].join(\"\"));\n        }\n    }\n    for(var i = 0; i < nargs; ++i){\n        var indexStr = [\n            \"offset\" + i\n        ];\n        for(var j = matched; j < dimension; ++j){\n            indexStr.push([\n                \"j\",\n                j,\n                \"*t\",\n                i,\n                \"p\",\n                order[j]\n            ].join(\"\"));\n        }\n        code.push([\n            \"p\",\n            i,\n            \"=(\",\n            indexStr.join(\"+\"),\n            \")\"\n        ].join(\"\"));\n    }\n    code.push(innerFill(order, proc, body));\n    for(var i = matched; i < dimension; ++i){\n        code.push(\"}\");\n    }\n    return code.join(\"\\n\");\n}\n//Count the number of compatible inner orders\n// This is the length of the longest common prefix of the arrays in orders.\n// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.\n// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.\nfunction countMatches(orders) {\n    var matched = 0, dimension = orders[0].length;\n    while(matched < dimension){\n        for(var j = 1; j < orders.length; ++j){\n            if (orders[j][matched] !== orders[0][matched]) {\n                return matched;\n            }\n        }\n        ++matched;\n    }\n    return matched;\n}\n//Processes a block according to the given data types\n// Replaces variable names by different ones, either \"local\" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.\nfunction processBlock(block, proc, dtypes) {\n    var code = block.body;\n    var pre = [];\n    var post = [];\n    for(var i = 0; i < block.args.length; ++i){\n        var carg = block.args[i];\n        if (carg.count <= 0) {\n            continue;\n        }\n        var re = new RegExp(carg.name, \"g\");\n        var ptrStr = \"\";\n        var arrNum = proc.arrayArgs.indexOf(i);\n        switch(proc.argTypes[i]){\n            case \"offset\":\n                var offArgIndex = proc.offsetArgIndex.indexOf(i);\n                var offArg = proc.offsetArgs[offArgIndex];\n                arrNum = offArg.array;\n                ptrStr = \"+q\" + offArgIndex // Adds offset to the \"pointer\" in the array\n                ;\n            case \"array\":\n                ptrStr = \"p\" + arrNum + ptrStr;\n                var localStr = \"l\" + i;\n                var arrStr = \"a\" + arrNum;\n                if (proc.arrayBlockIndices[arrNum] === 0) {\n                    if (carg.count === 1) {\n                        if (dtypes[arrNum] === \"generic\") {\n                            if (carg.lvalue) {\n                                pre.push([\n                                    \"var \",\n                                    localStr,\n                                    \"=\",\n                                    arrStr,\n                                    \".get(\",\n                                    ptrStr,\n                                    \")\"\n                                ].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n                                ;\n                                code = code.replace(re, localStr);\n                                post.push([\n                                    arrStr,\n                                    \".set(\",\n                                    ptrStr,\n                                    \",\",\n                                    localStr,\n                                    \")\"\n                                ].join(\"\"));\n                            } else {\n                                code = code.replace(re, [\n                                    arrStr,\n                                    \".get(\",\n                                    ptrStr,\n                                    \")\"\n                                ].join(\"\"));\n                            }\n                        } else {\n                            code = code.replace(re, [\n                                arrStr,\n                                \"[\",\n                                ptrStr,\n                                \"]\"\n                            ].join(\"\"));\n                        }\n                    } else if (dtypes[arrNum] === \"generic\") {\n                        pre.push([\n                            \"var \",\n                            localStr,\n                            \"=\",\n                            arrStr,\n                            \".get(\",\n                            ptrStr,\n                            \")\"\n                        ].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n                        ;\n                        code = code.replace(re, localStr);\n                        if (carg.lvalue) {\n                            post.push([\n                                arrStr,\n                                \".set(\",\n                                ptrStr,\n                                \",\",\n                                localStr,\n                                \")\"\n                            ].join(\"\"));\n                        }\n                    } else {\n                        pre.push([\n                            \"var \",\n                            localStr,\n                            \"=\",\n                            arrStr,\n                            \"[\",\n                            ptrStr,\n                            \"]\"\n                        ].join(\"\")) // TODO: Could we optimize by checking for carg.rvalue?\n                        ;\n                        code = code.replace(re, localStr);\n                        if (carg.lvalue) {\n                            post.push([\n                                arrStr,\n                                \"[\",\n                                ptrStr,\n                                \"]=\",\n                                localStr\n                            ].join(\"\"));\n                        }\n                    }\n                } else {\n                    var reStrArr = [\n                        carg.name\n                    ], ptrStrArr = [\n                        ptrStr\n                    ];\n                    for(var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++){\n                        reStrArr.push(\"\\\\s*\\\\[([^\\\\]]+)\\\\]\");\n                        ptrStrArr.push(\"$\" + (j + 1) + \"*t\" + arrNum + \"b\" + j) // Matched index times stride\n                        ;\n                    }\n                    re = new RegExp(reStrArr.join(\"\"), \"g\");\n                    ptrStr = ptrStrArr.join(\"+\");\n                    if (dtypes[arrNum] === \"generic\") {\n                        /*if(carg.lvalue) {\n              pre.push([\"var \", localStr, \"=\", arrStr, \".get(\", ptrStr, \")\"].join(\"\")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)\n              code = code.replace(re, localStr)\n              post.push([arrStr, \".set(\", ptrStr, \",\", localStr,\")\"].join(\"\"))\n            } else {\n              code = code.replace(re, [arrStr, \".get(\", ptrStr, \")\"].join(\"\"))\n            }*/ throw new Error(\"cwise: Generic arrays not supported in combination with blocks!\");\n                    } else {\n                        // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.\n                        code = code.replace(re, [\n                            arrStr,\n                            \"[\",\n                            ptrStr,\n                            \"]\"\n                        ].join(\"\"));\n                    }\n                }\n                break;\n            case \"scalar\":\n                code = code.replace(re, \"Y\" + proc.scalarArgs.indexOf(i));\n                break;\n            case \"index\":\n                code = code.replace(re, \"index\");\n                break;\n            case \"shape\":\n                code = code.replace(re, \"shape\");\n                break;\n        }\n    }\n    return [\n        pre.join(\"\\n\"),\n        code,\n        post.join(\"\\n\")\n    ].join(\"\\n\").trim();\n}\nfunction typeSummary(dtypes) {\n    var summary = new Array(dtypes.length);\n    var allEqual = true;\n    for(var i = 0; i < dtypes.length; ++i){\n        var t = dtypes[i];\n        var digits = t.match(/\\d+/);\n        if (!digits) {\n            digits = \"\";\n        } else {\n            digits = digits[0];\n        }\n        if (t.charAt(0) === 0) {\n            summary[i] = \"u\" + t.charAt(1) + digits;\n        } else {\n            summary[i] = t.charAt(0) + digits;\n        }\n        if (i > 0) {\n            allEqual = allEqual && summary[i] === summary[i - 1];\n        }\n    }\n    if (allEqual) {\n        return summary[0];\n    }\n    return summary.join(\"\");\n}\n//Generates a cwise operator\nfunction generateCWiseOp(proc, typesig) {\n    //Compute dimension\n    // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.\n    var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;\n    var orders = new Array(proc.arrayArgs.length);\n    var dtypes = new Array(proc.arrayArgs.length);\n    for(var i = 0; i < proc.arrayArgs.length; ++i){\n        dtypes[i] = typesig[2 * i];\n        orders[i] = typesig[2 * i + 1];\n    }\n    //Determine where block and loop indices start and end\n    var blockBegin = [], blockEnd = [] // These indices are exposed as blocks\n    ;\n    var loopBegin = [], loopEnd = [] // These indices are iterated over\n    ;\n    var loopOrders = [] // orders restricted to the loop indices\n    ;\n    for(var i = 0; i < proc.arrayArgs.length; ++i){\n        if (proc.arrayBlockIndices[i] < 0) {\n            loopBegin.push(0);\n            loopEnd.push(dimension);\n            blockBegin.push(dimension);\n            blockEnd.push(dimension + proc.arrayBlockIndices[i]);\n        } else {\n            loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative\n            ;\n            loopEnd.push(proc.arrayBlockIndices[i] + dimension);\n            blockBegin.push(0);\n            blockEnd.push(proc.arrayBlockIndices[i]);\n        }\n        var newOrder = [];\n        for(var j = 0; j < orders[i].length; j++){\n            if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {\n                newOrder.push(orders[i][j] - loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.\n                ;\n            }\n        }\n        loopOrders.push(newOrder);\n    }\n    //First create arguments for procedure\n    var arglist = [\n        \"SS\"\n    ] // SS is the overall shape over which we iterate\n    ;\n    var code = [\n        \"'use strict'\"\n    ];\n    var vars = [];\n    for(var j = 0; j < dimension; ++j){\n        vars.push([\n            \"s\",\n            j,\n            \"=SS[\",\n            j,\n            \"]\"\n        ].join(\"\")) // The limits for each dimension.\n        ;\n    }\n    for(var i = 0; i < proc.arrayArgs.length; ++i){\n        arglist.push(\"a\" + i) // Actual data array\n        ;\n        arglist.push(\"t\" + i) // Strides\n        ;\n        arglist.push(\"p\" + i) // Offset in the array at which the data starts (also used for iterating over the data)\n        ;\n        for(var j = 0; j < dimension; ++j){\n            vars.push([\n                \"t\",\n                i,\n                \"p\",\n                j,\n                \"=t\",\n                i,\n                \"[\",\n                loopBegin[i] + j,\n                \"]\"\n            ].join(\"\"));\n        }\n        for(var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j){\n            vars.push([\n                \"t\",\n                i,\n                \"b\",\n                j,\n                \"=t\",\n                i,\n                \"[\",\n                blockBegin[i] + j,\n                \"]\"\n            ].join(\"\"));\n        }\n    }\n    for(var i = 0; i < proc.scalarArgs.length; ++i){\n        arglist.push(\"Y\" + i);\n    }\n    if (proc.shapeArgs.length > 0) {\n        vars.push(\"shape=SS.slice(0)\") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)\n        ;\n    }\n    if (proc.indexArgs.length > 0) {\n        // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.\n        var zeros = new Array(dimension);\n        for(var i = 0; i < dimension; ++i){\n            zeros[i] = \"0\";\n        }\n        vars.push([\n            \"index=[\",\n            zeros.join(\",\"),\n            \"]\"\n        ].join(\"\"));\n    }\n    for(var i = 0; i < proc.offsetArgs.length; ++i){\n        var off_arg = proc.offsetArgs[i];\n        var init_string = [];\n        for(var j = 0; j < off_arg.offset.length; ++j){\n            if (off_arg.offset[j] === 0) {\n                continue;\n            } else if (off_arg.offset[j] === 1) {\n                init_string.push([\n                    \"t\",\n                    off_arg.array,\n                    \"p\",\n                    j\n                ].join(\"\"));\n            } else {\n                init_string.push([\n                    off_arg.offset[j],\n                    \"*t\",\n                    off_arg.array,\n                    \"p\",\n                    j\n                ].join(\"\"));\n            }\n        }\n        if (init_string.length === 0) {\n            vars.push(\"q\" + i + \"=0\");\n        } else {\n            vars.push([\n                \"q\",\n                i,\n                \"=\",\n                init_string.join(\"+\")\n            ].join(\"\"));\n        }\n    }\n    //Prepare this variables\n    var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));\n    vars = vars.concat(thisVars);\n    if (vars.length > 0) {\n        code.push(\"var \" + vars.join(\",\"));\n    }\n    for(var i = 0; i < proc.arrayArgs.length; ++i){\n        code.push(\"p\" + i + \"|=0\");\n    }\n    //Inline prelude\n    if (proc.pre.body.length > 3) {\n        code.push(processBlock(proc.pre, proc, dtypes));\n    }\n    //Process body\n    var body = processBlock(proc.body, proc, dtypes);\n    var matched = countMatches(loopOrders);\n    if (matched < dimension) {\n        code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.\n        ;\n    } else {\n        code.push(innerFill(loopOrders[0], proc, body));\n    }\n    //Inline epilog\n    if (proc.post.body.length > 3) {\n        code.push(processBlock(proc.post, proc, dtypes));\n    }\n    if (proc.debug) {\n        console.log(\"-----Generated cwise routine for \", typesig, \":\\n\" + code.join(\"\\n\") + \"\\n----------\");\n    }\n    var loopName = [\n        proc.funcName || \"unnamed\",\n        \"_cwise_loop_\",\n        orders[0].join(\"s\"),\n        \"m\",\n        matched,\n        typeSummary(dtypes)\n    ].join(\"\");\n    var f = new Function([\n        \"function \",\n        loopName,\n        \"(\",\n        arglist.join(\",\"),\n        \"){\",\n        code.join(\"\\n\"),\n        \"} return \",\n        loopName\n    ].join(\"\"));\n    return f();\n}\nmodule.exports = generateCWiseOp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL2NvbXBpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQywrQ0FBTTtBQUV6Qiw0TUFBNE07QUFDNU0saVdBQWlXO0FBQ2pXLFNBQVNDLFVBQVVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxJQUFJO0lBQ2xDLElBQUlDLFlBQVlILE1BQU1JLE1BQU0sRUFDeEJDLFFBQVFKLEtBQUtLLFNBQVMsQ0FBQ0YsTUFBTSxFQUM3QkcsWUFBWU4sS0FBS08sU0FBUyxDQUFDSixNQUFNLEdBQUMsR0FDbENLLE9BQU8sRUFBRSxFQUNUQyxPQUFPLEVBQUUsRUFDVEMsTUFBSSxHQUFHQyxPQUFLLEdBQUdDLEdBQUdDO0lBQ3RCLElBQUlELElBQUUsR0FBR0EsSUFBRVYsV0FBVyxFQUFFVSxFQUFHO1FBQ3pCSCxLQUFLSyxJQUFJLENBQUM7WUFBQztZQUFJRjtZQUFFO1NBQUssQ0FBQ0csSUFBSSxDQUFDO0lBQzlCO0lBQ0EscUJBQXFCO0lBQ3JCLElBQUlGLElBQUUsR0FBR0EsSUFBRVQsT0FBTyxFQUFFUyxFQUFHO1FBQ3JCLElBQUlELElBQUUsR0FBR0EsSUFBRVYsV0FBVyxFQUFFVSxFQUFHO1lBQ3pCRCxPQUFPRDtZQUNQQSxNQUFNWCxLQUFLLENBQUNhLEVBQUU7WUFDZCxJQUFHQSxNQUFNLEdBQUc7Z0JBQ1ZILEtBQUtLLElBQUksQ0FBQztvQkFBQztvQkFBSUQ7b0JBQUU7b0JBQUlEO29CQUFFO29CQUFLQztvQkFBRTtvQkFBSUg7aUJBQUksQ0FBQ0ssSUFBSSxDQUFDO1lBQzlDLE9BQU87Z0JBQ0xOLEtBQUtLLElBQUksQ0FBQztvQkFBQztvQkFBSUQ7b0JBQUU7b0JBQUlEO29CQUFFO29CQUFNQztvQkFBRTtvQkFBSUg7b0JBQUk7b0JBQUtDO29CQUFLO29CQUFLRTtvQkFBRTtvQkFBSUY7b0JBQUs7aUJBQUksQ0FBQ0ksSUFBSSxDQUFDO1lBQzdFO1FB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QU07UUFBYWtFO0tBQVMsQ0FBQ2xFLElBQUksQ0FBQztJQUNwSCxPQUFPb0U7QUFDVDtBQUNBRSxPQUFPQyxPQUFPLEdBQUd4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3FyLWNvZGUvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL2NvbXBpbGUuanM/MDZiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG52YXIgdW5pcSA9IHJlcXVpcmUoXCJ1bmlxXCIpXG5cbi8vIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIHZlcnkgc2ltcGxlIGxvb3BzIGFuYWxvZ291cyB0byBob3cgeW91IHR5cGljYWxseSB0cmF2ZXJzZSBhcnJheXMgKHRoZSBvdXRlcm1vc3QgbG9vcCBjb3JyZXNwb25kcyB0byB0aGUgc2xvd2VzdCBjaGFuZ2luZyBpbmRleCwgdGhlIGlubmVybW9zdCBsb29wIHRvIHRoZSBmYXN0ZXN0IGNoYW5naW5nIGluZGV4KVxuLy8gVE9ETzogSWYgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIHN0cmlkZXMgKGFuZCBvZmZzZXRzKSB0aGVyZSBpcyBwb3RlbnRpYWwgZm9yIGRlY3JlYXNpbmcgdGhlIG51bWJlciBvZiBcInBvaW50ZXJzXCIgYW5kIHJlbGF0ZWQgdmFyaWFibGVzLiBUaGUgZHJhd2JhY2sgaXMgdGhhdCB0aGUgdHlwZSBzaWduYXR1cmUgd291bGQgYmVjb21lIG1vcmUgc3BlY2lmaWMgYW5kIHRoYXQgdGhlcmUgd291bGQgdGh1cyBiZSBsZXNzIHBvdGVudGlhbCBmb3IgY2FjaGluZywgYnV0IGl0IG1pZ2h0IHN0aWxsIGJlIHdvcnRoIGl0LCBlc3BlY2lhbGx5IHdoZW4gZGVhbGluZyB3aXRoIGxhcmdlIG51bWJlcnMgb2YgYXJndW1lbnRzLlxuZnVuY3Rpb24gaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSB7XG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcbiAgICAsIG5hcmdzID0gcHJvYy5hcnJheUFyZ3MubGVuZ3RoXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGg+MFxuICAgICwgY29kZSA9IFtdXG4gICAgLCB2YXJzID0gW11cbiAgICAsIGlkeD0wLCBwaWR4PTAsIGksIGpcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkgeyAvLyBJdGVyYXRpb24gdmFyaWFibGVzXG4gICAgdmFycy5wdXNoKFtcImlcIixpLFwiPTBcIl0uam9pbihcIlwiKSlcbiAgfVxuICAvL0NvbXB1dGUgc2NhbiBkZWx0YXNcbiAgZm9yKGo9MDsgajxuYXJnczsgKytqKSB7XG4gICAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgcGlkeCA9IGlkeFxuICAgICAgaWR4ID0gb3JkZXJbaV1cbiAgICAgIGlmKGkgPT09IDApIHsgLy8gVGhlIGlubmVybW9zdC9mYXN0ZXN0IGRpbWVuc2lvbidzIGRlbHRhIGlzIHNpbXBseSBpdHMgc3RyaWRlXG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPXRcIixqLFwicFwiLGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH0gZWxzZSB7IC8vIEZvciBvdGhlciBkaW1lbnNpb25zIHRoZSBkZWx0YSBpcyBiYXNpY2FsbHkgdGhlIHN0cmlkZSBtaW51cyBzb21ldGhpbmcgd2hpY2ggZXNzZW50aWFsbHkgXCJyZXdpbmRzXCIgdGhlIHByZXZpb3VzIChtb3JlIGlubmVyKSBkaW1lbnNpb25cbiAgICAgICAgdmFycy5wdXNoKFtcImRcIixqLFwic1wiLGksXCI9KHRcIixqLFwicFwiLGlkeCxcIi1zXCIscGlkeCxcIip0XCIsaixcInBcIixwaWR4LFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmFycy5sZW5ndGggPiAwKSB7XG4gICAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgfSAgXG4gIC8vU2NhbiBsb29wXG4gIGZvcihpPWRpbWVuc2lvbi0xOyBpPj0wOyAtLWkpIHsgLy8gU3RhcnQgYXQgbGFyZ2VzdCBzdHJpZGUgYW5kIHdvcmsgeW91ciB3YXkgaW53YXJkc1xuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgY29kZS5wdXNoKFtcImZvcihpXCIsaSxcIj0wO2lcIixpLFwiPHNcIixpZHgsXCI7KytpXCIsaSxcIil7XCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9QdXNoIGJvZHkgb2YgaW5uZXIgbG9vcFxuICBjb2RlLnB1c2goYm9keSlcbiAgLy9BZHZhbmNlIHNjYW4gcG9pbnRlcnNcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHBpZHggPSBpZHhcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgICAgY29kZS5wdXNoKFtcInBcIixqLFwiKz1kXCIsaixcInNcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGlmKGkgPiAwKSB7XG4gICAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixwaWR4LFwiXS09c1wiLHBpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goW1wiKytpbmRleFtcIixpZHgsXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbi8vIEdlbmVyYXRlIFwib3V0ZXJcIiBsb29wcyB0aGF0IGxvb3Agb3ZlciBibG9ja3Mgb2YgZGF0YSwgYXBwbHlpbmcgXCJpbm5lclwiIGxvb3BzIHRvIHRoZSBibG9ja3MgYnkgbWFuaXB1bGF0aW5nIHRoZSBsb2NhbCB2YXJpYWJsZXMgaW4gc3VjaCBhIHdheSB0aGF0IHRoZSBpbm5lciBsb29wIG9ubHkgXCJzZWVzXCIgdGhlIGN1cnJlbnQgYmxvY2suXG4vLyBUT0RPOiBJZiB0aGlzIGlzIHVzZWQsIHRoZW4gdGhlIHByZXZpb3VzIGRlY2xhcmF0aW9uIChkb25lIGJ5IGdlbmVyYXRlQ3dpc2VPcCkgb2YgcyogaXMgZXNzZW50aWFsbHkgdW5uZWNlc3NhcnkuXG4vLyAgICAgICBJIGJlbGlldmUgdGhlIHMqIGFyZSBub3QgdXNlZCBlbHNld2hlcmUgKGluIHBhcnRpY3VsYXIsIEkgZG9uJ3QgdGhpbmsgdGhleSdyZSB1c2VkIGluIHRoZSBwcmUvcG9zdCBwYXJ0cyBhbmQgXCJzaGFwZVwiIGlzIGRlZmluZWQgaW5kZXBlbmRlbnRseSksIHNvIGl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIG1ha2UgZGVmaW5pbmcgdGhlIHMqIGRlcGVuZGVudCBvbiB3aGF0IGxvb3AgbWV0aG9kIGlzIGJlaW5nIHVzZWQuXG5mdW5jdGlvbiBvdXRlckZpbGwobWF0Y2hlZCwgb3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGJsb2NrU2l6ZSA9IHByb2MuYmxvY2tTaXplXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwXG4gICAgLCBjb2RlID0gW11cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJ2YXIgb2Zmc2V0XCIsaSxcIj1wXCIsaV0uam9pbihcIlwiKSlcbiAgfVxuICAvL0dlbmVyYXRlIGxvb3BzIGZvciB1bm1hdGNoZWQgZGltZW5zaW9uc1xuICAvLyBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlc2UgZGltZW5zaW9ucyBhcmUgdHJhdmVyc2VkIGlzIGZhaXJseSBhcmJpdHJhcnkgKGZyb20gc21hbGwgc3RyaWRlIHRvIGxhcmdlIHN0cmlkZSwgZm9yIHRoZSBmaXJzdCBhcmd1bWVudClcbiAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSBpZiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlc2UgbG9vcHMgYXJlIHBsYWNlZCB3b3VsZCBhbHNvIGJlIHNvbWVob3cgXCJvcHRpbWFsXCIgKGF0IHRoZSB2ZXJ5IGxlYXN0IHdlIHNob3VsZCBjaGVjayB0aGF0IGl0IHJlYWxseSBkb2Vzbid0IGh1cnQgdXMgaWYgdGhleSdyZSBub3QpLlxuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJmb3IodmFyIGpcIitpK1wiPVNTW1wiLCBvcmRlcltpXSwgXCJdfDA7alwiLCBpLCBcIj4wOyl7XCJdLmpvaW4oXCJcIikpIC8vIEl0ZXJhdGUgYmFjayB0byBmcm9udFxuICAgIGNvZGUucHVzaChbXCJpZihqXCIsaSxcIjxcIixibG9ja1NpemUsXCIpe1wiXS5qb2luKFwiXCIpKSAvLyBFaXRoZXIgZGVjcmVhc2UgaiBieSBibG9ja1NpemUgKHMgPSBibG9ja1NpemUpLCBvciBzZXQgaXQgdG8gemVybyAoYWZ0ZXIgc2V0dGluZyBzID0gaikuXG4gICAgY29kZS5wdXNoKFtcInNcIixvcmRlcltpXSxcIj1qXCIsaV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJ9ZWxzZXtzXCIsb3JkZXJbaV0sXCI9XCIsYmxvY2tTaXplXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIi09XCIsYmxvY2tTaXplLFwifVwiXS5qb2luKFwiXCIpKVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLG9yZGVyW2ldLFwiXT1qXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIHZhciBpbmRleFN0ciA9IFtcIm9mZnNldFwiK2ldXG4gICAgZm9yKHZhciBqPW1hdGNoZWQ7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIGluZGV4U3RyLnB1c2goW1wialwiLGosXCIqdFwiLGksXCJwXCIsb3JkZXJbal1dLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChbXCJwXCIsaSxcIj0oXCIsaW5kZXhTdHIuam9pbihcIitcIiksXCIpXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgY29kZS5wdXNoKGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkpXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy9Db3VudCB0aGUgbnVtYmVyIG9mIGNvbXBhdGlibGUgaW5uZXIgb3JkZXJzXG4vLyBUaGlzIGlzIHRoZSBsZW5ndGggb2YgdGhlIGxvbmdlc3QgY29tbW9uIHByZWZpeCBvZiB0aGUgYXJyYXlzIGluIG9yZGVycy5cbi8vIEVhY2ggYXJyYXkgaW4gb3JkZXJzIGxpc3RzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb3JyZXNwb25kIG5kYXJyYXkgaW4gb3JkZXIgb2YgaW5jcmVhc2luZyBzdHJpZGUuXG4vLyBUaGlzIGlzIHRodXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRpbWVuc2lvbnMgdGhhdCBjYW4gYmUgZWZmaWNpZW50bHkgdHJhdmVyc2VkIGJ5IHNpbXBsZSBuZXN0ZWQgbG9vcHMgZm9yIGFsbCBhcnJheXMuXG5mdW5jdGlvbiBjb3VudE1hdGNoZXMob3JkZXJzKSB7XG4gIHZhciBtYXRjaGVkID0gMCwgZGltZW5zaW9uID0gb3JkZXJzWzBdLmxlbmd0aFxuICB3aGlsZShtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgZm9yKHZhciBqPTE7IGo8b3JkZXJzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvcmRlcnNbal1bbWF0Y2hlZF0gIT09IG9yZGVyc1swXVttYXRjaGVkXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFxuICAgICAgfVxuICAgIH1cbiAgICArK21hdGNoZWRcbiAgfVxuICByZXR1cm4gbWF0Y2hlZFxufVxuXG4vL1Byb2Nlc3NlcyBhIGJsb2NrIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZGF0YSB0eXBlc1xuLy8gUmVwbGFjZXMgdmFyaWFibGUgbmFtZXMgYnkgZGlmZmVyZW50IG9uZXMsIGVpdGhlciBcImxvY2FsXCIgb25lcyAodGhhdCBhcmUgdGhlbiBmZXJyaWVkIGluIGFuZCBvdXQgb2YgdGhlIGdpdmVuIGFycmF5KSBvciBvbmVzIG1hdGNoaW5nIHRoZSBhcmd1bWVudHMgdGhhdCB0aGUgZnVuY3Rpb24gcGVyZm9ybWluZyB0aGUgdWx0aW1hdGUgbG9vcCB3aWxsIGFjY2VwdC5cbmZ1bmN0aW9uIHByb2Nlc3NCbG9jayhibG9jaywgcHJvYywgZHR5cGVzKSB7XG4gIHZhciBjb2RlID0gYmxvY2suYm9keVxuICB2YXIgcHJlID0gW11cbiAgdmFyIHBvc3QgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxibG9jay5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNhcmcgPSBibG9jay5hcmdzW2ldXG4gICAgaWYoY2FyZy5jb3VudCA8PSAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKGNhcmcubmFtZSwgXCJnXCIpXG4gICAgdmFyIHB0clN0ciA9IFwiXCJcbiAgICB2YXIgYXJyTnVtID0gcHJvYy5hcnJheUFyZ3MuaW5kZXhPZihpKVxuICAgIHN3aXRjaChwcm9jLmFyZ1R5cGVzW2ldKSB7XG4gICAgICBjYXNlIFwib2Zmc2V0XCI6XG4gICAgICAgIHZhciBvZmZBcmdJbmRleCA9IHByb2Mub2Zmc2V0QXJnSW5kZXguaW5kZXhPZihpKVxuICAgICAgICB2YXIgb2ZmQXJnID0gcHJvYy5vZmZzZXRBcmdzW29mZkFyZ0luZGV4XVxuICAgICAgICBhcnJOdW0gPSBvZmZBcmcuYXJyYXlcbiAgICAgICAgcHRyU3RyID0gXCIrcVwiICsgb2ZmQXJnSW5kZXggLy8gQWRkcyBvZmZzZXQgdG8gdGhlIFwicG9pbnRlclwiIGluIHRoZSBhcnJheVxuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIHB0clN0ciA9IFwicFwiICsgYXJyTnVtICsgcHRyU3RyXG4gICAgICAgIHZhciBsb2NhbFN0ciA9IFwibFwiICsgaVxuICAgICAgICB2YXIgYXJyU3RyID0gXCJhXCIgKyBhcnJOdW1cbiAgICAgICAgaWYgKHByb2MuYXJyYXlCbG9ja0luZGljZXNbYXJyTnVtXSA9PT0gMCkgeyAvLyBBcmd1bWVudCB0byBib2R5IGlzIGp1c3QgYSBzaW5nbGUgdmFsdWUgZnJvbSB0aGlzIGFycmF5XG4gICAgICAgICAgaWYoY2FyZy5jb3VudCA9PT0gMSkgeyAvLyBBcmd1bWVudC9hcnJheSB1c2VkIG9ubHkgb25jZSg/KVxuICAgICAgICAgICAgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBJcyB0aGlzIG5lY2Vzc2FyeSBpZiB0aGUgYXJndW1lbnQgaXMgT05MWSB1c2VkIGFzIGFuIGx2YWx1ZT8gKGtlZXAgaW4gbWluZCB0aGF0IHdlIGNhbiBoYXZlIGEgKz0gc29tZXRoaW5nLCBzbyB3ZSB3b3VsZCBhY3R1YWxseSBuZWVkIHRvIGNoZWNrIGNhcmcucnZhbHVlKVxuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBUT0RPOiBDb3VsZCB3ZSBvcHRpbWl6ZSBieSBjaGVja2luZyBmb3IgY2FyZy5ydmFsdWU/XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSkgLy8gVE9ETzogQ291bGQgd2Ugb3B0aW1pemUgYnkgY2hlY2tpbmcgZm9yIGNhcmcucnZhbHVlP1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdPVwiLCBsb2NhbFN0cl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMgYSBcImJsb2NrXCJcbiAgICAgICAgICB2YXIgcmVTdHJBcnIgPSBbY2FyZy5uYW1lXSwgcHRyU3RyQXJyID0gW3B0clN0cl1cbiAgICAgICAgICBmb3IodmFyIGo9MDsgajxNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2Fyck51bV0pOyBqKyspIHtcbiAgICAgICAgICAgIHJlU3RyQXJyLnB1c2goXCJcXFxccypcXFxcWyhbXlxcXFxdXSspXFxcXF1cIilcbiAgICAgICAgICAgIHB0clN0ckFyci5wdXNoKFwiJFwiICsgKGorMSkgKyBcIip0XCIgKyBhcnJOdW0gKyBcImJcIiArIGopIC8vIE1hdGNoZWQgaW5kZXggdGltZXMgc3RyaWRlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChyZVN0ckFyci5qb2luKFwiXCIpLCBcImdcIilcbiAgICAgICAgICBwdHJTdHIgPSBwdHJTdHJBcnIuam9pbihcIitcIilcbiAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIC8qaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBJcyB0aGlzIG5lY2Vzc2FyeSBpZiB0aGUgYXJndW1lbnQgaXMgT05MWSB1c2VkIGFzIGFuIGx2YWx1ZT8gKGtlZXAgaW4gbWluZCB0aGF0IHdlIGNhbiBoYXZlIGEgKz0gc29tZXRoaW5nLCBzbyB3ZSB3b3VsZCBhY3R1YWxseSBuZWVkIHRvIGNoZWNrIGNhcmcucnZhbHVlKVxuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBHZW5lcmljIGFycmF5cyBub3Qgc3VwcG9ydGVkIGluIGNvbWJpbmF0aW9uIHdpdGggYmxvY2tzIVwiKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGRvZXMgbm90IHByb2R1Y2UgYW55IGxvY2FsIHZhcmlhYmxlcywgZXZlbiBpZiB2YXJpYWJsZXMgYXJlIHVzZWQgbXVsdGlwbGUgdGltZXMuIEl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIGRvIHNvLCBidXQgaXQgd291bGQgY29tcGxpY2F0ZSB0aGluZ3MgcXVpdGUgYSBiaXQuXG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiWVwiICsgcHJvYy5zY2FsYXJBcmdzLmluZGV4T2YoaSkpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiaW5kZXhcIilcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2hhcGVcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJzaGFwZVwiKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwcmUuam9pbihcIlxcblwiKSwgY29kZSwgcG9zdC5qb2luKFwiXFxuXCIpXS5qb2luKFwiXFxuXCIpLnRyaW0oKVxufVxuXG5mdW5jdGlvbiB0eXBlU3VtbWFyeShkdHlwZXMpIHtcbiAgdmFyIHN1bW1hcnkgPSBuZXcgQXJyYXkoZHR5cGVzLmxlbmd0aClcbiAgdmFyIGFsbEVxdWFsID0gdHJ1ZVxuICBmb3IodmFyIGk9MDsgaTxkdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdCA9IGR0eXBlc1tpXVxuICAgIHZhciBkaWdpdHMgPSB0Lm1hdGNoKC9cXGQrLylcbiAgICBpZighZGlnaXRzKSB7XG4gICAgICBkaWdpdHMgPSBcIlwiXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZ2l0cyA9IGRpZ2l0c1swXVxuICAgIH1cbiAgICBpZih0LmNoYXJBdCgwKSA9PT0gMCkge1xuICAgICAgc3VtbWFyeVtpXSA9IFwidVwiICsgdC5jaGFyQXQoMSkgKyBkaWdpdHNcbiAgICB9IGVsc2Uge1xuICAgICAgc3VtbWFyeVtpXSA9IHQuY2hhckF0KDApICsgZGlnaXRzXG4gICAgfVxuICAgIGlmKGkgPiAwKSB7XG4gICAgICBhbGxFcXVhbCA9IGFsbEVxdWFsICYmIHN1bW1hcnlbaV0gPT09IHN1bW1hcnlbaS0xXVxuICAgIH1cbiAgfVxuICBpZihhbGxFcXVhbCkge1xuICAgIHJldHVybiBzdW1tYXJ5WzBdXG4gIH1cbiAgcmV0dXJuIHN1bW1hcnkuam9pbihcIlwiKVxufVxuXG4vL0dlbmVyYXRlcyBhIGN3aXNlIG9wZXJhdG9yXG5mdW5jdGlvbiBnZW5lcmF0ZUNXaXNlT3AocHJvYywgdHlwZXNpZykge1xuXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb25cbiAgLy8gQXJyYXlzIGdldCBwdXQgZmlyc3QgaW4gdHlwZXNpZywgYW5kIHRoZXJlIGFyZSB0d28gZW50cmllcyBwZXIgYXJyYXkgKGR0eXBlIGFuZCBvcmRlciksIHNvIHRoaXMgZ2V0cyB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgaW4gdGhlIGZpcnN0IGFycmF5IGFyZy5cbiAgdmFyIGRpbWVuc2lvbiA9ICh0eXBlc2lnWzFdLmxlbmd0aCAtIE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pKXwwXG4gIHZhciBvcmRlcnMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICB2YXIgZHR5cGVzID0gbmV3IEFycmF5KHByb2MuYXJyYXlBcmdzLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBkdHlwZXNbaV0gPSB0eXBlc2lnWzIqaV1cbiAgICBvcmRlcnNbaV0gPSB0eXBlc2lnWzIqaSsxXVxuICB9XG4gIFxuICAvL0RldGVybWluZSB3aGVyZSBibG9jayBhbmQgbG9vcCBpbmRpY2VzIHN0YXJ0IGFuZCBlbmRcbiAgdmFyIGJsb2NrQmVnaW4gPSBbXSwgYmxvY2tFbmQgPSBbXSAvLyBUaGVzZSBpbmRpY2VzIGFyZSBleHBvc2VkIGFzIGJsb2Nrc1xuICB2YXIgbG9vcEJlZ2luID0gW10sIGxvb3BFbmQgPSBbXSAvLyBUaGVzZSBpbmRpY2VzIGFyZSBpdGVyYXRlZCBvdmVyXG4gIHZhciBsb29wT3JkZXJzID0gW10gLy8gb3JkZXJzIHJlc3RyaWN0ZWQgdG8gdGhlIGxvb3AgaW5kaWNlc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldPDApIHtcbiAgICAgIGxvb3BCZWdpbi5wdXNoKDApXG4gICAgICBsb29wRW5kLnB1c2goZGltZW5zaW9uKVxuICAgICAgYmxvY2tCZWdpbi5wdXNoKGRpbWVuc2lvbilcbiAgICAgIGJsb2NrRW5kLnB1c2goZGltZW5zaW9uK3Byb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGxvb3BCZWdpbi5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pIC8vIE5vbi1uZWdhdGl2ZVxuICAgICAgbG9vcEVuZC5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0rZGltZW5zaW9uKVxuICAgICAgYmxvY2tCZWdpbi5wdXNoKDApXG4gICAgICBibG9ja0VuZC5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pXG4gICAgfVxuICAgIHZhciBuZXdPcmRlciA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b3JkZXJzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobG9vcEJlZ2luW2ldPD1vcmRlcnNbaV1bal0gJiYgb3JkZXJzW2ldW2pdPGxvb3BFbmRbaV0pIHtcbiAgICAgICAgbmV3T3JkZXIucHVzaChvcmRlcnNbaV1bal0tbG9vcEJlZ2luW2ldKSAvLyBJZiB0aGlzIGlzIGEgbG9vcCBpbmRleCwgcHV0IGl0IGluIG5ld09yZGVyLCBzdWJ0cmFjdGluZyBsb29wQmVnaW4sIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBsb29wT3JkZXJzIGFyZSB1c2luZyBhIGNvbW1vbiBzZXQgb2YgaW5kaWNlcy5cbiAgICAgIH1cbiAgICB9XG4gICAgbG9vcE9yZGVycy5wdXNoKG5ld09yZGVyKVxuICB9XG5cbiAgLy9GaXJzdCBjcmVhdGUgYXJndW1lbnRzIGZvciBwcm9jZWR1cmVcbiAgdmFyIGFyZ2xpc3QgPSBbXCJTU1wiXSAvLyBTUyBpcyB0aGUgb3ZlcmFsbCBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGVcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cbiAgdmFyIHZhcnMgPSBbXVxuICBcbiAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICB2YXJzLnB1c2goW1wic1wiLCBqLCBcIj1TU1tcIiwgaiwgXCJdXCJdLmpvaW4oXCJcIikpIC8vIFRoZSBsaW1pdHMgZm9yIGVhY2ggZGltZW5zaW9uLlxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiYVwiK2kpIC8vIEFjdHVhbCBkYXRhIGFycmF5XG4gICAgYXJnbGlzdC5wdXNoKFwidFwiK2kpIC8vIFN0cmlkZXNcbiAgICBhcmdsaXN0LnB1c2goXCJwXCIraSkgLy8gT2Zmc2V0IGluIHRoZSBhcnJheSBhdCB3aGljaCB0aGUgZGF0YSBzdGFydHMgKGFsc28gdXNlZCBmb3IgaXRlcmF0aW5nIG92ZXIgdGhlIGRhdGEpXG4gICAgXG4gICAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHsgLy8gVW5wYWNrIHRoZSBzdHJpZGVzIGludG8gdmFycyBmb3IgbG9vcGluZ1xuICAgICAgdmFycy5wdXNoKFtcInRcIixpLFwicFwiLGosXCI9dFwiLGksXCJbXCIsbG9vcEJlZ2luW2ldK2osXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIFxuICAgIGZvcih2YXIgaj0wOyBqPE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pOyArK2opIHsgLy8gVW5wYWNrIHRoZSBzdHJpZGVzIGludG8gdmFycyBmb3IgYmxvY2sgaXRlcmF0aW9uXG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJiXCIsaixcIj10XCIsaSxcIltcIixibG9ja0JlZ2luW2ldK2osXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2Muc2NhbGFyQXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ2xpc3QucHVzaChcIllcIiArIGkpXG4gIH1cbiAgaWYocHJvYy5zaGFwZUFyZ3MubGVuZ3RoID4gMCkge1xuICAgIHZhcnMucHVzaChcInNoYXBlPVNTLnNsaWNlKDApXCIpIC8vIE1ha2VzIHRoZSBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGUgYXZhaWxhYmxlIHRvIHRoZSB1c2VyIGRlZmluZWQgZnVuY3Rpb25zIChzbyB5b3UgY2FuIHVzZSB3aWR0aC9oZWlnaHQgZm9yIGV4YW1wbGUpXG4gIH1cbiAgaWYocHJvYy5pbmRleEFyZ3MubGVuZ3RoID4gMCkge1xuICAgIC8vIFByZXBhcmUgYW4gYXJyYXkgdG8ga2VlcCB0cmFjayBvZiB0aGUgKGxvZ2ljYWwpIGluZGljZXMsIGluaXRpYWxpemVkIHRvIGRpbWVuc2lvbiB6ZXJvZXMuXG4gICAgdmFyIHplcm9zID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgemVyb3NbaV0gPSBcIjBcIlxuICAgIH1cbiAgICB2YXJzLnB1c2goW1wiaW5kZXg9W1wiLCB6ZXJvcy5qb2luKFwiLFwiKSwgXCJdXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5vZmZzZXRBcmdzLmxlbmd0aDsgKytpKSB7IC8vIE9mZnNldCBhcmd1bWVudHMgdXNlZCBmb3Igc3RlbmNpbCBvcGVyYXRpb25zXG4gICAgdmFyIG9mZl9hcmcgPSBwcm9jLm9mZnNldEFyZ3NbaV1cbiAgICB2YXIgaW5pdF9zdHJpbmcgPSBbXVxuICAgIGZvcih2YXIgaj0wOyBqPG9mZl9hcmcub2Zmc2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvZmZfYXJnLm9mZnNldFtqXSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAxKSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW1widFwiLCBvZmZfYXJnLmFycmF5LCBcInBcIiwgal0uam9pbihcIlwiKSkgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW29mZl9hcmcub2Zmc2V0W2pdLCBcIip0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihpbml0X3N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhcnMucHVzaChcInFcIiArIGkgKyBcIj0wXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMucHVzaChbXCJxXCIsIGksIFwiPVwiLCBpbml0X3N0cmluZy5qb2luKFwiK1wiKV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cblxuICAvL1ByZXBhcmUgdGhpcyB2YXJpYWJsZXNcbiAgdmFyIHRoaXNWYXJzID0gdW5pcShbXS5jb25jYXQocHJvYy5wcmUudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLmJvZHkudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLnBvc3QudGhpc1ZhcnMpKVxuICB2YXJzID0gdmFycy5jb25jYXQodGhpc1ZhcnMpXG4gIGlmICh2YXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwicFwiK2krXCJ8PTBcIilcbiAgfVxuICBcbiAgLy9JbmxpbmUgcHJlbHVkZVxuICBpZihwcm9jLnByZS5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucHJlLCBwcm9jLCBkdHlwZXMpKVxuICB9XG5cbiAgLy9Qcm9jZXNzIGJvZHlcbiAgdmFyIGJvZHkgPSBwcm9jZXNzQmxvY2socHJvYy5ib2R5LCBwcm9jLCBkdHlwZXMpXG4gIHZhciBtYXRjaGVkID0gY291bnRNYXRjaGVzKGxvb3BPcmRlcnMpXG4gIGlmKG1hdGNoZWQgPCBkaW1lbnNpb24pIHtcbiAgICBjb2RlLnB1c2gob3V0ZXJGaWxsKG1hdGNoZWQsIGxvb3BPcmRlcnNbMF0sIHByb2MsIGJvZHkpKSAvLyBUT0RPOiBSYXRoZXIgdGhhbiBwYXNzaW5nIGxvb3BPcmRlcnNbMF0sIGl0IG1pZ2h0IGJlIGludGVyZXN0aW5nIHRvIGxvb2sgYXQgcGFzc2luZyBhbiBvcmRlciB0aGF0IHJlcHJlc2VudHMgdGhlIG1ham9yaXR5IG9mIHRoZSBhcmd1bWVudHMgZm9yIGV4YW1wbGUuXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKGlubmVyRmlsbChsb29wT3JkZXJzWzBdLCBwcm9jLCBib2R5KSlcbiAgfVxuXG4gIC8vSW5saW5lIGVwaWxvZ1xuICBpZihwcm9jLnBvc3QuYm9keS5sZW5ndGggPiAzKSB7XG4gICAgY29kZS5wdXNoKHByb2Nlc3NCbG9jayhwcm9jLnBvc3QsIHByb2MsIGR0eXBlcykpXG4gIH1cbiAgXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIGN3aXNlIHJvdXRpbmUgZm9yIFwiLCB0eXBlc2lnLCBcIjpcXG5cIiArIGNvZGUuam9pbihcIlxcblwiKSArIFwiXFxuLS0tLS0tLS0tLVwiKVxuICB9XG4gIFxuICB2YXIgbG9vcE5hbWUgPSBbKHByb2MuZnVuY05hbWV8fFwidW5uYW1lZFwiKSwgXCJfY3dpc2VfbG9vcF9cIiwgb3JkZXJzWzBdLmpvaW4oXCJzXCIpLFwibVwiLG1hdGNoZWQsdHlwZVN1bW1hcnkoZHR5cGVzKV0uam9pbihcIlwiKVxuICB2YXIgZiA9IG5ldyBGdW5jdGlvbihbXCJmdW5jdGlvbiBcIixsb29wTmFtZSxcIihcIiwgYXJnbGlzdC5qb2luKFwiLFwiKSxcIil7XCIsIGNvZGUuam9pbihcIlxcblwiKSxcIn0gcmV0dXJuIFwiLCBsb29wTmFtZV0uam9pbihcIlwiKSlcbiAgcmV0dXJuIGYoKVxufVxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZUNXaXNlT3BcbiJdLCJuYW1lcyI6WyJ1bmlxIiwicmVxdWlyZSIsImlubmVyRmlsbCIsIm9yZGVyIiwicHJvYyIsImJvZHkiLCJkaW1lbnNpb24iLCJsZW5ndGgiLCJuYXJncyIsImFycmF5QXJncyIsImhhc19pbmRleCIsImluZGV4QXJncyIsImNvZGUiLCJ2YXJzIiwiaWR4IiwicGlkeCIsImkiLCJqIiwicHVzaCIsImpvaW4iLCJvdXRlckZpbGwiLCJtYXRjaGVkIiwiYmxvY2tTaXplIiwiaW5kZXhTdHIiLCJjb3VudE1hdGNoZXMiLCJvcmRlcnMiLCJwcm9jZXNzQmxvY2siLCJibG9jayIsImR0eXBlcyIsInByZSIsInBvc3QiLCJhcmdzIiwiY2FyZyIsImNvdW50IiwicmUiLCJSZWdFeHAiLCJuYW1lIiwicHRyU3RyIiwiYXJyTnVtIiwiaW5kZXhPZiIsImFyZ1R5cGVzIiwib2ZmQXJnSW5kZXgiLCJvZmZzZXRBcmdJbmRleCIsIm9mZkFyZyIsIm9mZnNldEFyZ3MiLCJhcnJheSIsImxvY2FsU3RyIiwiYXJyU3RyIiwiYXJyYXlCbG9ja0luZGljZXMiLCJsdmFsdWUiLCJyZXBsYWNlIiwicmVTdHJBcnIiLCJwdHJTdHJBcnIiLCJNYXRoIiwiYWJzIiwiRXJyb3IiLCJzY2FsYXJBcmdzIiwidHJpbSIsInR5cGVTdW1tYXJ5Iiwic3VtbWFyeSIsIkFycmF5IiwiYWxsRXF1YWwiLCJ0IiwiZGlnaXRzIiwibWF0Y2giLCJjaGFyQXQiLCJnZW5lcmF0ZUNXaXNlT3AiLCJ0eXBlc2lnIiwiYmxvY2tCZWdpbiIsImJsb2NrRW5kIiwibG9vcEJlZ2luIiwibG9vcEVuZCIsImxvb3BPcmRlcnMiLCJuZXdPcmRlciIsImFyZ2xpc3QiLCJzaGFwZUFyZ3MiLCJ6ZXJvcyIsIm9mZl9hcmciLCJpbml0X3N0cmluZyIsIm9mZnNldCIsInRoaXNWYXJzIiwiY29uY2F0IiwiZGVidWciLCJjb25zb2xlIiwibG9nIiwibG9vcE5hbWUiLCJmdW5jTmFtZSIsImYiLCJGdW5jdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cwise-compiler/lib/compile.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cwise-compiler/lib/thunk.js":
/*!**************************************************!*\
  !*** ./node_modules/cwise-compiler/lib/thunk.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// The function below is called when constructing a cwise function object, and does the following:\n// A function object is constructed which accepts as argument a compilation function and returns another function.\n// It is this other function that is eventually returned by createThunk, and this function is the one that actually\n// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.\n// The compilation passed to the first function object is used for compiling new functions.\n// Once this function object is created, it is called with compile as argument, where the first argument of compile\n// is bound to \"proc\" (essentially containing a preprocessed version of the user arguments to cwise).\n// So createThunk roughly works like this:\n// function createThunk(proc) {\n//   var thunk = function(compileBound) {\n//     var CACHED = {}\n//     return function(arrays and scalars) {\n//       if (dtype and order of arrays in CACHED) {\n//         var func = CACHED[dtype and order of arrays]\n//       } else {\n//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)\n//       }\n//       return func(arrays and scalars)\n//     }\n//   }\n//   return thunk(compile.bind1(proc))\n// }\nvar compile = __webpack_require__(/*! ./compile.js */ \"(ssr)/./node_modules/cwise-compiler/lib/compile.js\");\nfunction createThunk(proc) {\n    var code = [\n        \"'use strict'\",\n        \"var CACHED={}\"\n    ];\n    var vars = [];\n    var thunkName = proc.funcName + \"_cwise_thunk\";\n    //Build thunk\n    code.push([\n        \"return function \",\n        thunkName,\n        \"(\",\n        proc.shimArgs.join(\",\"),\n        \"){\"\n    ].join(\"\"));\n    var typesig = [];\n    var string_typesig = [];\n    var proc_args = [\n        [\n            \"array\",\n            proc.arrayArgs[0],\n            \".shape.slice(\",\n            Math.max(0, proc.arrayBlockIndices[0]),\n            proc.arrayBlockIndices[0] < 0 ? \",\" + proc.arrayBlockIndices[0] + \")\" : \")\"\n        ].join(\"\")\n    ];\n    var shapeLengthConditions = [], shapeConditions = [];\n    // Process array arguments\n    for(var i = 0; i < proc.arrayArgs.length; ++i){\n        var j = proc.arrayArgs[i];\n        vars.push([\n            \"t\",\n            j,\n            \"=array\",\n            j,\n            \".dtype,\",\n            \"r\",\n            j,\n            \"=array\",\n            j,\n            \".order\"\n        ].join(\"\"));\n        typesig.push(\"t\" + j);\n        typesig.push(\"r\" + j);\n        string_typesig.push(\"t\" + j);\n        string_typesig.push(\"r\" + j + \".join()\");\n        proc_args.push(\"array\" + j + \".data\");\n        proc_args.push(\"array\" + j + \".stride\");\n        proc_args.push(\"array\" + j + \".offset|0\");\n        if (i > 0) {\n            shapeLengthConditions.push(\"array\" + proc.arrayArgs[0] + \".shape.length===array\" + j + \".shape.length+\" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));\n            shapeConditions.push(\"array\" + proc.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0, proc.arrayBlockIndices[0]) + \"]===array\" + j + \".shape[shapeIndex+\" + Math.max(0, proc.arrayBlockIndices[i]) + \"]\");\n        }\n    }\n    // Check for shape equality\n    if (proc.arrayArgs.length > 1) {\n        code.push(\"if (!(\" + shapeLengthConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\");\n        code.push(\"for(var shapeIndex=array\" + proc.arrayArgs[0] + \".shape.length-\" + Math.abs(proc.arrayBlockIndices[0]) + \"; shapeIndex-->0;) {\");\n        code.push(\"if (!(\" + shapeConditions.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\");\n        code.push(\"}\");\n    }\n    // Process scalar arguments\n    for(var i = 0; i < proc.scalarArgs.length; ++i){\n        proc_args.push(\"scalar\" + proc.scalarArgs[i]);\n    }\n    // Check for cached function (and if not present, generate it)\n    vars.push([\n        \"type=[\",\n        string_typesig.join(\",\"),\n        \"].join()\"\n    ].join(\"\"));\n    vars.push(\"proc=CACHED[type]\");\n    code.push(\"var \" + vars.join(\",\"));\n    code.push([\n        \"if(!proc){\",\n        \"CACHED[type]=proc=compile([\",\n        typesig.join(\",\"),\n        \"])}\",\n        \"return proc(\",\n        proc_args.join(\",\"),\n        \")}\"\n    ].join(\"\"));\n    if (proc.debug) {\n        console.log(\"-----Generated thunk:\\n\" + code.join(\"\\n\") + \"\\n----------\");\n    }\n    //Compile thunk\n    var thunk = new Function(\"compile\", code.join(\"\\n\"));\n    return thunk(compile.bind(undefined, proc));\n}\nmodule.exports = createThunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsa0dBQWtHO0FBQ2xHLGtIQUFrSDtBQUNsSCxtSEFBbUg7QUFDbkgsK0dBQStHO0FBQy9HLDJGQUEyRjtBQUMzRixtSEFBbUg7QUFDbkgscUdBQXFHO0FBQ3JHLDBDQUEwQztBQUMxQywrQkFBK0I7QUFDL0IseUNBQXlDO0FBQ3pDLHNCQUFzQjtBQUN0Qiw0Q0FBNEM7QUFDNUMsbURBQW1EO0FBQ25ELHVEQUF1RDtBQUN2RCxpQkFBaUI7QUFDakIsaUdBQWlHO0FBQ2pHLFVBQVU7QUFDVix3Q0FBd0M7QUFDeEMsUUFBUTtBQUNSLE1BQU07QUFDTixzQ0FBc0M7QUFDdEMsSUFBSTtBQUVKLElBQUlBLFVBQVVDLG1CQUFPQSxDQUFDLHdFQUFjO0FBRXBDLFNBQVNDLFlBQVlDLElBQUk7SUFDdkIsSUFBSUMsT0FBTztRQUFDO1FBQWdCO0tBQWdCO0lBQzVDLElBQUlDLE9BQU8sRUFBRTtJQUNiLElBQUlDLFlBQVlILEtBQUtJLFFBQVEsR0FBRztJQUVoQyxhQUFhO0lBQ2JILEtBQUtJLElBQUksQ0FBQztRQUFDO1FBQW9CRjtRQUFXO1FBQUtILEtBQUtNLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDO1FBQU07S0FBSyxDQUFDQSxJQUFJLENBQUM7SUFDbkYsSUFBSUMsVUFBVSxFQUFFO0lBQ2hCLElBQUlDLGlCQUFpQixFQUFFO0lBQ3ZCLElBQUlDLFlBQVk7UUFBQztZQUFDO1lBQVFWLEtBQUtXLFNBQVMsQ0FBQyxFQUFFO1lBQUM7WUFDMUJDLEtBQUtDLEdBQUcsQ0FBQyxHQUFFYixLQUFLYyxpQkFBaUIsQ0FBQyxFQUFFO1lBQUVkLEtBQUtjLGlCQUFpQixDQUFDLEVBQUUsR0FBQyxJQUFHLE1BQUlkLEtBQUtjLGlCQUFpQixDQUFDLEVBQUUsR0FBQyxNQUFLO1NBQUksQ0FBQ1AsSUFBSSxDQUFDO0tBQUk7SUFDdEksSUFBSVEsd0JBQXdCLEVB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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xci1jb2RlLy4vbm9kZV9tb2R1bGVzL2N3aXNlLWNvbXBpbGVyL2xpYi90aHVuay5qcz82NjQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbi8vIFRoZSBmdW5jdGlvbiBiZWxvdyBpcyBjYWxsZWQgd2hlbiBjb25zdHJ1Y3RpbmcgYSBjd2lzZSBmdW5jdGlvbiBvYmplY3QsIGFuZCBkb2VzIHRoZSBmb2xsb3dpbmc6XG4vLyBBIGZ1bmN0aW9uIG9iamVjdCBpcyBjb25zdHJ1Y3RlZCB3aGljaCBhY2NlcHRzIGFzIGFyZ3VtZW50IGEgY29tcGlsYXRpb24gZnVuY3Rpb24gYW5kIHJldHVybnMgYW5vdGhlciBmdW5jdGlvbi5cbi8vIEl0IGlzIHRoaXMgb3RoZXIgZnVuY3Rpb24gdGhhdCBpcyBldmVudHVhbGx5IHJldHVybmVkIGJ5IGNyZWF0ZVRodW5rLCBhbmQgdGhpcyBmdW5jdGlvbiBpcyB0aGUgb25lIHRoYXQgYWN0dWFsbHlcbi8vIGNoZWNrcyB3aGV0aGVyIGEgY2VydGFpbiBwYXR0ZXJuIG9mIGFyZ3VtZW50cyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgYmVmb3JlIGFuZCBjb21waWxlcyBuZXcgbG9vcHMgYXMgbmVlZGVkLlxuLy8gVGhlIGNvbXBpbGF0aW9uIHBhc3NlZCB0byB0aGUgZmlyc3QgZnVuY3Rpb24gb2JqZWN0IGlzIHVzZWQgZm9yIGNvbXBpbGluZyBuZXcgZnVuY3Rpb25zLlxuLy8gT25jZSB0aGlzIGZ1bmN0aW9uIG9iamVjdCBpcyBjcmVhdGVkLCBpdCBpcyBjYWxsZWQgd2l0aCBjb21waWxlIGFzIGFyZ3VtZW50LCB3aGVyZSB0aGUgZmlyc3QgYXJndW1lbnQgb2YgY29tcGlsZVxuLy8gaXMgYm91bmQgdG8gXCJwcm9jXCIgKGVzc2VudGlhbGx5IGNvbnRhaW5pbmcgYSBwcmVwcm9jZXNzZWQgdmVyc2lvbiBvZiB0aGUgdXNlciBhcmd1bWVudHMgdG8gY3dpc2UpLlxuLy8gU28gY3JlYXRlVGh1bmsgcm91Z2hseSB3b3JrcyBsaWtlIHRoaXM6XG4vLyBmdW5jdGlvbiBjcmVhdGVUaHVuayhwcm9jKSB7XG4vLyAgIHZhciB0aHVuayA9IGZ1bmN0aW9uKGNvbXBpbGVCb3VuZCkge1xuLy8gICAgIHZhciBDQUNIRUQgPSB7fVxuLy8gICAgIHJldHVybiBmdW5jdGlvbihhcnJheXMgYW5kIHNjYWxhcnMpIHtcbi8vICAgICAgIGlmIChkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzIGluIENBQ0hFRCkge1xuLy8gICAgICAgICB2YXIgZnVuYyA9IENBQ0hFRFtkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzXVxuLy8gICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgdmFyIGZ1bmMgPSBDQUNIRURbZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5c10gPSBjb21waWxlQm91bmQoZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5cylcbi8vICAgICAgIH1cbi8vICAgICAgIHJldHVybiBmdW5jKGFycmF5cyBhbmQgc2NhbGFycylcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgcmV0dXJuIHRodW5rKGNvbXBpbGUuYmluZDEocHJvYykpXG4vLyB9XG5cbnZhciBjb21waWxlID0gcmVxdWlyZShcIi4vY29tcGlsZS5qc1wiKVxuXG5mdW5jdGlvbiBjcmVhdGVUaHVuayhwcm9jKSB7XG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCIsIFwidmFyIENBQ0hFRD17fVwiXVxuICB2YXIgdmFycyA9IFtdXG4gIHZhciB0aHVua05hbWUgPSBwcm9jLmZ1bmNOYW1lICsgXCJfY3dpc2VfdGh1bmtcIlxuICBcbiAgLy9CdWlsZCB0aHVua1xuICBjb2RlLnB1c2goW1wicmV0dXJuIGZ1bmN0aW9uIFwiLCB0aHVua05hbWUsIFwiKFwiLCBwcm9jLnNoaW1BcmdzLmpvaW4oXCIsXCIpLCBcIil7XCJdLmpvaW4oXCJcIikpXG4gIHZhciB0eXBlc2lnID0gW11cbiAgdmFyIHN0cmluZ190eXBlc2lnID0gW11cbiAgdmFyIHByb2NfYXJncyA9IFtbXCJhcnJheVwiLHByb2MuYXJyYXlBcmdzWzBdLFwiLnNoYXBlLnNsaWNlKFwiLCAvLyBTbGljZSBzaGFwZSBzbyB0aGF0IHdlIG9ubHkgcmV0YWluIHRoZSBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGUgKHdoaWNoIGdldHMgcGFzc2VkIHRvIHRoZSBjd2lzZSBvcGVyYXRvciBhcyBTUykuXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXTwwPyhcIixcIitwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdK1wiKVwiKTpcIilcIl0uam9pbihcIlwiKV1cbiAgdmFyIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucyA9IFtdLCBzaGFwZUNvbmRpdGlvbnMgPSBbXVxuICAvLyBQcm9jZXNzIGFycmF5IGFyZ3VtZW50c1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBqID0gcHJvYy5hcnJheUFyZ3NbaV1cbiAgICB2YXJzLnB1c2goW1widFwiLCBqLCBcIj1hcnJheVwiLCBqLCBcIi5kdHlwZSxcIixcbiAgICAgICAgICAgICAgIFwiclwiLCBqLCBcIj1hcnJheVwiLCBqLCBcIi5vcmRlclwiXS5qb2luKFwiXCIpKVxuICAgIHR5cGVzaWcucHVzaChcInRcIiArIGopXG4gICAgdHlwZXNpZy5wdXNoKFwiclwiICsgailcbiAgICBzdHJpbmdfdHlwZXNpZy5wdXNoKFwidFwiK2opXG4gICAgc3RyaW5nX3R5cGVzaWcucHVzaChcInJcIitqK1wiLmpvaW4oKVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5kYXRhXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLnN0cmlkZVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5vZmZzZXR8MFwiKVxuICAgIGlmIChpPjApIHsgLy8gR2F0aGVyIGNvbmRpdGlvbnMgdG8gY2hlY2sgZm9yIHNoYXBlIGVxdWFsaXR5IChpZ25vcmluZyBibG9jayBpbmRpY2VzKVxuICAgICAgc2hhcGVMZW5ndGhDb25kaXRpb25zLnB1c2goXCJhcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZS5sZW5ndGg9PT1hcnJheVwiICsgaiArIFwiLnNoYXBlLmxlbmd0aCtcIiArIChNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKS1NYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKSkpXG4gICAgICBzaGFwZUNvbmRpdGlvbnMucHVzaChcImFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlW3NoYXBlSW5kZXgrXCIgKyBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pICsgXCJdPT09YXJyYXlcIiArIGogKyBcIi5zaGFwZVtzaGFwZUluZGV4K1wiICsgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKSArIFwiXVwiKVxuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3Igc2hhcGUgZXF1YWxpdHlcbiAgaWYgKHByb2MuYXJyYXlBcmdzLmxlbmd0aCA+IDEpIHtcbiAgICBjb2RlLnB1c2goXCJpZiAoIShcIiArIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucy5qb2luKFwiICYmIFwiKSArIFwiKSkgdGhyb3cgbmV3IEVycm9yKCdjd2lzZTogQXJyYXlzIGRvIG5vdCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25hbGl0eSEnKVwiKVxuICAgIGNvZGUucHVzaChcImZvcih2YXIgc2hhcGVJbmRleD1hcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZS5sZW5ndGgtXCIgKyBNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSArIFwiOyBzaGFwZUluZGV4LS0+MDspIHtcIilcbiAgICBjb2RlLnB1c2goXCJpZiAoIShcIiArIHNoYXBlQ29uZGl0aW9ucy5qb2luKFwiICYmIFwiKSArIFwiKSkgdGhyb3cgbmV3IEVycm9yKCdjd2lzZTogQXJyYXlzIGRvIG5vdCBhbGwgaGF2ZSB0aGUgc2FtZSBzaGFwZSEnKVwiKVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICAvLyBQcm9jZXNzIHNjYWxhciBhcmd1bWVudHNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgcHJvY19hcmdzLnB1c2goXCJzY2FsYXJcIiArIHByb2Muc2NhbGFyQXJnc1tpXSlcbiAgfVxuICAvLyBDaGVjayBmb3IgY2FjaGVkIGZ1bmN0aW9uIChhbmQgaWYgbm90IHByZXNlbnQsIGdlbmVyYXRlIGl0KVxuICB2YXJzLnB1c2goW1widHlwZT1bXCIsIHN0cmluZ190eXBlc2lnLmpvaW4oXCIsXCIpLCBcIl0uam9pbigpXCJdLmpvaW4oXCJcIikpXG4gIHZhcnMucHVzaChcInByb2M9Q0FDSEVEW3R5cGVdXCIpXG4gIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIFxuICBjb2RlLnB1c2goW1wiaWYoIXByb2Mpe1wiLFxuICAgICAgICAgICAgIFwiQ0FDSEVEW3R5cGVdPXByb2M9Y29tcGlsZShbXCIsIHR5cGVzaWcuam9pbihcIixcIiksIFwiXSl9XCIsXG4gICAgICAgICAgICAgXCJyZXR1cm4gcHJvYyhcIiwgcHJvY19hcmdzLmpvaW4oXCIsXCIpLCBcIil9XCJdLmpvaW4oXCJcIikpXG5cbiAgaWYocHJvYy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKFwiLS0tLS1HZW5lcmF0ZWQgdGh1bms6XFxuXCIgKyBjb2RlLmpvaW4oXCJcXG5cIikgKyBcIlxcbi0tLS0tLS0tLS1cIilcbiAgfVxuICBcbiAgLy9Db21waWxlIHRodW5rXG4gIHZhciB0aHVuayA9IG5ldyBGdW5jdGlvbihcImNvbXBpbGVcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gdGh1bmsoY29tcGlsZS5iaW5kKHVuZGVmaW5lZCwgcHJvYykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGh1bmtcbiJdLCJuYW1lcyI6WyJjb21waWxlIiwicmVxdWlyZSIsImNyZWF0ZVRodW5rIiwicHJvYyIsImNvZGUiLCJ2YXJzIiwidGh1bmtOYW1lIiwiZnVuY05hbWUiLCJwdXNoIiwic2hpbUFyZ3MiLCJqb2luIiwidHlwZXNpZyIsInN0cmluZ190eXBlc2lnIiwicHJvY19hcmdzIiwiYXJyYXlBcmdzIiwiTWF0aCIsIm1heCIsImFycmF5QmxvY2tJbmRpY2VzIiwic2hhcGVMZW5ndGhDb25kaXRpb25zIiwic2hhcGVDb25kaXRpb25zIiwiaSIsImxlbmd0aCIsImoiLCJhYnMiLCJzY2FsYXJBcmdzIiwiZGVidWciLCJjb25zb2xlIiwibG9nIiwidGh1bmsiLCJGdW5jdGlvbiIsImJpbmQiLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cwise-compiler/lib/thunk.js\n");

/***/ })

};
;