"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/omggif";
exports.ids = ["vendor-chunks/omggif"];
exports.modules = {

/***/ "(ssr)/./node_modules/omggif/omggif.js":
/*!***************************************!*\
  !*** ./node_modules/omggif/omggif.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// (c) Dean McNamee <dean@gmail.com>, 2013.\n//\n// https://github.com/deanm/omggif\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n//\n// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,\n// including animation and compression.  It does not rely on any specific\n// underlying system, so should run in the browser, Node, or Plask.\n\nfunction GifWriter(buf, width, height, gopts) {\n    var p = 0;\n    var gopts = gopts === undefined ? {} : gopts;\n    var loop_count = gopts.loop === undefined ? null : gopts.loop;\n    var global_palette = gopts.palette === undefined ? null : gopts.palette;\n    if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw new Error(\"Width/Height invalid.\");\n    function check_palette_and_num_colors(palette) {\n        var num_colors = palette.length;\n        if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {\n            throw new Error(\"Invalid code/color length, must be power of 2 and 2 .. 256.\");\n        }\n        return num_colors;\n    }\n    // - Header.\n    buf[p++] = 0x47;\n    buf[p++] = 0x49;\n    buf[p++] = 0x46; // GIF\n    buf[p++] = 0x38;\n    buf[p++] = 0x39;\n    buf[p++] = 0x61; // 89a\n    // Handling of Global Color Table (palette) and background index.\n    var gp_num_colors_pow2 = 0;\n    var background = 0;\n    if (global_palette !== null) {\n        var gp_num_colors = check_palette_and_num_colors(global_palette);\n        while(gp_num_colors >>= 1)++gp_num_colors_pow2;\n        gp_num_colors = 1 << gp_num_colors_pow2;\n        --gp_num_colors_pow2;\n        if (gopts.background !== undefined) {\n            background = gopts.background;\n            if (background >= gp_num_colors) throw new Error(\"Background index out of range.\");\n            // The GIF spec states that a background index of 0 should be ignored, so\n            // this is probably a mistake and you really want to set it to another\n            // slot in the palette.  But actually in the end most browsers, etc end\n            // up ignoring this almost completely (including for dispose background).\n            if (background === 0) throw new Error(\"Background index explicitly passed as 0.\");\n        }\n    }\n    // - Logical Screen Descriptor.\n    // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.\n    buf[p++] = width & 0xff;\n    buf[p++] = width >> 8 & 0xff;\n    buf[p++] = height & 0xff;\n    buf[p++] = height >> 8 & 0xff;\n    // NOTE: Indicates 0-bpp original color resolution (unused?).\n    buf[p++] = (global_palette !== null ? 0x80 : 0) | // Global Color Table Flag.\n    gp_num_colors_pow2; // NOTE: No sort flag (unused?).\n    buf[p++] = background; // Background Color Index.\n    buf[p++] = 0; // Pixel aspect ratio (unused?).\n    // - Global Color Table\n    if (global_palette !== null) {\n        for(var i = 0, il = global_palette.length; i < il; ++i){\n            var rgb = global_palette[i];\n            buf[p++] = rgb >> 16 & 0xff;\n            buf[p++] = rgb >> 8 & 0xff;\n            buf[p++] = rgb & 0xff;\n        }\n    }\n    if (loop_count !== null) {\n        if (loop_count < 0 || loop_count > 65535) throw new Error(\"Loop count invalid.\");\n        // Extension code, label, and length.\n        buf[p++] = 0x21;\n        buf[p++] = 0xff;\n        buf[p++] = 0x0b;\n        // NETSCAPE2.0\n        buf[p++] = 0x4e;\n        buf[p++] = 0x45;\n        buf[p++] = 0x54;\n        buf[p++] = 0x53;\n        buf[p++] = 0x43;\n        buf[p++] = 0x41;\n        buf[p++] = 0x50;\n        buf[p++] = 0x45;\n        buf[p++] = 0x32;\n        buf[p++] = 0x2e;\n        buf[p++] = 0x30;\n        // Sub-block\n        buf[p++] = 0x03;\n        buf[p++] = 0x01;\n        buf[p++] = loop_count & 0xff;\n        buf[p++] = loop_count >> 8 & 0xff;\n        buf[p++] = 0x00; // Terminator.\n    }\n    var ended = false;\n    this.addFrame = function(x, y, w, h, indexed_pixels, opts) {\n        if (ended === true) {\n            --p;\n            ended = false;\n        } // Un-end.\n        opts = opts === undefined ? {} : opts;\n        // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual\n        // canvas width/height, I imagine?\n        if (x < 0 || y < 0 || x > 65535 || y > 65535) throw new Error(\"x/y invalid.\");\n        if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw new Error(\"Width/Height invalid.\");\n        if (indexed_pixels.length < w * h) throw new Error(\"Not enough pixels for the frame size.\");\n        var using_local_palette = true;\n        var palette = opts.palette;\n        if (palette === undefined || palette === null) {\n            using_local_palette = false;\n            palette = global_palette;\n        }\n        if (palette === undefined || palette === null) throw new Error(\"Must supply either a local or global palette.\");\n        var num_colors = check_palette_and_num_colors(palette);\n        // Compute the min_code_size (power of 2), destroying num_colors.\n        var min_code_size = 0;\n        while(num_colors >>= 1)++min_code_size;\n        num_colors = 1 << min_code_size; // Now we can easily get it back.\n        var delay = opts.delay === undefined ? 0 : opts.delay;\n        // From the spec:\n        //     0 -   No disposal specified. The decoder is\n        //           not required to take any action.\n        //     1 -   Do not dispose. The graphic is to be left\n        //           in place.\n        //     2 -   Restore to background color. The area used by the\n        //           graphic must be restored to the background color.\n        //     3 -   Restore to previous. The decoder is required to\n        //           restore the area overwritten by the graphic with\n        //           what was there prior to rendering the graphic.\n        //  4-7 -    To be defined.\n        // NOTE(deanm): Dispose background doesn't really work, apparently most\n        // browsers ignore the background palette index and clear to transparency.\n        var disposal = opts.disposal === undefined ? 0 : opts.disposal;\n        if (disposal < 0 || disposal > 3) throw new Error(\"Disposal out of range.\");\n        var use_transparency = false;\n        var transparent_index = 0;\n        if (opts.transparent !== undefined && opts.transparent !== null) {\n            use_transparency = true;\n            transparent_index = opts.transparent;\n            if (transparent_index < 0 || transparent_index >= num_colors) throw new Error(\"Transparent color index.\");\n        }\n        if (disposal !== 0 || use_transparency || delay !== 0) {\n            // - Graphics Control Extension\n            buf[p++] = 0x21;\n            buf[p++] = 0xf9; // Extension / Label.\n            buf[p++] = 4; // Byte size.\n            buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);\n            buf[p++] = delay & 0xff;\n            buf[p++] = delay >> 8 & 0xff;\n            buf[p++] = transparent_index; // Transparent color index.\n            buf[p++] = 0; // Block Terminator.\n        }\n        // - Image Descriptor\n        buf[p++] = 0x2c; // Image Seperator.\n        buf[p++] = x & 0xff;\n        buf[p++] = x >> 8 & 0xff; // Left.\n        buf[p++] = y & 0xff;\n        buf[p++] = y >> 8 & 0xff; // Top.\n        buf[p++] = w & 0xff;\n        buf[p++] = w >> 8 & 0xff;\n        buf[p++] = h & 0xff;\n        buf[p++] = h >> 8 & 0xff;\n        // NOTE: No sort flag (unused?).\n        // TODO(deanm): Support interlace.\n        buf[p++] = using_local_palette === true ? 0x80 | min_code_size - 1 : 0;\n        // - Local Color Table\n        if (using_local_palette === true) {\n            for(var i = 0, il = palette.length; i < il; ++i){\n                var rgb = palette[i];\n                buf[p++] = rgb >> 16 & 0xff;\n                buf[p++] = rgb >> 8 & 0xff;\n                buf[p++] = rgb & 0xff;\n            }\n        }\n        p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);\n        return p;\n    };\n    this.end = function() {\n        if (ended === false) {\n            buf[p++] = 0x3b; // Trailer.\n            ended = true;\n        }\n        return p;\n    };\n    this.getOutputBuffer = function() {\n        return buf;\n    };\n    this.setOutputBuffer = function(v) {\n        buf = v;\n    };\n    this.getOutputBufferPosition = function() {\n        return p;\n    };\n    this.setOutputBufferPosition = function(v) {\n        p = v;\n    };\n}\n// Main compression routine, palette indexes -> LZW code stream.\n// |index_stream| must have at least one entry.\nfunction GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {\n    buf[p++] = min_code_size;\n    var cur_subblock = p++; // Pointing at the length field.\n    var clear_code = 1 << min_code_size;\n    var code_mask = clear_code - 1;\n    var eoi_code = clear_code + 1;\n    var next_code = eoi_code + 1;\n    var cur_code_size = min_code_size + 1; // Number of bits per code.\n    var cur_shift = 0;\n    // We have at most 12-bit codes, so we should have to hold a max of 19\n    // bits here (and then we would write out).\n    var cur = 0;\n    function emit_bytes_to_buffer(bit_block_size) {\n        while(cur_shift >= bit_block_size){\n            buf[p++] = cur & 0xff;\n            cur >>= 8;\n            cur_shift -= 8;\n            if (p === cur_subblock + 256) {\n                buf[cur_subblock] = 255;\n                cur_subblock = p++;\n            }\n        }\n    }\n    function emit_code(c) {\n        cur |= c << cur_shift;\n        cur_shift += cur_code_size;\n        emit_bytes_to_buffer(8);\n    }\n    // I am not an expert on the topic, and I don't want to write a thesis.\n    // However, it is good to outline here the basic algorithm and the few data\n    // structures and optimizations here that make this implementation fast.\n    // The basic idea behind LZW is to build a table of previously seen runs\n    // addressed by a short id (herein called output code).  All data is\n    // referenced by a code, which represents one or more values from the\n    // original input stream.  All input bytes can be referenced as the same\n    // value as an output code.  So if you didn't want any compression, you\n    // could more or less just output the original bytes as codes (there are\n    // some details to this, but it is the idea).  In order to achieve\n    // compression, values greater then the input range (codes can be up to\n    // 12-bit while input only 8-bit) represent a sequence of previously seen\n    // inputs.  The decompressor is able to build the same mapping while\n    // decoding, so there is always a shared common knowledge between the\n    // encoding and decoder, which is also important for \"timing\" aspects like\n    // how to handle variable bit width code encoding.\n    //\n    // One obvious but very important consequence of the table system is there\n    // is always a unique id (at most 12-bits) to map the runs.  'A' might be\n    // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship\n    // can be used for an effecient lookup strategy for the code mapping.  We\n    // need to know if a run has been seen before, and be able to map that run\n    // to the output code.  Since we start with known unique ids (input bytes),\n    // and then from those build more unique ids (table entries), we can\n    // continue this chain (almost like a linked list) to always have small\n    // integer values that represent the current byte chains in the encoder.\n    // This means instead of tracking the input bytes (AAAABCD) to know our\n    // current state, we can track the table entry for AAAABC (it is guaranteed\n    // to exist by the nature of the algorithm) and the next character D.\n    // Therefor the tuple of (table_entry, byte) is guaranteed to also be\n    // unique.  This allows us to create a simple lookup key for mapping input\n    // sequences to codes (table indices) without having to store or search\n    // any of the code sequences.  So if 'AAAA' has a table entry of 12, the\n    // tuple of ('AAAA', K) for any input byte K will be unique, and can be our\n    // key.  This leads to a integer value at most 20-bits, which can always\n    // fit in an SMI value and be used as a fast sparse array / object key.\n    // Output code for the current contents of the index buffer.\n    var ib_code = index_stream[0] & code_mask; // Load first input index.\n    var code_table = {}; // Key'd on our 20-bit \"tuple\".\n    emit_code(clear_code); // Spec says first code should be a clear code.\n    // First index already loaded, process the rest of the stream.\n    for(var i = 1, il = index_stream.length; i < il; ++i){\n        var k = index_stream[i] & code_mask;\n        var cur_key = ib_code << 8 | k; // (prev, k) unique tuple.\n        var cur_code = code_table[cur_key]; // buffer + k.\n        // Check if we have to create a new code table entry.\n        if (cur_code === undefined) {\n            // Emit index buffer (without k).\n            // This is an inline version of emit_code, because this is the core\n            // writing routine of the compressor (and V8 cannot inline emit_code\n            // because it is a closure here in a different context).  Additionally\n            // we can call emit_byte_to_buffer less often, because we can have\n            // 30-bits (from our 31-bit signed SMI), and we know our codes will only\n            // be 12-bits, so can safely have 18-bits there without overflow.\n            // emit_code(ib_code);\n            cur |= ib_code << cur_shift;\n            cur_shift += cur_code_size;\n            while(cur_shift >= 8){\n                buf[p++] = cur & 0xff;\n                cur >>= 8;\n                cur_shift -= 8;\n                if (p === cur_subblock + 256) {\n                    buf[cur_subblock] = 255;\n                    cur_subblock = p++;\n                }\n            }\n            if (next_code === 4096) {\n                emit_code(clear_code);\n                next_code = eoi_code + 1;\n                cur_code_size = min_code_size + 1;\n                code_table = {};\n            } else {\n                // Increase our variable bit code sizes if necessary.  This is a bit\n                // tricky as it is based on \"timing\" between the encoding and\n                // decoder.  From the encoders perspective this should happen after\n                // we've already emitted the index buffer and are about to create the\n                // first table entry that would overflow our current code bit size.\n                if (next_code >= 1 << cur_code_size) ++cur_code_size;\n                code_table[cur_key] = next_code++; // Insert into code table.\n            }\n            ib_code = k; // Index buffer to single input k.\n        } else {\n            ib_code = cur_code; // Index buffer to sequence in code table.\n        }\n    }\n    emit_code(ib_code); // There will still be something in the index buffer.\n    emit_code(eoi_code); // End Of Information.\n    // Flush / finalize the sub-blocks stream to the buffer.\n    emit_bytes_to_buffer(1);\n    // Finish the sub-blocks, writing out any unfinished lengths and\n    // terminating with a sub-block of length 0.  If we have already started\n    // but not yet used a sub-block it can just become the terminator.\n    if (cur_subblock + 1 === p) {\n        buf[cur_subblock] = 0;\n    } else {\n        buf[cur_subblock] = p - cur_subblock - 1;\n        buf[p++] = 0;\n    }\n    return p;\n}\nfunction GifReader(buf) {\n    var p = 0;\n    // - Header (GIF87a or GIF89a).\n    if (buf[p++] !== 0x47 || buf[p++] !== 0x49 || buf[p++] !== 0x46 || buf[p++] !== 0x38 || (buf[p++] + 1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {\n        throw new Error(\"Invalid GIF 87a/89a header.\");\n    }\n    // - Logical Screen Descriptor.\n    var width = buf[p++] | buf[p++] << 8;\n    var height = buf[p++] | buf[p++] << 8;\n    var pf0 = buf[p++]; // <Packed Fields>.\n    var global_palette_flag = pf0 >> 7;\n    var num_global_colors_pow2 = pf0 & 0x7;\n    var num_global_colors = 1 << num_global_colors_pow2 + 1;\n    var background = buf[p++];\n    buf[p++]; // Pixel aspect ratio (unused?).\n    var global_palette_offset = null;\n    var global_palette_size = null;\n    if (global_palette_flag) {\n        global_palette_offset = p;\n        global_palette_size = num_global_colors;\n        p += num_global_colors * 3; // Seek past palette.\n    }\n    var no_eof = true;\n    var frames = [];\n    var delay = 0;\n    var transparent_index = null;\n    var disposal = 0; // 0 - No disposal specified.\n    var loop_count = null;\n    this.width = width;\n    this.height = height;\n    while(no_eof && p < buf.length){\n        switch(buf[p++]){\n            case 0x21:\n                switch(buf[p++]){\n                    case 0xff:\n                        // Try if it's a Netscape block (with animation loop counter).\n                        if (buf[p] !== 0x0b || // 21 FF already read, check block size.\n                        // NETSCAPE2.0\n                        buf[p + 1] == 0x4e && buf[p + 2] == 0x45 && buf[p + 3] == 0x54 && buf[p + 4] == 0x53 && buf[p + 5] == 0x43 && buf[p + 6] == 0x41 && buf[p + 7] == 0x50 && buf[p + 8] == 0x45 && buf[p + 9] == 0x32 && buf[p + 10] == 0x2e && buf[p + 11] == 0x30 && // Sub-block\n                        buf[p + 12] == 0x03 && buf[p + 13] == 0x01 && buf[p + 16] == 0) {\n                            p += 14;\n                            loop_count = buf[p++] | buf[p++] << 8;\n                            p++; // Skip terminator.\n                        } else {\n                            p += 12;\n                            while(true){\n                                var block_size = buf[p++];\n                                // Bad block size (ex: undefined from an out of bounds read).\n                                if (!(block_size >= 0)) throw Error(\"Invalid block size\");\n                                if (block_size === 0) break; // 0 size is terminator\n                                p += block_size;\n                            }\n                        }\n                        break;\n                    case 0xf9:\n                        if (buf[p++] !== 0x4 || buf[p + 4] !== 0) throw new Error(\"Invalid graphics extension block.\");\n                        var pf1 = buf[p++];\n                        delay = buf[p++] | buf[p++] << 8;\n                        transparent_index = buf[p++];\n                        if ((pf1 & 1) === 0) transparent_index = null;\n                        disposal = pf1 >> 2 & 0x7;\n                        p++; // Skip terminator.\n                        break;\n                    case 0xfe:\n                        while(true){\n                            var block_size = buf[p++];\n                            // Bad block size (ex: undefined from an out of bounds read).\n                            if (!(block_size >= 0)) throw Error(\"Invalid block size\");\n                            if (block_size === 0) break; // 0 size is terminator\n                            // console.log(buf.slice(p, p+block_size).toString('ascii'));\n                            p += block_size;\n                        }\n                        break;\n                    default:\n                        throw new Error(\"Unknown graphic control label: 0x\" + buf[p - 1].toString(16));\n                }\n                break;\n            case 0x2c:\n                var x = buf[p++] | buf[p++] << 8;\n                var y = buf[p++] | buf[p++] << 8;\n                var w = buf[p++] | buf[p++] << 8;\n                var h = buf[p++] | buf[p++] << 8;\n                var pf2 = buf[p++];\n                var local_palette_flag = pf2 >> 7;\n                var interlace_flag = pf2 >> 6 & 1;\n                var num_local_colors_pow2 = pf2 & 0x7;\n                var num_local_colors = 1 << num_local_colors_pow2 + 1;\n                var palette_offset = global_palette_offset;\n                var palette_size = global_palette_size;\n                var has_local_palette = false;\n                if (local_palette_flag) {\n                    var has_local_palette = true;\n                    palette_offset = p; // Override with local palette.\n                    palette_size = num_local_colors;\n                    p += num_local_colors * 3; // Seek past palette.\n                }\n                var data_offset = p;\n                p++; // codesize\n                while(true){\n                    var block_size = buf[p++];\n                    // Bad block size (ex: undefined from an out of bounds read).\n                    if (!(block_size >= 0)) throw Error(\"Invalid block size\");\n                    if (block_size === 0) break; // 0 size is terminator\n                    p += block_size;\n                }\n                frames.push({\n                    x: x,\n                    y: y,\n                    width: w,\n                    height: h,\n                    has_local_palette: has_local_palette,\n                    palette_offset: palette_offset,\n                    palette_size: palette_size,\n                    data_offset: data_offset,\n                    data_length: p - data_offset,\n                    transparent_index: transparent_index,\n                    interlaced: !!interlace_flag,\n                    delay: delay,\n                    disposal: disposal\n                });\n                break;\n            case 0x3b:\n                no_eof = false;\n                break;\n            default:\n                throw new Error(\"Unknown gif block: 0x\" + buf[p - 1].toString(16));\n                break;\n        }\n    }\n    this.numFrames = function() {\n        return frames.length;\n    };\n    this.loopCount = function() {\n        return loop_count;\n    };\n    this.frameInfo = function(frame_num) {\n        if (frame_num < 0 || frame_num >= frames.length) throw new Error(\"Frame index out of range.\");\n        return frames[frame_num];\n    };\n    this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {\n        var frame = this.frameInfo(frame_num);\n        var num_pixels = frame.width * frame.height;\n        var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.\n        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);\n        var palette_offset = frame.palette_offset;\n        // NOTE(deanm): It seems to be much faster to compare index to 256 than\n        // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n        // the profile, not sure if it's related to using a Uint8Array.\n        var trans = frame.transparent_index;\n        if (trans === null) trans = 256;\n        // We are possibly just blitting to a portion of the entire frame.\n        // That is a subrect within the framerect, so the additional pixels\n        // must be skipped over after we finished a scanline.\n        var framewidth = frame.width;\n        var framestride = width - framewidth;\n        var xleft = framewidth; // Number of subrect pixels left in scanline.\n        // Output indicies of the top left and bottom right corners of the subrect.\n        var opbeg = (frame.y * width + frame.x) * 4;\n        var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n        var op = opbeg;\n        var scanstride = framestride * 4;\n        // Use scanstride to skip past the rows when interlacing.  This is skipping\n        // 7 rows for the first two passes, then 3 then 1.\n        if (frame.interlaced === true) {\n            scanstride += width * 4 * 7; // Pass 1.\n        }\n        var interlaceskip = 8; // Tracking the row interval in the current pass.\n        for(var i = 0, il = index_stream.length; i < il; ++i){\n            var index = index_stream[i];\n            if (xleft === 0) {\n                op += scanstride;\n                xleft = framewidth;\n                if (op >= opend) {\n                    scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);\n                    // interlaceskip / 2 * 4 is interlaceskip << 1.\n                    op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n                    interlaceskip >>= 1;\n                }\n            }\n            if (index === trans) {\n                op += 4;\n            } else {\n                var r = buf[palette_offset + index * 3];\n                var g = buf[palette_offset + index * 3 + 1];\n                var b = buf[palette_offset + index * 3 + 2];\n                pixels[op++] = b;\n                pixels[op++] = g;\n                pixels[op++] = r;\n                pixels[op++] = 255;\n            }\n            --xleft;\n        }\n    };\n    // I will go to copy and paste hell one day...\n    this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {\n        var frame = this.frameInfo(frame_num);\n        var num_pixels = frame.width * frame.height;\n        var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.\n        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);\n        var palette_offset = frame.palette_offset;\n        // NOTE(deanm): It seems to be much faster to compare index to 256 than\n        // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n        // the profile, not sure if it's related to using a Uint8Array.\n        var trans = frame.transparent_index;\n        if (trans === null) trans = 256;\n        // We are possibly just blitting to a portion of the entire frame.\n        // That is a subrect within the framerect, so the additional pixels\n        // must be skipped over after we finished a scanline.\n        var framewidth = frame.width;\n        var framestride = width - framewidth;\n        var xleft = framewidth; // Number of subrect pixels left in scanline.\n        // Output indicies of the top left and bottom right corners of the subrect.\n        var opbeg = (frame.y * width + frame.x) * 4;\n        var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n        var op = opbeg;\n        var scanstride = framestride * 4;\n        // Use scanstride to skip past the rows when interlacing.  This is skipping\n        // 7 rows for the first two passes, then 3 then 1.\n        if (frame.interlaced === true) {\n            scanstride += width * 4 * 7; // Pass 1.\n        }\n        var interlaceskip = 8; // Tracking the row interval in the current pass.\n        for(var i = 0, il = index_stream.length; i < il; ++i){\n            var index = index_stream[i];\n            if (xleft === 0) {\n                op += scanstride;\n                xleft = framewidth;\n                if (op >= opend) {\n                    scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);\n                    // interlaceskip / 2 * 4 is interlaceskip << 1.\n                    op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n                    interlaceskip >>= 1;\n                }\n            }\n            if (index === trans) {\n                op += 4;\n            } else {\n                var r = buf[palette_offset + index * 3];\n                var g = buf[palette_offset + index * 3 + 1];\n                var b = buf[palette_offset + index * 3 + 2];\n                pixels[op++] = r;\n                pixels[op++] = g;\n                pixels[op++] = b;\n                pixels[op++] = 255;\n            }\n            --xleft;\n        }\n    };\n}\nfunction GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {\n    var min_code_size = code_stream[p++];\n    var clear_code = 1 << min_code_size;\n    var eoi_code = clear_code + 1;\n    var next_code = eoi_code + 1;\n    var cur_code_size = min_code_size + 1; // Number of bits per code.\n    // NOTE: This shares the same name as the encoder, but has a different\n    // meaning here.  Here this masks each code coming from the code stream.\n    var code_mask = (1 << cur_code_size) - 1;\n    var cur_shift = 0;\n    var cur = 0;\n    var op = 0; // Output pointer.\n    var subblock_size = code_stream[p++];\n    // TODO(deanm): Would using a TypedArray be any faster?  At least it would\n    // solve the fast mode / backing store uncertainty.\n    // var code_table = Array(4096);\n    var code_table = new Int32Array(4096); // Can be signed, we only use 20 bits.\n    var prev_code = null; // Track code-1.\n    while(true){\n        // Read up to two bytes, making sure we always 12-bits for max sized code.\n        while(cur_shift < 16){\n            if (subblock_size === 0) break; // No more data to be read.\n            cur |= code_stream[p++] << cur_shift;\n            cur_shift += 8;\n            if (subblock_size === 1) {\n                subblock_size = code_stream[p++]; // Next subblock.\n            } else {\n                --subblock_size;\n            }\n        }\n        // TODO(deanm): We should never really get here, we should have received\n        // and EOI.\n        if (cur_shift < cur_code_size) break;\n        var code = cur & code_mask;\n        cur >>= cur_code_size;\n        cur_shift -= cur_code_size;\n        // TODO(deanm): Maybe should check that the first code was a clear code,\n        // at least this is what you're supposed to do.  But actually our encoder\n        // now doesn't emit a clear code first anyway.\n        if (code === clear_code) {\n            // We don't actually have to clear the table.  This could be a good idea\n            // for greater error checking, but we don't really do any anyway.  We\n            // will just track it with next_code and overwrite old entries.\n            next_code = eoi_code + 1;\n            cur_code_size = min_code_size + 1;\n            code_mask = (1 << cur_code_size) - 1;\n            // Don't update prev_code ?\n            prev_code = null;\n            continue;\n        } else if (code === eoi_code) {\n            break;\n        }\n        // We have a similar situation as the decoder, where we want to store\n        // variable length entries (code table entries), but we want to do in a\n        // faster manner than an array of arrays.  The code below stores sort of a\n        // linked list within the code table, and then \"chases\" through it to\n        // construct the dictionary entries.  When a new entry is created, just the\n        // last byte is stored, and the rest (prefix) of the entry is only\n        // referenced by its table entry.  Then the code chases through the\n        // prefixes until it reaches a single byte code.  We have to chase twice,\n        // first to compute the length, and then to actually copy the data to the\n        // output (backwards, since we know the length).  The alternative would be\n        // storing something in an intermediate stack, but that doesn't make any\n        // more sense.  I implemented an approach where it also stored the length\n        // in the code table, although it's a bit tricky because you run out of\n        // bits (12 + 12 + 8), but I didn't measure much improvements (the table\n        // entries are generally not the long).  Even when I created benchmarks for\n        // very long table entries the complexity did not seem worth it.\n        // The code table stores the prefix entry in 12 bits and then the suffix\n        // byte in 8 bits, so each entry is 20 bits.\n        var chase_code = code < next_code ? code : prev_code;\n        // Chase what we will output, either {CODE} or {CODE-1}.\n        var chase_length = 0;\n        var chase = chase_code;\n        while(chase > clear_code){\n            chase = code_table[chase] >> 8;\n            ++chase_length;\n        }\n        var k = chase;\n        var op_end = op + chase_length + (chase_code !== code ? 1 : 0);\n        if (op_end > output_length) {\n            console.log(\"Warning, gif stream longer than expected.\");\n            return;\n        }\n        // Already have the first byte from the chase, might as well write it fast.\n        output[op++] = k;\n        op += chase_length;\n        var b = op; // Track pointer, writing backwards.\n        if (chase_code !== code) output[op++] = k;\n        chase = chase_code;\n        while(chase_length--){\n            chase = code_table[chase];\n            output[--b] = chase & 0xff; // Write backwards.\n            chase >>= 8; // Pull down to the prefix code.\n        }\n        if (prev_code !== null && next_code < 4096) {\n            code_table[next_code++] = prev_code << 8 | k;\n            // TODO(deanm): Figure out this clearing vs code growth logic better.  I\n            // have an feeling that it should just happen somewhere else, for now it\n            // is awkward between when we grow past the max and then hit a clear code.\n            // For now just check if we hit the max 12-bits (then a clear code should\n            // follow, also of course encoded in 12-bits).\n            if (next_code >= code_mask + 1 && cur_code_size < 12) {\n                ++cur_code_size;\n                code_mask = code_mask << 1 | 1;\n            }\n        }\n        prev_code = code;\n    }\n    if (op !== output_length) {\n        console.log(\"Warning, gif stream shorter than expected.\");\n    }\n    return output;\n}\n// CommonJS.\ntry {\n    exports.GifWriter = GifWriter;\n    exports.GifReader = GifReader;\n} catch (e) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb21nZ2lmL29tZ2dpZi5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyQ0FBMkM7QUFDM0MsRUFBRTtBQUNGLGtDQUFrQztBQUNsQyxFQUFFO0FBQ0YsK0VBQStFO0FBQy9FLDJFQUEyRTtBQUMzRSw2RUFBNkU7QUFDN0UsOEVBQThFO0FBQzlFLDZFQUE2RTtBQUM3RSwyREFBMkQ7QUFDM0QsRUFBRTtBQUNGLDZFQUE2RTtBQUM3RSxzREFBc0Q7QUFDdEQsRUFBRTtBQUNGLDZFQUE2RTtBQUM3RSwyRUFBMkU7QUFDM0UsOEVBQThFO0FBQzlFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUsK0VBQStFO0FBQy9FLG1CQUFtQjtBQUNuQixFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSxtRUFBbUU7QUFFdEQ7QUFFYixTQUFTQSxVQUFVQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxLQUFLO0lBQzFDLElBQUlDLElBQUk7SUFFUixJQUFJRCxRQUFRQSxVQUFVRSxZQUFZLENBQUUsSUFBSUY7SUFDeEMsSUFBSUcsYUFBYUgsTUFBTUksSUFBSSxLQUFLRixZQUFZLE9BQU9GLE1BQU1JLElBQUk7SUFDN0QsSUFBSUMsaUJBQWlCTCxNQUFNTSxPQUFPLEtBQUtKLFlBQVksT0FBT0YsTUFBTU0sT0FBTztJQUV2RSxJQUFJUixTQUFTLEtBQUtDLFVBQVUsS0FBS0QsUUFBUSxTQUFTQyxTQUFTLE9BQ3pELE1BQU0sSUFBSVEsTUFBTTtJQUVsQixTQUFTQyw2QkFBNkJGLE9BQU87UUFDM0MsSUFBSUcsYUFBYUgsUUFBUUksTUFBTTtRQUMvQixJQUFJRCxhQUFhLEtBQUtBLGFBQWEsT0FBUUEsYUFBY0EsYUFBVyxHQUFJO1lBQ3RFLE1BQU0sSUFBSUYsTUFDTjtRQUNOO1FBQ0EsT0FBT0U7SUFDVDtJQUVBLFlBQVk7SUFDWlosR0FBRyxDQUFDSSxJQUFJLEdBQUc7SUFBTUosR0FBRyxDQUFDSSxJQUFJLEdBQUc7SUFB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Zi5qcz9mZWNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIChjKSBEZWFuIE1jTmFtZWUgPGRlYW5AZ21haWwuY29tPiwgMjAxMy5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vb21nZ2lmXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Ncbi8vIElOIFRIRSBTT0ZUV0FSRS5cbi8vXG4vLyBvbWdnaWYgaXMgYSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIGEgR0lGIDg5YSBlbmNvZGVyIGFuZCBkZWNvZGVyLFxuLy8gaW5jbHVkaW5nIGFuaW1hdGlvbiBhbmQgY29tcHJlc3Npb24uICBJdCBkb2VzIG5vdCByZWx5IG9uIGFueSBzcGVjaWZpY1xuLy8gdW5kZXJseWluZyBzeXN0ZW0sIHNvIHNob3VsZCBydW4gaW4gdGhlIGJyb3dzZXIsIE5vZGUsIG9yIFBsYXNrLlxuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gR2lmV3JpdGVyKGJ1Ziwgd2lkdGgsIGhlaWdodCwgZ29wdHMpIHtcbiAgdmFyIHAgPSAwO1xuXG4gIHZhciBnb3B0cyA9IGdvcHRzID09PSB1bmRlZmluZWQgPyB7IH0gOiBnb3B0cztcbiAgdmFyIGxvb3BfY291bnQgPSBnb3B0cy5sb29wID09PSB1bmRlZmluZWQgPyBudWxsIDogZ29wdHMubG9vcDtcbiAgdmFyIGdsb2JhbF9wYWxldHRlID0gZ29wdHMucGFsZXR0ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdvcHRzLnBhbGV0dGU7XG5cbiAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDAgfHwgd2lkdGggPiA2NTUzNSB8fCBoZWlnaHQgPiA2NTUzNSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aC9IZWlnaHQgaW52YWxpZC5cIik7XG5cbiAgZnVuY3Rpb24gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhwYWxldHRlKSB7XG4gICAgdmFyIG51bV9jb2xvcnMgPSBwYWxldHRlLmxlbmd0aDtcbiAgICBpZiAobnVtX2NvbG9ycyA8IDIgfHwgbnVtX2NvbG9ycyA+IDI1NiB8fCAgbnVtX2NvbG9ycyAmIChudW1fY29sb3JzLTEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGNvZGUvY29sb3IgbGVuZ3RoLCBtdXN0IGJlIHBvd2VyIG9mIDIgYW5kIDIgLi4gMjU2LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bV9jb2xvcnM7XG4gIH1cblxuICAvLyAtIEhlYWRlci5cbiAgYnVmW3ArK10gPSAweDQ3OyBidWZbcCsrXSA9IDB4NDk7IGJ1ZltwKytdID0gMHg0NjsgIC8vIEdJRlxuICBidWZbcCsrXSA9IDB4Mzg7IGJ1ZltwKytdID0gMHgzOTsgYnVmW3ArK10gPSAweDYxOyAgLy8gODlhXG5cbiAgLy8gSGFuZGxpbmcgb2YgR2xvYmFsIENvbG9yIFRhYmxlIChwYWxldHRlKSBhbmQgYmFja2dyb3VuZCBpbmRleC5cbiAgdmFyIGdwX251bV9jb2xvcnNfcG93MiA9IDA7XG4gIHZhciBiYWNrZ3JvdW5kID0gMDtcbiAgaWYgKGdsb2JhbF9wYWxldHRlICE9PSBudWxsKSB7XG4gICAgdmFyIGdwX251bV9jb2xvcnMgPSBjaGVja19wYWxldHRlX2FuZF9udW1fY29sb3JzKGdsb2JhbF9wYWxldHRlKTtcbiAgICB3aGlsZSAoZ3BfbnVtX2NvbG9ycyA+Pj0gMSkgKytncF9udW1fY29sb3JzX3BvdzI7XG4gICAgZ3BfbnVtX2NvbG9ycyA9IDEgPDwgZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIC0tZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIGlmIChnb3B0cy5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJhY2tncm91bmQgPSBnb3B0cy5iYWNrZ3JvdW5kO1xuICAgICAgaWYgKGJhY2tncm91bmQgPj0gZ3BfbnVtX2NvbG9ycylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja2dyb3VuZCBpbmRleCBvdXQgb2YgcmFuZ2UuXCIpO1xuICAgICAgLy8gVGhlIEdJRiBzcGVjIHN0YXRlcyB0aGF0IGEgYmFja2dyb3VuZCBpbmRleCBvZiAwIHNob3VsZCBiZSBpZ25vcmVkLCBzb1xuICAgICAgLy8gdGhpcyBpcyBwcm9iYWJseSBhIG1pc3Rha2UgYW5kIHlvdSByZWFsbHkgd2FudCB0byBzZXQgaXQgdG8gYW5vdGhlclxuICAgICAgLy8gc2xvdCBpbiB0aGUgcGFsZXR0ZS4gIEJ1dCBhY3R1YWxseSBpbiB0aGUgZW5kIG1vc3QgYnJvd3NlcnMsIGV0YyBlbmRcbiAgICAgIC8vIHVwIGlnbm9yaW5nIHRoaXMgYWxtb3N0IGNvbXBsZXRlbHkgKGluY2x1ZGluZyBmb3IgZGlzcG9zZSBiYWNrZ3JvdW5kKS5cbiAgICAgIGlmIChiYWNrZ3JvdW5kID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZ3JvdW5kIGluZGV4IGV4cGxpY2l0bHkgcGFzc2VkIGFzIDAuXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIC0gTG9naWNhbCBTY3JlZW4gRGVzY3JpcHRvci5cbiAgLy8gTk9URShkZWFubSk6IHcvaCBhcHBhcmVudGx5IGlnbm9yZWQgYnkgaW1wbGVtZW50YXRpb25zLCBidXQgc2V0IGFueXdheS5cbiAgYnVmW3ArK10gPSB3aWR0aCAmIDB4ZmY7IGJ1ZltwKytdID0gd2lkdGggPj4gOCAmIDB4ZmY7XG4gIGJ1ZltwKytdID0gaGVpZ2h0ICYgMHhmZjsgYnVmW3ArK10gPSBoZWlnaHQgPj4gOCAmIDB4ZmY7XG4gIC8vIE5PVEU6IEluZGljYXRlcyAwLWJwcCBvcmlnaW5hbCBjb2xvciByZXNvbHV0aW9uICh1bnVzZWQ/KS5cbiAgYnVmW3ArK10gPSAoZ2xvYmFsX3BhbGV0dGUgIT09IG51bGwgPyAweDgwIDogMCkgfCAgLy8gR2xvYmFsIENvbG9yIFRhYmxlIEZsYWcuXG4gICAgICAgICAgICAgZ3BfbnVtX2NvbG9yc19wb3cyOyAgLy8gTk9URTogTm8gc29ydCBmbGFnICh1bnVzZWQ/KS5cbiAgYnVmW3ArK10gPSBiYWNrZ3JvdW5kOyAgLy8gQmFja2dyb3VuZCBDb2xvciBJbmRleC5cbiAgYnVmW3ArK10gPSAwOyAgLy8gUGl4ZWwgYXNwZWN0IHJhdGlvICh1bnVzZWQ/KS5cblxuICAvLyAtIEdsb2JhbCBDb2xvciBUYWJsZVxuICBpZiAoZ2xvYmFsX3BhbGV0dGUgIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBnbG9iYWxfcGFsZXR0ZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICB2YXIgcmdiID0gZ2xvYmFsX3BhbGV0dGVbaV07XG4gICAgICBidWZbcCsrXSA9IHJnYiA+PiAxNiAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHJnYiA+PiA4ICYgMHhmZjtcbiAgICAgIGJ1ZltwKytdID0gcmdiICYgMHhmZjtcbiAgICB9XG4gIH1cblxuICBpZiAobG9vcF9jb3VudCAhPT0gbnVsbCkgeyAgLy8gTmV0c2NhcGUgYmxvY2sgZm9yIGxvb3BpbmcuXG4gICAgaWYgKGxvb3BfY291bnQgPCAwIHx8IGxvb3BfY291bnQgPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvb3AgY291bnQgaW52YWxpZC5cIilcbiAgICAvLyBFeHRlbnNpb24gY29kZSwgbGFiZWwsIGFuZCBsZW5ndGguXG4gICAgYnVmW3ArK10gPSAweDIxOyBidWZbcCsrXSA9IDB4ZmY7IGJ1ZltwKytdID0gMHgwYjtcbiAgICAvLyBORVRTQ0FQRTIuMFxuICAgIGJ1ZltwKytdID0gMHg0ZTsgYnVmW3ArK10gPSAweDQ1OyBidWZbcCsrXSA9IDB4NTQ7IGJ1ZltwKytdID0gMHg1MztcbiAgICBidWZbcCsrXSA9IDB4NDM7IGJ1ZltwKytdID0gMHg0MTsgYnVmW3ArK10gPSAweDUwOyBidWZbcCsrXSA9IDB4NDU7XG4gICAgYnVmW3ArK10gPSAweDMyOyBidWZbcCsrXSA9IDB4MmU7IGJ1ZltwKytdID0gMHgzMDtcbiAgICAvLyBTdWItYmxvY2tcbiAgICBidWZbcCsrXSA9IDB4MDM7IGJ1ZltwKytdID0gMHgwMTtcbiAgICBidWZbcCsrXSA9IGxvb3BfY291bnQgJiAweGZmOyBidWZbcCsrXSA9IGxvb3BfY291bnQgPj4gOCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSAweDAwOyAgLy8gVGVybWluYXRvci5cbiAgfVxuXG5cbiAgdmFyIGVuZGVkID0gZmFsc2U7XG5cbiAgdGhpcy5hZGRGcmFtZSA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIGluZGV4ZWRfcGl4ZWxzLCBvcHRzKSB7XG4gICAgaWYgKGVuZGVkID09PSB0cnVlKSB7IC0tcDsgZW5kZWQgPSBmYWxzZTsgfSAgLy8gVW4tZW5kLlxuXG4gICAgb3B0cyA9IG9wdHMgPT09IHVuZGVmaW5lZCA/IHsgfSA6IG9wdHM7XG5cbiAgICAvLyBUT0RPKGRlYW5tKTogQm91bmRzIGNoZWNrIHgsIHkuICBEbyB0aGV5IG5lZWQgdG8gYmUgd2l0aGluIHRoZSB2aXJ0dWFsXG4gICAgLy8gY2FudmFzIHdpZHRoL2hlaWdodCwgSSBpbWFnaW5lP1xuICAgIGlmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID4gNjU1MzUgfHwgeSA+IDY1NTM1KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwieC95IGludmFsaWQuXCIpXG5cbiAgICBpZiAodyA8PSAwIHx8IGggPD0gMCB8fCB3ID4gNjU1MzUgfHwgaCA+IDY1NTM1KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCIpXG5cbiAgICBpZiAoaW5kZXhlZF9waXhlbHMubGVuZ3RoIDwgdyAqIGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZW5vdWdoIHBpeGVscyBmb3IgdGhlIGZyYW1lIHNpemUuXCIpO1xuXG4gICAgdmFyIHVzaW5nX2xvY2FsX3BhbGV0dGUgPSB0cnVlO1xuICAgIHZhciBwYWxldHRlID0gb3B0cy5wYWxldHRlO1xuICAgIGlmIChwYWxldHRlID09PSB1bmRlZmluZWQgfHwgcGFsZXR0ZSA9PT0gbnVsbCkge1xuICAgICAgdXNpbmdfbG9jYWxfcGFsZXR0ZSA9IGZhbHNlO1xuICAgICAgcGFsZXR0ZSA9IGdsb2JhbF9wYWxldHRlO1xuICAgIH1cblxuICAgIGlmIChwYWxldHRlID09PSB1bmRlZmluZWQgfHwgcGFsZXR0ZSA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3VwcGx5IGVpdGhlciBhIGxvY2FsIG9yIGdsb2JhbCBwYWxldHRlLlwiKTtcblxuICAgIHZhciBudW1fY29sb3JzID0gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhwYWxldHRlKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1pbl9jb2RlX3NpemUgKHBvd2VyIG9mIDIpLCBkZXN0cm95aW5nIG51bV9jb2xvcnMuXG4gICAgdmFyIG1pbl9jb2RlX3NpemUgPSAwO1xuICAgIHdoaWxlIChudW1fY29sb3JzID4+PSAxKSArK21pbl9jb2RlX3NpemU7XG4gICAgbnVtX2NvbG9ycyA9IDEgPDwgbWluX2NvZGVfc2l6ZTsgIC8vIE5vdyB3ZSBjYW4gZWFzaWx5IGdldCBpdCBiYWNrLlxuXG4gICAgdmFyIGRlbGF5ID0gb3B0cy5kZWxheSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdHMuZGVsYXk7XG5cbiAgICAvLyBGcm9tIHRoZSBzcGVjOlxuICAgIC8vICAgICAwIC0gICBObyBkaXNwb3NhbCBzcGVjaWZpZWQuIFRoZSBkZWNvZGVyIGlzXG4gICAgLy8gICAgICAgICAgIG5vdCByZXF1aXJlZCB0byB0YWtlIGFueSBhY3Rpb24uXG4gICAgLy8gICAgIDEgLSAgIERvIG5vdCBkaXNwb3NlLiBUaGUgZ3JhcGhpYyBpcyB0byBiZSBsZWZ0XG4gICAgLy8gICAgICAgICAgIGluIHBsYWNlLlxuICAgIC8vICAgICAyIC0gICBSZXN0b3JlIHRvIGJhY2tncm91bmQgY29sb3IuIFRoZSBhcmVhIHVzZWQgYnkgdGhlXG4gICAgLy8gICAgICAgICAgIGdyYXBoaWMgbXVzdCBiZSByZXN0b3JlZCB0byB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICAvLyAgICAgMyAtICAgUmVzdG9yZSB0byBwcmV2aW91cy4gVGhlIGRlY29kZXIgaXMgcmVxdWlyZWQgdG9cbiAgICAvLyAgICAgICAgICAgcmVzdG9yZSB0aGUgYXJlYSBvdmVyd3JpdHRlbiBieSB0aGUgZ3JhcGhpYyB3aXRoXG4gICAgLy8gICAgICAgICAgIHdoYXQgd2FzIHRoZXJlIHByaW9yIHRvIHJlbmRlcmluZyB0aGUgZ3JhcGhpYy5cbiAgICAvLyAgNC03IC0gICAgVG8gYmUgZGVmaW5lZC5cbiAgICAvLyBOT1RFKGRlYW5tKTogRGlzcG9zZSBiYWNrZ3JvdW5kIGRvZXNuJ3QgcmVhbGx5IHdvcmssIGFwcGFyZW50bHkgbW9zdFxuICAgIC8vIGJyb3dzZXJzIGlnbm9yZSB0aGUgYmFja2dyb3VuZCBwYWxldHRlIGluZGV4IGFuZCBjbGVhciB0byB0cmFuc3BhcmVuY3kuXG4gICAgdmFyIGRpc3Bvc2FsID0gb3B0cy5kaXNwb3NhbCA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdHMuZGlzcG9zYWw7XG4gICAgaWYgKGRpc3Bvc2FsIDwgMCB8fCBkaXNwb3NhbCA+IDMpICAvLyA0LTcgaXMgcmVzZXJ2ZWQuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNwb3NhbCBvdXQgb2YgcmFuZ2UuXCIpO1xuXG4gICAgdmFyIHVzZV90cmFuc3BhcmVuY3kgPSBmYWxzZTtcbiAgICB2YXIgdHJhbnNwYXJlbnRfaW5kZXggPSAwO1xuICAgIGlmIChvcHRzLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgJiYgb3B0cy50cmFuc3BhcmVudCAhPT0gbnVsbCkge1xuICAgICAgdXNlX3RyYW5zcGFyZW5jeSA9IHRydWU7XG4gICAgICB0cmFuc3BhcmVudF9pbmRleCA9IG9wdHMudHJhbnNwYXJlbnQ7XG4gICAgICBpZiAodHJhbnNwYXJlbnRfaW5kZXggPCAwIHx8IHRyYW5zcGFyZW50X2luZGV4ID49IG51bV9jb2xvcnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcGFyZW50IGNvbG9yIGluZGV4LlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZGlzcG9zYWwgIT09IDAgfHwgdXNlX3RyYW5zcGFyZW5jeSB8fCBkZWxheSAhPT0gMCkge1xuICAgICAgLy8gLSBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvblxuICAgICAgYnVmW3ArK10gPSAweDIxOyBidWZbcCsrXSA9IDB4Zjk7ICAvLyBFeHRlbnNpb24gLyBMYWJlbC5cbiAgICAgIGJ1ZltwKytdID0gNDsgIC8vIEJ5dGUgc2l6ZS5cblxuICAgICAgYnVmW3ArK10gPSBkaXNwb3NhbCA8PCAyIHwgKHVzZV90cmFuc3BhcmVuY3kgPT09IHRydWUgPyAxIDogMCk7XG4gICAgICBidWZbcCsrXSA9IGRlbGF5ICYgMHhmZjsgYnVmW3ArK10gPSBkZWxheSA+PiA4ICYgMHhmZjtcbiAgICAgIGJ1ZltwKytdID0gdHJhbnNwYXJlbnRfaW5kZXg7ICAvLyBUcmFuc3BhcmVudCBjb2xvciBpbmRleC5cbiAgICAgIGJ1ZltwKytdID0gMDsgIC8vIEJsb2NrIFRlcm1pbmF0b3IuXG4gICAgfVxuXG4gICAgLy8gLSBJbWFnZSBEZXNjcmlwdG9yXG4gICAgYnVmW3ArK10gPSAweDJjOyAgLy8gSW1hZ2UgU2VwZXJhdG9yLlxuICAgIGJ1ZltwKytdID0geCAmIDB4ZmY7IGJ1ZltwKytdID0geCA+PiA4ICYgMHhmZjsgIC8vIExlZnQuXG4gICAgYnVmW3ArK10gPSB5ICYgMHhmZjsgYnVmW3ArK10gPSB5ID4+IDggJiAweGZmOyAgLy8gVG9wLlxuICAgIGJ1ZltwKytdID0gdyAmIDB4ZmY7IGJ1ZltwKytdID0gdyA+PiA4ICYgMHhmZjtcbiAgICBidWZbcCsrXSA9IGggJiAweGZmOyBidWZbcCsrXSA9IGggPj4gOCAmIDB4ZmY7XG4gICAgLy8gTk9URTogTm8gc29ydCBmbGFnICh1bnVzZWQ/KS5cbiAgICAvLyBUT0RPKGRlYW5tKTogU3VwcG9ydCBpbnRlcmxhY2UuXG4gICAgYnVmW3ArK10gPSB1c2luZ19sb2NhbF9wYWxldHRlID09PSB0cnVlID8gKDB4ODAgfCAobWluX2NvZGVfc2l6ZS0xKSkgOiAwO1xuXG4gICAgLy8gLSBMb2NhbCBDb2xvciBUYWJsZVxuICAgIGlmICh1c2luZ19sb2NhbF9wYWxldHRlID09PSB0cnVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwYWxldHRlLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgdmFyIHJnYiA9IHBhbGV0dGVbaV07XG4gICAgICAgIGJ1ZltwKytdID0gcmdiID4+IDE2ICYgMHhmZjtcbiAgICAgICAgYnVmW3ArK10gPSByZ2IgPj4gOCAmIDB4ZmY7XG4gICAgICAgIGJ1ZltwKytdID0gcmdiICYgMHhmZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwID0gR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbShcbiAgICAgICAgICAgIGJ1ZiwgcCwgbWluX2NvZGVfc2l6ZSA8IDIgPyAyIDogbWluX2NvZGVfc2l6ZSwgaW5kZXhlZF9waXhlbHMpO1xuXG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdGhpcy5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoZW5kZWQgPT09IGZhbHNlKSB7XG4gICAgICBidWZbcCsrXSA9IDB4M2I7ICAvLyBUcmFpbGVyLlxuICAgICAgZW5kZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICB0aGlzLmdldE91dHB1dEJ1ZmZlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYnVmOyB9O1xuICB0aGlzLnNldE91dHB1dEJ1ZmZlciA9IGZ1bmN0aW9uKHYpIHsgYnVmID0gdjsgfTtcbiAgdGhpcy5nZXRPdXRwdXRCdWZmZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcDsgfTtcbiAgdGhpcy5zZXRPdXRwdXRCdWZmZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKHYpIHsgcCA9IHY7IH07XG59XG5cbi8vIE1haW4gY29tcHJlc3Npb24gcm91dGluZSwgcGFsZXR0ZSBpbmRleGVzIC0+IExaVyBjb2RlIHN0cmVhbS5cbi8vIHxpbmRleF9zdHJlYW18IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZW50cnkuXG5mdW5jdGlvbiBHaWZXcml0ZXJPdXRwdXRMWldDb2RlU3RyZWFtKGJ1ZiwgcCwgbWluX2NvZGVfc2l6ZSwgaW5kZXhfc3RyZWFtKSB7XG4gIGJ1ZltwKytdID0gbWluX2NvZGVfc2l6ZTtcbiAgdmFyIGN1cl9zdWJibG9jayA9IHArKzsgIC8vIFBvaW50aW5nIGF0IHRoZSBsZW5ndGggZmllbGQuXG5cbiAgdmFyIGNsZWFyX2NvZGUgPSAxIDw8IG1pbl9jb2RlX3NpemU7XG4gIHZhciBjb2RlX21hc2sgPSBjbGVhcl9jb2RlIC0gMTtcbiAgdmFyIGVvaV9jb2RlID0gY2xlYXJfY29kZSArIDE7XG4gIHZhciBuZXh0X2NvZGUgPSBlb2lfY29kZSArIDE7XG5cbiAgdmFyIGN1cl9jb2RlX3NpemUgPSBtaW5fY29kZV9zaXplICsgMTsgIC8vIE51bWJlciBvZiBiaXRzIHBlciBjb2RlLlxuICB2YXIgY3VyX3NoaWZ0ID0gMDtcbiAgLy8gV2UgaGF2ZSBhdCBtb3N0IDEyLWJpdCBjb2Rlcywgc28gd2Ugc2hvdWxkIGhhdmUgdG8gaG9sZCBhIG1heCBvZiAxOVxuICAvLyBiaXRzIGhlcmUgKGFuZCB0aGVuIHdlIHdvdWxkIHdyaXRlIG91dCkuXG4gIHZhciBjdXIgPSAwO1xuXG4gIGZ1bmN0aW9uIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKGJpdF9ibG9ja19zaXplKSB7XG4gICAgd2hpbGUgKGN1cl9zaGlmdCA+PSBiaXRfYmxvY2tfc2l6ZSkge1xuICAgICAgYnVmW3ArK10gPSBjdXIgJiAweGZmO1xuICAgICAgY3VyID4+PSA4OyBjdXJfc2hpZnQgLT0gODtcbiAgICAgIGlmIChwID09PSBjdXJfc3ViYmxvY2sgKyAyNTYpIHsgIC8vIEZpbmlzaGVkIGEgc3ViYmxvY2suXG4gICAgICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gMjU1O1xuICAgICAgICBjdXJfc3ViYmxvY2sgPSBwKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdF9jb2RlKGMpIHtcbiAgICBjdXIgfD0gYyA8PCBjdXJfc2hpZnQ7XG4gICAgY3VyX3NoaWZ0ICs9IGN1cl9jb2RlX3NpemU7XG4gICAgZW1pdF9ieXRlc190b19idWZmZXIoOCk7XG4gIH1cblxuICAvLyBJIGFtIG5vdCBhbiBleHBlcnQgb24gdGhlIHRvcGljLCBhbmQgSSBkb24ndCB3YW50IHRvIHdyaXRlIGEgdGhlc2lzLlxuICAvLyBIb3dldmVyLCBpdCBpcyBnb29kIHRvIG91dGxpbmUgaGVyZSB0aGUgYmFzaWMgYWxnb3JpdGhtIGFuZCB0aGUgZmV3IGRhdGFcbiAgLy8gc3RydWN0dXJlcyBhbmQgb3B0aW1pemF0aW9ucyBoZXJlIHRoYXQgbWFrZSB0aGlzIGltcGxlbWVudGF0aW9uIGZhc3QuXG4gIC8vIFRoZSBiYXNpYyBpZGVhIGJlaGluZCBMWlcgaXMgdG8gYnVpbGQgYSB0YWJsZSBvZiBwcmV2aW91c2x5IHNlZW4gcnVuc1xuICAvLyBhZGRyZXNzZWQgYnkgYSBzaG9ydCBpZCAoaGVyZWluIGNhbGxlZCBvdXRwdXQgY29kZSkuICBBbGwgZGF0YSBpc1xuICAvLyByZWZlcmVuY2VkIGJ5IGEgY29kZSwgd2hpY2ggcmVwcmVzZW50cyBvbmUgb3IgbW9yZSB2YWx1ZXMgZnJvbSB0aGVcbiAgLy8gb3JpZ2luYWwgaW5wdXQgc3RyZWFtLiAgQWxsIGlucHV0IGJ5dGVzIGNhbiBiZSByZWZlcmVuY2VkIGFzIHRoZSBzYW1lXG4gIC8vIHZhbHVlIGFzIGFuIG91dHB1dCBjb2RlLiAgU28gaWYgeW91IGRpZG4ndCB3YW50IGFueSBjb21wcmVzc2lvbiwgeW91XG4gIC8vIGNvdWxkIG1vcmUgb3IgbGVzcyBqdXN0IG91dHB1dCB0aGUgb3JpZ2luYWwgYnl0ZXMgYXMgY29kZXMgKHRoZXJlIGFyZVxuICAvLyBzb21lIGRldGFpbHMgdG8gdGhpcywgYnV0IGl0IGlzIHRoZSBpZGVhKS4gIEluIG9yZGVyIHRvIGFjaGlldmVcbiAgLy8gY29tcHJlc3Npb24sIHZhbHVlcyBncmVhdGVyIHRoZW4gdGhlIGlucHV0IHJhbmdlIChjb2RlcyBjYW4gYmUgdXAgdG9cbiAgLy8gMTItYml0IHdoaWxlIGlucHV0IG9ubHkgOC1iaXQpIHJlcHJlc2VudCBhIHNlcXVlbmNlIG9mIHByZXZpb3VzbHkgc2VlblxuICAvLyBpbnB1dHMuICBUaGUgZGVjb21wcmVzc29yIGlzIGFibGUgdG8gYnVpbGQgdGhlIHNhbWUgbWFwcGluZyB3aGlsZVxuICAvLyBkZWNvZGluZywgc28gdGhlcmUgaXMgYWx3YXlzIGEgc2hhcmVkIGNvbW1vbiBrbm93bGVkZ2UgYmV0d2VlbiB0aGVcbiAgLy8gZW5jb2RpbmcgYW5kIGRlY29kZXIsIHdoaWNoIGlzIGFsc28gaW1wb3J0YW50IGZvciBcInRpbWluZ1wiIGFzcGVjdHMgbGlrZVxuICAvLyBob3cgdG8gaGFuZGxlIHZhcmlhYmxlIGJpdCB3aWR0aCBjb2RlIGVuY29kaW5nLlxuICAvL1xuICAvLyBPbmUgb2J2aW91cyBidXQgdmVyeSBpbXBvcnRhbnQgY29uc2VxdWVuY2Ugb2YgdGhlIHRhYmxlIHN5c3RlbSBpcyB0aGVyZVxuICAvLyBpcyBhbHdheXMgYSB1bmlxdWUgaWQgKGF0IG1vc3QgMTItYml0cykgdG8gbWFwIHRoZSBydW5zLiAgJ0EnIG1pZ2h0IGJlXG4gIC8vIDQsIHRoZW4gJ0FBJyBtaWdodCBiZSAxMCwgJ0FBQScgMTEsICdBQUFBJyAxMiwgZXRjLiAgVGhpcyByZWxhdGlvbnNoaXBcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGFuIGVmZmVjaWVudCBsb29rdXAgc3RyYXRlZ3kgZm9yIHRoZSBjb2RlIG1hcHBpbmcuICBXZVxuICAvLyBuZWVkIHRvIGtub3cgaWYgYSBydW4gaGFzIGJlZW4gc2VlbiBiZWZvcmUsIGFuZCBiZSBhYmxlIHRvIG1hcCB0aGF0IHJ1blxuICAvLyB0byB0aGUgb3V0cHV0IGNvZGUuICBTaW5jZSB3ZSBzdGFydCB3aXRoIGtub3duIHVuaXF1ZSBpZHMgKGlucHV0IGJ5dGVzKSxcbiAgLy8gYW5kIHRoZW4gZnJvbSB0aG9zZSBidWlsZCBtb3JlIHVuaXF1ZSBpZHMgKHRhYmxlIGVudHJpZXMpLCB3ZSBjYW5cbiAgLy8gY29udGludWUgdGhpcyBjaGFpbiAoYWxtb3N0IGxpa2UgYSBsaW5rZWQgbGlzdCkgdG8gYWx3YXlzIGhhdmUgc21hbGxcbiAgLy8gaW50ZWdlciB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIGN1cnJlbnQgYnl0ZSBjaGFpbnMgaW4gdGhlIGVuY29kZXIuXG4gIC8vIFRoaXMgbWVhbnMgaW5zdGVhZCBvZiB0cmFja2luZyB0aGUgaW5wdXQgYnl0ZXMgKEFBQUFCQ0QpIHRvIGtub3cgb3VyXG4gIC8vIGN1cnJlbnQgc3RhdGUsIHdlIGNhbiB0cmFjayB0aGUgdGFibGUgZW50cnkgZm9yIEFBQUFCQyAoaXQgaXMgZ3VhcmFudGVlZFxuICAvLyB0byBleGlzdCBieSB0aGUgbmF0dXJlIG9mIHRoZSBhbGdvcml0aG0pIGFuZCB0aGUgbmV4dCBjaGFyYWN0ZXIgRC5cbiAgLy8gVGhlcmVmb3IgdGhlIHR1cGxlIG9mICh0YWJsZV9lbnRyeSwgYnl0ZSkgaXMgZ3VhcmFudGVlZCB0byBhbHNvIGJlXG4gIC8vIHVuaXF1ZS4gIFRoaXMgYWxsb3dzIHVzIHRvIGNyZWF0ZSBhIHNpbXBsZSBsb29rdXAga2V5IGZvciBtYXBwaW5nIGlucHV0XG4gIC8vIHNlcXVlbmNlcyB0byBjb2RlcyAodGFibGUgaW5kaWNlcykgd2l0aG91dCBoYXZpbmcgdG8gc3RvcmUgb3Igc2VhcmNoXG4gIC8vIGFueSBvZiB0aGUgY29kZSBzZXF1ZW5jZXMuICBTbyBpZiAnQUFBQScgaGFzIGEgdGFibGUgZW50cnkgb2YgMTIsIHRoZVxuICAvLyB0dXBsZSBvZiAoJ0FBQUEnLCBLKSBmb3IgYW55IGlucHV0IGJ5dGUgSyB3aWxsIGJlIHVuaXF1ZSwgYW5kIGNhbiBiZSBvdXJcbiAgLy8ga2V5LiAgVGhpcyBsZWFkcyB0byBhIGludGVnZXIgdmFsdWUgYXQgbW9zdCAyMC1iaXRzLCB3aGljaCBjYW4gYWx3YXlzXG4gIC8vIGZpdCBpbiBhbiBTTUkgdmFsdWUgYW5kIGJlIHVzZWQgYXMgYSBmYXN0IHNwYXJzZSBhcnJheSAvIG9iamVjdCBrZXkuXG5cbiAgLy8gT3V0cHV0IGNvZGUgZm9yIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoZSBpbmRleCBidWZmZXIuXG4gIHZhciBpYl9jb2RlID0gaW5kZXhfc3RyZWFtWzBdICYgY29kZV9tYXNrOyAgLy8gTG9hZCBmaXJzdCBpbnB1dCBpbmRleC5cbiAgdmFyIGNvZGVfdGFibGUgPSB7IH07ICAvLyBLZXknZCBvbiBvdXIgMjAtYml0IFwidHVwbGVcIi5cblxuICBlbWl0X2NvZGUoY2xlYXJfY29kZSk7ICAvLyBTcGVjIHNheXMgZmlyc3QgY29kZSBzaG91bGQgYmUgYSBjbGVhciBjb2RlLlxuXG4gIC8vIEZpcnN0IGluZGV4IGFscmVhZHkgbG9hZGVkLCBwcm9jZXNzIHRoZSByZXN0IG9mIHRoZSBzdHJlYW0uXG4gIGZvciAodmFyIGkgPSAxLCBpbCA9IGluZGV4X3N0cmVhbS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgdmFyIGsgPSBpbmRleF9zdHJlYW1baV0gJiBjb2RlX21hc2s7XG4gICAgdmFyIGN1cl9rZXkgPSBpYl9jb2RlIDw8IDggfCBrOyAgLy8gKHByZXYsIGspIHVuaXF1ZSB0dXBsZS5cbiAgICB2YXIgY3VyX2NvZGUgPSBjb2RlX3RhYmxlW2N1cl9rZXldOyAgLy8gYnVmZmVyICsgay5cblxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdG8gY3JlYXRlIGEgbmV3IGNvZGUgdGFibGUgZW50cnkuXG4gICAgaWYgKGN1cl9jb2RlID09PSB1bmRlZmluZWQpIHsgIC8vIFdlIGRvbid0IGhhdmUgYnVmZmVyICsgay5cbiAgICAgIC8vIEVtaXQgaW5kZXggYnVmZmVyICh3aXRob3V0IGspLlxuICAgICAgLy8gVGhpcyBpcyBhbiBpbmxpbmUgdmVyc2lvbiBvZiBlbWl0X2NvZGUsIGJlY2F1c2UgdGhpcyBpcyB0aGUgY29yZVxuICAgICAgLy8gd3JpdGluZyByb3V0aW5lIG9mIHRoZSBjb21wcmVzc29yIChhbmQgVjggY2Fubm90IGlubGluZSBlbWl0X2NvZGVcbiAgICAgIC8vIGJlY2F1c2UgaXQgaXMgYSBjbG9zdXJlIGhlcmUgaW4gYSBkaWZmZXJlbnQgY29udGV4dCkuICBBZGRpdGlvbmFsbHlcbiAgICAgIC8vIHdlIGNhbiBjYWxsIGVtaXRfYnl0ZV90b19idWZmZXIgbGVzcyBvZnRlbiwgYmVjYXVzZSB3ZSBjYW4gaGF2ZVxuICAgICAgLy8gMzAtYml0cyAoZnJvbSBvdXIgMzEtYml0IHNpZ25lZCBTTUkpLCBhbmQgd2Uga25vdyBvdXIgY29kZXMgd2lsbCBvbmx5XG4gICAgICAvLyBiZSAxMi1iaXRzLCBzbyBjYW4gc2FmZWx5IGhhdmUgMTgtYml0cyB0aGVyZSB3aXRob3V0IG92ZXJmbG93LlxuICAgICAgLy8gZW1pdF9jb2RlKGliX2NvZGUpO1xuICAgICAgY3VyIHw9IGliX2NvZGUgPDwgY3VyX3NoaWZ0O1xuICAgICAgY3VyX3NoaWZ0ICs9IGN1cl9jb2RlX3NpemU7XG4gICAgICB3aGlsZSAoY3VyX3NoaWZ0ID49IDgpIHtcbiAgICAgICAgYnVmW3ArK10gPSBjdXIgJiAweGZmO1xuICAgICAgICBjdXIgPj49IDg7IGN1cl9zaGlmdCAtPSA4O1xuICAgICAgICBpZiAocCA9PT0gY3VyX3N1YmJsb2NrICsgMjU2KSB7ICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gMjU1O1xuICAgICAgICAgIGN1cl9zdWJibG9jayA9IHArKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dF9jb2RlID09PSA0MDk2KSB7ICAvLyBUYWJsZSBmdWxsLCBuZWVkIGEgY2xlYXIuXG4gICAgICAgIGVtaXRfY29kZShjbGVhcl9jb2RlKTtcbiAgICAgICAgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuICAgICAgICBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7XG4gICAgICAgIGNvZGVfdGFibGUgPSB7IH07XG4gICAgICB9IGVsc2UgeyAgLy8gVGFibGUgbm90IGZ1bGwsIGluc2VydCBhIG5ldyBlbnRyeS5cbiAgICAgICAgLy8gSW5jcmVhc2Ugb3VyIHZhcmlhYmxlIGJpdCBjb2RlIHNpemVzIGlmIG5lY2Vzc2FyeS4gIFRoaXMgaXMgYSBiaXRcbiAgICAgICAgLy8gdHJpY2t5IGFzIGl0IGlzIGJhc2VkIG9uIFwidGltaW5nXCIgYmV0d2VlbiB0aGUgZW5jb2RpbmcgYW5kXG4gICAgICAgIC8vIGRlY29kZXIuICBGcm9tIHRoZSBlbmNvZGVycyBwZXJzcGVjdGl2ZSB0aGlzIHNob3VsZCBoYXBwZW4gYWZ0ZXJcbiAgICAgICAgLy8gd2UndmUgYWxyZWFkeSBlbWl0dGVkIHRoZSBpbmRleCBidWZmZXIgYW5kIGFyZSBhYm91dCB0byBjcmVhdGUgdGhlXG4gICAgICAgIC8vIGZpcnN0IHRhYmxlIGVudHJ5IHRoYXQgd291bGQgb3ZlcmZsb3cgb3VyIGN1cnJlbnQgY29kZSBiaXQgc2l6ZS5cbiAgICAgICAgaWYgKG5leHRfY29kZSA+PSAoMSA8PCBjdXJfY29kZV9zaXplKSkgKytjdXJfY29kZV9zaXplO1xuICAgICAgICBjb2RlX3RhYmxlW2N1cl9rZXldID0gbmV4dF9jb2RlKys7ICAvLyBJbnNlcnQgaW50byBjb2RlIHRhYmxlLlxuICAgICAgfVxuXG4gICAgICBpYl9jb2RlID0gazsgIC8vIEluZGV4IGJ1ZmZlciB0byBzaW5nbGUgaW5wdXQgay5cbiAgICB9IGVsc2Uge1xuICAgICAgaWJfY29kZSA9IGN1cl9jb2RlOyAgLy8gSW5kZXggYnVmZmVyIHRvIHNlcXVlbmNlIGluIGNvZGUgdGFibGUuXG4gICAgfVxuICB9XG5cbiAgZW1pdF9jb2RlKGliX2NvZGUpOyAgLy8gVGhlcmUgd2lsbCBzdGlsbCBiZSBzb21ldGhpbmcgaW4gdGhlIGluZGV4IGJ1ZmZlci5cbiAgZW1pdF9jb2RlKGVvaV9jb2RlKTsgIC8vIEVuZCBPZiBJbmZvcm1hdGlvbi5cblxuICAvLyBGbHVzaCAvIGZpbmFsaXplIHRoZSBzdWItYmxvY2tzIHN0cmVhbSB0byB0aGUgYnVmZmVyLlxuICBlbWl0X2J5dGVzX3RvX2J1ZmZlcigxKTtcblxuICAvLyBGaW5pc2ggdGhlIHN1Yi1ibG9ja3MsIHdyaXRpbmcgb3V0IGFueSB1bmZpbmlzaGVkIGxlbmd0aHMgYW5kXG4gIC8vIHRlcm1pbmF0aW5nIHdpdGggYSBzdWItYmxvY2sgb2YgbGVuZ3RoIDAuICBJZiB3ZSBoYXZlIGFscmVhZHkgc3RhcnRlZFxuICAvLyBidXQgbm90IHlldCB1c2VkIGEgc3ViLWJsb2NrIGl0IGNhbiBqdXN0IGJlY29tZSB0aGUgdGVybWluYXRvci5cbiAgaWYgKGN1cl9zdWJibG9jayArIDEgPT09IHApIHsgIC8vIFN0YXJ0ZWQgYnV0IHVudXNlZC5cbiAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDA7XG4gIH0gZWxzZSB7ICAvLyBTdGFydGVkIGFuZCB1c2VkLCB3cml0ZSBsZW5ndGggYW5kIGFkZGl0aW9uYWwgdGVybWluYXRvciBibG9jay5cbiAgICBidWZbY3VyX3N1YmJsb2NrXSA9IHAgLSBjdXJfc3ViYmxvY2sgLSAxO1xuICAgIGJ1ZltwKytdID0gMDtcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gR2lmUmVhZGVyKGJ1Zikge1xuICB2YXIgcCA9IDA7XG5cbiAgLy8gLSBIZWFkZXIgKEdJRjg3YSBvciBHSUY4OWEpLlxuICBpZiAoYnVmW3ArK10gIT09IDB4NDcgfHwgICAgICAgICAgICBidWZbcCsrXSAhPT0gMHg0OSB8fCBidWZbcCsrXSAhPT0gMHg0NiB8fFxuICAgICAgYnVmW3ArK10gIT09IDB4MzggfHwgKGJ1ZltwKytdKzEgJiAweGZkKSAhPT0gMHgzOCB8fCBidWZbcCsrXSAhPT0gMHg2MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgR0lGIDg3YS84OWEgaGVhZGVyLlwiKTtcbiAgfVxuXG4gIC8vIC0gTG9naWNhbCBTY3JlZW4gRGVzY3JpcHRvci5cbiAgdmFyIHdpZHRoID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICB2YXIgaGVpZ2h0ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICB2YXIgcGYwID0gYnVmW3ArK107ICAvLyA8UGFja2VkIEZpZWxkcz4uXG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9mbGFnID0gcGYwID4+IDc7XG4gIHZhciBudW1fZ2xvYmFsX2NvbG9yc19wb3cyID0gcGYwICYgMHg3O1xuICB2YXIgbnVtX2dsb2JhbF9jb2xvcnMgPSAxIDw8IChudW1fZ2xvYmFsX2NvbG9yc19wb3cyICsgMSk7XG4gIHZhciBiYWNrZ3JvdW5kID0gYnVmW3ArK107XG4gIGJ1ZltwKytdOyAgLy8gUGl4ZWwgYXNwZWN0IHJhdGlvICh1bnVzZWQ/KS5cblxuICB2YXIgZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0ID0gbnVsbDtcbiAgdmFyIGdsb2JhbF9wYWxldHRlX3NpemUgICA9IG51bGw7XG5cbiAgaWYgKGdsb2JhbF9wYWxldHRlX2ZsYWcpIHtcbiAgICBnbG9iYWxfcGFsZXR0ZV9vZmZzZXQgPSBwO1xuICAgIGdsb2JhbF9wYWxldHRlX3NpemUgPSBudW1fZ2xvYmFsX2NvbG9ycztcbiAgICBwICs9IG51bV9nbG9iYWxfY29sb3JzICogMzsgIC8vIFNlZWsgcGFzdCBwYWxldHRlLlxuICB9XG5cbiAgdmFyIG5vX2VvZiA9IHRydWU7XG5cbiAgdmFyIGZyYW1lcyA9IFsgXTtcblxuICB2YXIgZGVsYXkgPSAwO1xuICB2YXIgdHJhbnNwYXJlbnRfaW5kZXggPSBudWxsO1xuICB2YXIgZGlzcG9zYWwgPSAwOyAgLy8gMCAtIE5vIGRpc3Bvc2FsIHNwZWNpZmllZC5cbiAgdmFyIGxvb3BfY291bnQgPSBudWxsO1xuXG4gIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgd2hpbGUgKG5vX2VvZiAmJiBwIDwgYnVmLmxlbmd0aCkge1xuICAgIHN3aXRjaCAoYnVmW3ArK10pIHtcbiAgICAgIGNhc2UgMHgyMTogIC8vIEdyYXBoaWNzIENvbnRyb2wgRXh0ZW5zaW9uIEJsb2NrXG4gICAgICAgIHN3aXRjaCAoYnVmW3ArK10pIHtcbiAgICAgICAgICBjYXNlIDB4ZmY6ICAvLyBBcHBsaWNhdGlvbiBzcGVjaWZpYyBibG9ja1xuICAgICAgICAgICAgLy8gVHJ5IGlmIGl0J3MgYSBOZXRzY2FwZSBibG9jayAod2l0aCBhbmltYXRpb24gbG9vcCBjb3VudGVyKS5cbiAgICAgICAgICAgIGlmIChidWZbcCAgIF0gIT09IDB4MGIgfHwgIC8vIDIxIEZGIGFscmVhZHkgcmVhZCwgY2hlY2sgYmxvY2sgc2l6ZS5cbiAgICAgICAgICAgICAgICAvLyBORVRTQ0FQRTIuMFxuICAgICAgICAgICAgICAgIGJ1ZltwKzEgXSA9PSAweDRlICYmIGJ1ZltwKzIgXSA9PSAweDQ1ICYmIGJ1ZltwKzMgXSA9PSAweDU0ICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArNCBdID09IDB4NTMgJiYgYnVmW3ArNSBdID09IDB4NDMgJiYgYnVmW3ArNiBdID09IDB4NDEgJiZcbiAgICAgICAgICAgICAgICBidWZbcCs3IF0gPT0gMHg1MCAmJiBidWZbcCs4IF0gPT0gMHg0NSAmJiBidWZbcCs5IF0gPT0gMHgzMiAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzEwXSA9PSAweDJlICYmIGJ1ZltwKzExXSA9PSAweDMwICYmXG4gICAgICAgICAgICAgICAgLy8gU3ViLWJsb2NrXG4gICAgICAgICAgICAgICAgYnVmW3ArMTJdID09IDB4MDMgJiYgYnVmW3ArMTNdID09IDB4MDEgJiYgYnVmW3ArMTZdID09IDApIHtcbiAgICAgICAgICAgICAgcCArPSAxNDtcbiAgICAgICAgICAgICAgbG9vcF9jb3VudCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgICAgICAgcCsrOyAgLy8gU2tpcCB0ZXJtaW5hdG9yLlxuICAgICAgICAgICAgfSBlbHNlIHsgIC8vIFdlIGRvbid0IGtub3cgd2hhdCBpdCBpcywganVzdCB0cnkgdG8gZ2V0IHBhc3QgaXQuXG4gICAgICAgICAgICAgIHAgKz0gMTI7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7ICAvLyBTZWVrIHRocm91Z2ggc3ViYmxvY2tzLlxuICAgICAgICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgICAgICAgLy8gQmFkIGJsb2NrIHNpemUgKGV4OiB1bmRlZmluZWQgZnJvbSBhbiBvdXQgb2YgYm91bmRzIHJlYWQpLlxuICAgICAgICAgICAgICAgIGlmICghKGJsb2NrX3NpemUgPj0gMCkpIHRocm93IEVycm9yKFwiSW52YWxpZCBibG9jayBzaXplXCIpO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmOTogIC8vIEdyYXBoaWNzIENvbnRyb2wgRXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoYnVmW3ArK10gIT09IDB4NCB8fCBidWZbcCs0XSAhPT0gMClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncmFwaGljcyBleHRlbnNpb24gYmxvY2suXCIpO1xuICAgICAgICAgICAgdmFyIHBmMSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgZGVsYXkgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgICAgICB0cmFuc3BhcmVudF9pbmRleCA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgaWYgKChwZjEgJiAxKSA9PT0gMCkgdHJhbnNwYXJlbnRfaW5kZXggPSBudWxsO1xuICAgICAgICAgICAgZGlzcG9zYWwgPSBwZjEgPj4gMiAmIDB4NztcbiAgICAgICAgICAgIHArKzsgIC8vIFNraXAgdGVybWluYXRvci5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweGZlOiAgLy8gQ29tbWVudCBFeHRlbnNpb24uXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkgeyAgLy8gU2VlayB0aHJvdWdoIHN1YmJsb2Nrcy5cbiAgICAgICAgICAgICAgdmFyIGJsb2NrX3NpemUgPSBidWZbcCsrXTtcbiAgICAgICAgICAgICAgLy8gQmFkIGJsb2NrIHNpemUgKGV4OiB1bmRlZmluZWQgZnJvbSBhbiBvdXQgb2YgYm91bmRzIHJlYWQpLlxuICAgICAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICAgICAgaWYgKGJsb2NrX3NpemUgPT09IDApIGJyZWFrOyAgLy8gMCBzaXplIGlzIHRlcm1pbmF0b3JcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYnVmLnNsaWNlKHAsIHArYmxvY2tfc2l6ZSkudG9TdHJpbmcoJ2FzY2lpJykpO1xuICAgICAgICAgICAgICBwICs9IGJsb2NrX3NpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmtub3duIGdyYXBoaWMgY29udHJvbCBsYWJlbDogMHhcIiArIGJ1ZltwLTFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHgyYzogIC8vIEltYWdlIERlc2NyaXB0b3IuXG4gICAgICAgIHZhciB4ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgeSA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHcgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciBoID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgcGYyID0gYnVmW3ArK107XG4gICAgICAgIHZhciBsb2NhbF9wYWxldHRlX2ZsYWcgPSBwZjIgPj4gNztcbiAgICAgICAgdmFyIGludGVybGFjZV9mbGFnID0gcGYyID4+IDYgJiAxO1xuICAgICAgICB2YXIgbnVtX2xvY2FsX2NvbG9yc19wb3cyID0gcGYyICYgMHg3O1xuICAgICAgICB2YXIgbnVtX2xvY2FsX2NvbG9ycyA9IDEgPDwgKG51bV9sb2NhbF9jb2xvcnNfcG93MiArIDEpO1xuICAgICAgICB2YXIgcGFsZXR0ZV9vZmZzZXQgPSBnbG9iYWxfcGFsZXR0ZV9vZmZzZXQ7XG4gICAgICAgIHZhciBwYWxldHRlX3NpemUgPSBnbG9iYWxfcGFsZXR0ZV9zaXplO1xuICAgICAgICB2YXIgaGFzX2xvY2FsX3BhbGV0dGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxvY2FsX3BhbGV0dGVfZmxhZykge1xuICAgICAgICAgIHZhciBoYXNfbG9jYWxfcGFsZXR0ZSA9IHRydWU7XG4gICAgICAgICAgcGFsZXR0ZV9vZmZzZXQgPSBwOyAgLy8gT3ZlcnJpZGUgd2l0aCBsb2NhbCBwYWxldHRlLlxuICAgICAgICAgIHBhbGV0dGVfc2l6ZSA9IG51bV9sb2NhbF9jb2xvcnM7XG4gICAgICAgICAgcCArPSBudW1fbG9jYWxfY29sb3JzICogMzsgIC8vIFNlZWsgcGFzdCBwYWxldHRlLlxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFfb2Zmc2V0ID0gcDtcblxuICAgICAgICBwKys7ICAvLyBjb2Rlc2l6ZVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgLy8gQmFkIGJsb2NrIHNpemUgKGV4OiB1bmRlZmluZWQgZnJvbSBhbiBvdXQgb2YgYm91bmRzIHJlYWQpLlxuICAgICAgICAgIGlmICghKGJsb2NrX3NpemUgPj0gMCkpIHRocm93IEVycm9yKFwiSW52YWxpZCBibG9jayBzaXplXCIpO1xuICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhbWVzLnB1c2goe3g6IHgsIHk6IHksIHdpZHRoOiB3LCBoZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgICAgICBoYXNfbG9jYWxfcGFsZXR0ZTogaGFzX2xvY2FsX3BhbGV0dGUsXG4gICAgICAgICAgICAgICAgICAgICBwYWxldHRlX29mZnNldDogcGFsZXR0ZV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICBwYWxldHRlX3NpemU6IHBhbGV0dGVfc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgIGRhdGFfb2Zmc2V0OiBkYXRhX29mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgIGRhdGFfbGVuZ3RoOiBwIC0gZGF0YV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudF9pbmRleDogdHJhbnNwYXJlbnRfaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICBpbnRlcmxhY2VkOiAhIWludGVybGFjZV9mbGFnLFxuICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWw6IGRpc3Bvc2FsfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4M2I6ICAvLyBUcmFpbGVyIE1hcmtlciAoZW5kIG9mIGZpbGUpLlxuICAgICAgICBub19lb2YgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZ2lmIGJsb2NrOiAweFwiICsgYnVmW3AtMV0udG9TdHJpbmcoMTYpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5udW1GcmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnJhbWVzLmxlbmd0aDtcbiAgfTtcblxuICB0aGlzLmxvb3BDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsb29wX2NvdW50O1xuICB9O1xuXG4gIHRoaXMuZnJhbWVJbmZvID0gZnVuY3Rpb24oZnJhbWVfbnVtKSB7XG4gICAgaWYgKGZyYW1lX251bSA8IDAgfHwgZnJhbWVfbnVtID49IGZyYW1lcy5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcmFtZSBpbmRleCBvdXQgb2YgcmFuZ2UuXCIpO1xuICAgIHJldHVybiBmcmFtZXNbZnJhbWVfbnVtXTtcbiAgfVxuXG4gIHRoaXMuZGVjb2RlQW5kQmxpdEZyYW1lQkdSQSA9IGZ1bmN0aW9uKGZyYW1lX251bSwgcGl4ZWxzKSB7XG4gICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZUluZm8oZnJhbWVfbnVtKTtcbiAgICB2YXIgbnVtX3BpeGVscyA9IGZyYW1lLndpZHRoICogZnJhbWUuaGVpZ2h0O1xuICAgIHZhciBpbmRleF9zdHJlYW0gPSBuZXcgVWludDhBcnJheShudW1fcGl4ZWxzKTsgIC8vIEF0IG1vc3QgOC1iaXQgaW5kaWNlcy5cbiAgICBHaWZSZWFkZXJMWldPdXRwdXRJbmRleFN0cmVhbShcbiAgICAgICAgYnVmLCBmcmFtZS5kYXRhX29mZnNldCwgaW5kZXhfc3RyZWFtLCBudW1fcGl4ZWxzKTtcbiAgICB2YXIgcGFsZXR0ZV9vZmZzZXQgPSBmcmFtZS5wYWxldHRlX29mZnNldDtcblxuICAgIC8vIE5PVEUoZGVhbm0pOiBJdCBzZWVtcyB0byBiZSBtdWNoIGZhc3RlciB0byBjb21wYXJlIGluZGV4IHRvIDI1NiB0aGFuXG4gICAgLy8gdG8gPT09IG51bGwuICBOb3Qgc3VyZSB3aHksIGJ1dCBDb21wYXJlU3R1Yl9FUV9TVFJJQ1Qgc2hvd3MgdXAgaGlnaCBpblxuICAgIC8vIHRoZSBwcm9maWxlLCBub3Qgc3VyZSBpZiBpdCdzIHJlbGF0ZWQgdG8gdXNpbmcgYSBVaW50OEFycmF5LlxuICAgIHZhciB0cmFucyA9IGZyYW1lLnRyYW5zcGFyZW50X2luZGV4O1xuICAgIGlmICh0cmFucyA9PT0gbnVsbCkgdHJhbnMgPSAyNTY7XG5cbiAgICAvLyBXZSBhcmUgcG9zc2libHkganVzdCBibGl0dGluZyB0byBhIHBvcnRpb24gb2YgdGhlIGVudGlyZSBmcmFtZS5cbiAgICAvLyBUaGF0IGlzIGEgc3VicmVjdCB3aXRoaW4gdGhlIGZyYW1lcmVjdCwgc28gdGhlIGFkZGl0aW9uYWwgcGl4ZWxzXG4gICAgLy8gbXVzdCBiZSBza2lwcGVkIG92ZXIgYWZ0ZXIgd2UgZmluaXNoZWQgYSBzY2FubGluZS5cbiAgICB2YXIgZnJhbWV3aWR0aCAgPSBmcmFtZS53aWR0aDtcbiAgICB2YXIgZnJhbWVzdHJpZGUgPSB3aWR0aCAtIGZyYW1ld2lkdGg7XG4gICAgdmFyIHhsZWZ0ICAgICAgID0gZnJhbWV3aWR0aDsgIC8vIE51bWJlciBvZiBzdWJyZWN0IHBpeGVscyBsZWZ0IGluIHNjYW5saW5lLlxuXG4gICAgLy8gT3V0cHV0IGluZGljaWVzIG9mIHRoZSB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGNvcm5lcnMgb2YgdGhlIHN1YnJlY3QuXG4gICAgdmFyIG9wYmVnID0gKChmcmFtZS55ICogd2lkdGgpICsgZnJhbWUueCkgKiA0O1xuICAgIHZhciBvcGVuZCA9ICgoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgKiB3aWR0aCArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3AgICAgPSBvcGJlZztcblxuICAgIHZhciBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0O1xuXG4gICAgLy8gVXNlIHNjYW5zdHJpZGUgdG8gc2tpcCBwYXN0IHRoZSByb3dzIHdoZW4gaW50ZXJsYWNpbmcuICBUaGlzIGlzIHNraXBwaW5nXG4gICAgLy8gNyByb3dzIGZvciB0aGUgZmlyc3QgdHdvIHBhc3NlcywgdGhlbiAzIHRoZW4gMS5cbiAgICBpZiAoZnJhbWUuaW50ZXJsYWNlZCA9PT0gdHJ1ZSkge1xuICAgICAgc2NhbnN0cmlkZSArPSB3aWR0aCAqIDQgKiA3OyAgLy8gUGFzcyAxLlxuICAgIH1cblxuICAgIHZhciBpbnRlcmxhY2Vza2lwID0gODsgIC8vIFRyYWNraW5nIHRoZSByb3cgaW50ZXJ2YWwgaW4gdGhlIGN1cnJlbnQgcGFzcy5cblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGluZGV4X3N0cmVhbS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICB2YXIgaW5kZXggPSBpbmRleF9zdHJlYW1baV07XG5cbiAgICAgIGlmICh4bGVmdCA9PT0gMCkgeyAgLy8gQmVnaW5uaW5nIG9mIG5ldyBzY2FuIGxpbmVcbiAgICAgICAgb3AgKz0gc2NhbnN0cmlkZTtcbiAgICAgICAgeGxlZnQgPSBmcmFtZXdpZHRoO1xuICAgICAgICBpZiAob3AgPj0gb3BlbmQpIHsgLy8gQ2F0Y2ggdGhlIHdyYXAgdG8gc3dpdGNoIHBhc3NlcyB3aGVuIGludGVybGFjaW5nLlxuICAgICAgICAgIHNjYW5zdHJpZGUgPSBmcmFtZXN0cmlkZSAqIDQgKyB3aWR0aCAqIDQgKiAoaW50ZXJsYWNlc2tpcC0xKTtcbiAgICAgICAgICAvLyBpbnRlcmxhY2Vza2lwIC8gMiAqIDQgaXMgaW50ZXJsYWNlc2tpcCA8PCAxLlxuICAgICAgICAgIG9wID0gb3BiZWcgKyAoZnJhbWV3aWR0aCArIGZyYW1lc3RyaWRlKSAqIChpbnRlcmxhY2Vza2lwIDw8IDEpO1xuICAgICAgICAgIGludGVybGFjZXNraXAgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09PSB0cmFucykge1xuICAgICAgICBvcCArPSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDNdO1xuICAgICAgICB2YXIgZyA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDFdO1xuICAgICAgICB2YXIgYiA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDJdO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBiO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBnO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSByO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSAyNTU7XG4gICAgICB9XG4gICAgICAtLXhsZWZ0O1xuICAgIH1cbiAgfTtcblxuICAvLyBJIHdpbGwgZ28gdG8gY29weSBhbmQgcGFzdGUgaGVsbCBvbmUgZGF5Li4uXG4gIHRoaXMuZGVjb2RlQW5kQmxpdEZyYW1lUkdCQSA9IGZ1bmN0aW9uKGZyYW1lX251bSwgcGl4ZWxzKSB7XG4gICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZUluZm8oZnJhbWVfbnVtKTtcbiAgICB2YXIgbnVtX3BpeGVscyA9IGZyYW1lLndpZHRoICogZnJhbWUuaGVpZ2h0O1xuICAgIHZhciBpbmRleF9zdHJlYW0gPSBuZXcgVWludDhBcnJheShudW1fcGl4ZWxzKTsgIC8vIEF0IG1vc3QgOC1iaXQgaW5kaWNlcy5cbiAgICBHaWZSZWFkZXJMWldPdXRwdXRJbmRleFN0cmVhbShcbiAgICAgICAgYnVmLCBmcmFtZS5kYXRhX29mZnNldCwgaW5kZXhfc3RyZWFtLCBudW1fcGl4ZWxzKTtcbiAgICB2YXIgcGFsZXR0ZV9vZmZzZXQgPSBmcmFtZS5wYWxldHRlX29mZnNldDtcblxuICAgIC8vIE5PVEUoZGVhbm0pOiBJdCBzZWVtcyB0byBiZSBtdWNoIGZhc3RlciB0byBjb21wYXJlIGluZGV4IHRvIDI1NiB0aGFuXG4gICAgLy8gdG8gPT09IG51bGwuICBOb3Qgc3VyZSB3aHksIGJ1dCBDb21wYXJlU3R1Yl9FUV9TVFJJQ1Qgc2hvd3MgdXAgaGlnaCBpblxuICAgIC8vIHRoZSBwcm9maWxlLCBub3Qgc3VyZSBpZiBpdCdzIHJlbGF0ZWQgdG8gdXNpbmcgYSBVaW50OEFycmF5LlxuICAgIHZhciB0cmFucyA9IGZyYW1lLnRyYW5zcGFyZW50X2luZGV4O1xuICAgIGlmICh0cmFucyA9PT0gbnVsbCkgdHJhbnMgPSAyNTY7XG5cbiAgICAvLyBXZSBhcmUgcG9zc2libHkganVzdCBibGl0dGluZyB0byBhIHBvcnRpb24gb2YgdGhlIGVudGlyZSBmcmFtZS5cbiAgICAvLyBUaGF0IGlzIGEgc3VicmVjdCB3aXRoaW4gdGhlIGZyYW1lcmVjdCwgc28gdGhlIGFkZGl0aW9uYWwgcGl4ZWxzXG4gICAgLy8gbXVzdCBiZSBza2lwcGVkIG92ZXIgYWZ0ZXIgd2UgZmluaXNoZWQgYSBzY2FubGluZS5cbiAgICB2YXIgZnJhbWV3aWR0aCAgPSBmcmFtZS53aWR0aDtcbiAgICB2YXIgZnJhbWVzdHJpZGUgPSB3aWR0aCAtIGZyYW1ld2lkdGg7XG4gICAgdmFyIHhsZWZ0ICAgICAgID0gZnJhbWV3aWR0aDsgIC8vIE51bWJlciBvZiBzdWJyZWN0IHBpeGVscyBsZWZ0IGluIHNjYW5saW5lLlxuXG4gICAgLy8gT3V0cHV0IGluZGljaWVzIG9mIHRoZSB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGNvcm5lcnMgb2YgdGhlIHN1YnJlY3QuXG4gICAgdmFyIG9wYmVnID0gKChmcmFtZS55ICogd2lkdGgpICsgZnJhbWUueCkgKiA0O1xuICAgIHZhciBvcGVuZCA9ICgoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgKiB3aWR0aCArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3AgICAgPSBvcGJlZztcblxuICAgIHZhciBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0O1xuXG4gICAgLy8gVXNlIHNjYW5zdHJpZGUgdG8gc2tpcCBwYXN0IHRoZSByb3dzIHdoZW4gaW50ZXJsYWNpbmcuICBUaGlzIGlzIHNraXBwaW5nXG4gICAgLy8gNyByb3dzIGZvciB0aGUgZmlyc3QgdHdvIHBhc3NlcywgdGhlbiAzIHRoZW4gMS5cbiAgICBpZiAoZnJhbWUuaW50ZXJsYWNlZCA9PT0gdHJ1ZSkge1xuICAgICAgc2NhbnN0cmlkZSArPSB3aWR0aCAqIDQgKiA3OyAgLy8gUGFzcyAxLlxuICAgIH1cblxuICAgIHZhciBpbnRlcmxhY2Vza2lwID0gODsgIC8vIFRyYWNraW5nIHRoZSByb3cgaW50ZXJ2YWwgaW4gdGhlIGN1cnJlbnQgcGFzcy5cblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGluZGV4X3N0cmVhbS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICB2YXIgaW5kZXggPSBpbmRleF9zdHJlYW1baV07XG5cbiAgICAgIGlmICh4bGVmdCA9PT0gMCkgeyAgLy8gQmVnaW5uaW5nIG9mIG5ldyBzY2FuIGxpbmVcbiAgICAgICAgb3AgKz0gc2NhbnN0cmlkZTtcbiAgICAgICAgeGxlZnQgPSBmcmFtZXdpZHRoO1xuICAgICAgICBpZiAob3AgPj0gb3BlbmQpIHsgLy8gQ2F0Y2ggdGhlIHdyYXAgdG8gc3dpdGNoIHBhc3NlcyB3aGVuIGludGVybGFjaW5nLlxuICAgICAgICAgIHNjYW5zdHJpZGUgPSBmcmFtZXN0cmlkZSAqIDQgKyB3aWR0aCAqIDQgKiAoaW50ZXJsYWNlc2tpcC0xKTtcbiAgICAgICAgICAvLyBpbnRlcmxhY2Vza2lwIC8gMiAqIDQgaXMgaW50ZXJsYWNlc2tpcCA8PCAxLlxuICAgICAgICAgIG9wID0gb3BiZWcgKyAoZnJhbWV3aWR0aCArIGZyYW1lc3RyaWRlKSAqIChpbnRlcmxhY2Vza2lwIDw8IDEpO1xuICAgICAgICAgIGludGVybGFjZXNraXAgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09PSB0cmFucykge1xuICAgICAgICBvcCArPSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDNdO1xuICAgICAgICB2YXIgZyA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDFdO1xuICAgICAgICB2YXIgYiA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDJdO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSByO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBnO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBiO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSAyNTU7XG4gICAgICB9XG4gICAgICAtLXhsZWZ0O1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oY29kZV9zdHJlYW0sIHAsIG91dHB1dCwgb3V0cHV0X2xlbmd0aCkge1xuICB2YXIgbWluX2NvZGVfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107XG5cbiAgdmFyIGNsZWFyX2NvZGUgPSAxIDw8IG1pbl9jb2RlX3NpemU7XG4gIHZhciBlb2lfY29kZSA9IGNsZWFyX2NvZGUgKyAxO1xuICB2YXIgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuXG4gIHZhciBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7ICAvLyBOdW1iZXIgb2YgYml0cyBwZXIgY29kZS5cbiAgLy8gTk9URTogVGhpcyBzaGFyZXMgdGhlIHNhbWUgbmFtZSBhcyB0aGUgZW5jb2RlciwgYnV0IGhhcyBhIGRpZmZlcmVudFxuICAvLyBtZWFuaW5nIGhlcmUuICBIZXJlIHRoaXMgbWFza3MgZWFjaCBjb2RlIGNvbWluZyBmcm9tIHRoZSBjb2RlIHN0cmVhbS5cbiAgdmFyIGNvZGVfbWFzayA9ICgxIDw8IGN1cl9jb2RlX3NpemUpIC0gMTtcbiAgdmFyIGN1cl9zaGlmdCA9IDA7XG4gIHZhciBjdXIgPSAwO1xuXG4gIHZhciBvcCA9IDA7ICAvLyBPdXRwdXQgcG9pbnRlci5cblxuICB2YXIgc3ViYmxvY2tfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107XG5cbiAgLy8gVE9ETyhkZWFubSk6IFdvdWxkIHVzaW5nIGEgVHlwZWRBcnJheSBiZSBhbnkgZmFzdGVyPyAgQXQgbGVhc3QgaXQgd291bGRcbiAgLy8gc29sdmUgdGhlIGZhc3QgbW9kZSAvIGJhY2tpbmcgc3RvcmUgdW5jZXJ0YWludHkuXG4gIC8vIHZhciBjb2RlX3RhYmxlID0gQXJyYXkoNDA5Nik7XG4gIHZhciBjb2RlX3RhYmxlID0gbmV3IEludDMyQXJyYXkoNDA5Nik7ICAvLyBDYW4gYmUgc2lnbmVkLCB3ZSBvbmx5IHVzZSAyMCBiaXRzLlxuXG4gIHZhciBwcmV2X2NvZGUgPSBudWxsOyAgLy8gVHJhY2sgY29kZS0xLlxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gUmVhZCB1cCB0byB0d28gYnl0ZXMsIG1ha2luZyBzdXJlIHdlIGFsd2F5cyAxMi1iaXRzIGZvciBtYXggc2l6ZWQgY29kZS5cbiAgICB3aGlsZSAoY3VyX3NoaWZ0IDwgMTYpIHtcbiAgICAgIGlmIChzdWJibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIE5vIG1vcmUgZGF0YSB0byBiZSByZWFkLlxuXG4gICAgICBjdXIgfD0gY29kZV9zdHJlYW1bcCsrXSA8PCBjdXJfc2hpZnQ7XG4gICAgICBjdXJfc2hpZnQgKz0gODtcblxuICAgICAgaWYgKHN1YmJsb2NrX3NpemUgPT09IDEpIHsgIC8vIE5ldmVyIGxldCBpdCBnZXQgdG8gMCB0byBob2xkIGxvZ2ljIGFib3ZlLlxuICAgICAgICBzdWJibG9ja19zaXplID0gY29kZV9zdHJlYW1bcCsrXTsgIC8vIE5leHQgc3ViYmxvY2suXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAtLXN1YmJsb2NrX3NpemU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyhkZWFubSk6IFdlIHNob3VsZCBuZXZlciByZWFsbHkgZ2V0IGhlcmUsIHdlIHNob3VsZCBoYXZlIHJlY2VpdmVkXG4gICAgLy8gYW5kIEVPSS5cbiAgICBpZiAoY3VyX3NoaWZ0IDwgY3VyX2NvZGVfc2l6ZSlcbiAgICAgIGJyZWFrO1xuXG4gICAgdmFyIGNvZGUgPSBjdXIgJiBjb2RlX21hc2s7XG4gICAgY3VyID4+PSBjdXJfY29kZV9zaXplO1xuICAgIGN1cl9zaGlmdCAtPSBjdXJfY29kZV9zaXplO1xuXG4gICAgLy8gVE9ETyhkZWFubSk6IE1heWJlIHNob3VsZCBjaGVjayB0aGF0IHRoZSBmaXJzdCBjb2RlIHdhcyBhIGNsZWFyIGNvZGUsXG4gICAgLy8gYXQgbGVhc3QgdGhpcyBpcyB3aGF0IHlvdSdyZSBzdXBwb3NlZCB0byBkby4gIEJ1dCBhY3R1YWxseSBvdXIgZW5jb2RlclxuICAgIC8vIG5vdyBkb2Vzbid0IGVtaXQgYSBjbGVhciBjb2RlIGZpcnN0IGFueXdheS5cbiAgICBpZiAoY29kZSA9PT0gY2xlYXJfY29kZSkge1xuICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSB0byBjbGVhciB0aGUgdGFibGUuICBUaGlzIGNvdWxkIGJlIGEgZ29vZCBpZGVhXG4gICAgICAvLyBmb3IgZ3JlYXRlciBlcnJvciBjaGVja2luZywgYnV0IHdlIGRvbid0IHJlYWxseSBkbyBhbnkgYW55d2F5LiAgV2VcbiAgICAgIC8vIHdpbGwganVzdCB0cmFjayBpdCB3aXRoIG5leHRfY29kZSBhbmQgb3ZlcndyaXRlIG9sZCBlbnRyaWVzLlxuXG4gICAgICBuZXh0X2NvZGUgPSBlb2lfY29kZSArIDE7XG4gICAgICBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7XG4gICAgICBjb2RlX21hc2sgPSAoMSA8PCBjdXJfY29kZV9zaXplKSAtIDE7XG5cbiAgICAgIC8vIERvbid0IHVwZGF0ZSBwcmV2X2NvZGUgP1xuICAgICAgcHJldl9jb2RlID0gbnVsbDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gZW9pX2NvZGUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgYSBzaW1pbGFyIHNpdHVhdGlvbiBhcyB0aGUgZGVjb2Rlciwgd2hlcmUgd2Ugd2FudCB0byBzdG9yZVxuICAgIC8vIHZhcmlhYmxlIGxlbmd0aCBlbnRyaWVzIChjb2RlIHRhYmxlIGVudHJpZXMpLCBidXQgd2Ugd2FudCB0byBkbyBpbiBhXG4gICAgLy8gZmFzdGVyIG1hbm5lciB0aGFuIGFuIGFycmF5IG9mIGFycmF5cy4gIFRoZSBjb2RlIGJlbG93IHN0b3JlcyBzb3J0IG9mIGFcbiAgICAvLyBsaW5rZWQgbGlzdCB3aXRoaW4gdGhlIGNvZGUgdGFibGUsIGFuZCB0aGVuIFwiY2hhc2VzXCIgdGhyb3VnaCBpdCB0b1xuICAgIC8vIGNvbnN0cnVjdCB0aGUgZGljdGlvbmFyeSBlbnRyaWVzLiAgV2hlbiBhIG5ldyBlbnRyeSBpcyBjcmVhdGVkLCBqdXN0IHRoZVxuICAgIC8vIGxhc3QgYnl0ZSBpcyBzdG9yZWQsIGFuZCB0aGUgcmVzdCAocHJlZml4KSBvZiB0aGUgZW50cnkgaXMgb25seVxuICAgIC8vIHJlZmVyZW5jZWQgYnkgaXRzIHRhYmxlIGVudHJ5LiAgVGhlbiB0aGUgY29kZSBjaGFzZXMgdGhyb3VnaCB0aGVcbiAgICAvLyBwcmVmaXhlcyB1bnRpbCBpdCByZWFjaGVzIGEgc2luZ2xlIGJ5dGUgY29kZS4gIFdlIGhhdmUgdG8gY2hhc2UgdHdpY2UsXG4gICAgLy8gZmlyc3QgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoLCBhbmQgdGhlbiB0byBhY3R1YWxseSBjb3B5IHRoZSBkYXRhIHRvIHRoZVxuICAgIC8vIG91dHB1dCAoYmFja3dhcmRzLCBzaW5jZSB3ZSBrbm93IHRoZSBsZW5ndGgpLiAgVGhlIGFsdGVybmF0aXZlIHdvdWxkIGJlXG4gICAgLy8gc3RvcmluZyBzb21ldGhpbmcgaW4gYW4gaW50ZXJtZWRpYXRlIHN0YWNrLCBidXQgdGhhdCBkb2Vzbid0IG1ha2UgYW55XG4gICAgLy8gbW9yZSBzZW5zZS4gIEkgaW1wbGVtZW50ZWQgYW4gYXBwcm9hY2ggd2hlcmUgaXQgYWxzbyBzdG9yZWQgdGhlIGxlbmd0aFxuICAgIC8vIGluIHRoZSBjb2RlIHRhYmxlLCBhbHRob3VnaCBpdCdzIGEgYml0IHRyaWNreSBiZWNhdXNlIHlvdSBydW4gb3V0IG9mXG4gICAgLy8gYml0cyAoMTIgKyAxMiArIDgpLCBidXQgSSBkaWRuJ3QgbWVhc3VyZSBtdWNoIGltcHJvdmVtZW50cyAodGhlIHRhYmxlXG4gICAgLy8gZW50cmllcyBhcmUgZ2VuZXJhbGx5IG5vdCB0aGUgbG9uZykuICBFdmVuIHdoZW4gSSBjcmVhdGVkIGJlbmNobWFya3MgZm9yXG4gICAgLy8gdmVyeSBsb25nIHRhYmxlIGVudHJpZXMgdGhlIGNvbXBsZXhpdHkgZGlkIG5vdCBzZWVtIHdvcnRoIGl0LlxuICAgIC8vIFRoZSBjb2RlIHRhYmxlIHN0b3JlcyB0aGUgcHJlZml4IGVudHJ5IGluIDEyIGJpdHMgYW5kIHRoZW4gdGhlIHN1ZmZpeFxuICAgIC8vIGJ5dGUgaW4gOCBiaXRzLCBzbyBlYWNoIGVudHJ5IGlzIDIwIGJpdHMuXG5cbiAgICB2YXIgY2hhc2VfY29kZSA9IGNvZGUgPCBuZXh0X2NvZGUgPyBjb2RlIDogcHJldl9jb2RlO1xuXG4gICAgLy8gQ2hhc2Ugd2hhdCB3ZSB3aWxsIG91dHB1dCwgZWl0aGVyIHtDT0RFfSBvciB7Q09ERS0xfS5cbiAgICB2YXIgY2hhc2VfbGVuZ3RoID0gMDtcbiAgICB2YXIgY2hhc2UgPSBjaGFzZV9jb2RlO1xuICAgIHdoaWxlIChjaGFzZSA+IGNsZWFyX2NvZGUpIHtcbiAgICAgIGNoYXNlID0gY29kZV90YWJsZVtjaGFzZV0gPj4gODtcbiAgICAgICsrY2hhc2VfbGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBrID0gY2hhc2U7XG5cbiAgICB2YXIgb3BfZW5kID0gb3AgKyBjaGFzZV9sZW5ndGggKyAoY2hhc2VfY29kZSAhPT0gY29kZSA/IDEgOiAwKTtcbiAgICBpZiAob3BfZW5kID4gb3V0cHV0X2xlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nLCBnaWYgc3RyZWFtIGxvbmdlciB0aGFuIGV4cGVjdGVkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBbHJlYWR5IGhhdmUgdGhlIGZpcnN0IGJ5dGUgZnJvbSB0aGUgY2hhc2UsIG1pZ2h0IGFzIHdlbGwgd3JpdGUgaXQgZmFzdC5cbiAgICBvdXRwdXRbb3ArK10gPSBrO1xuXG4gICAgb3AgKz0gY2hhc2VfbGVuZ3RoO1xuICAgIHZhciBiID0gb3A7ICAvLyBUcmFjayBwb2ludGVyLCB3cml0aW5nIGJhY2t3YXJkcy5cblxuICAgIGlmIChjaGFzZV9jb2RlICE9PSBjb2RlKSAgLy8gVGhlIGNhc2Ugb2YgZW1pdHRpbmcge0NPREUtMX0gKyBrLlxuICAgICAgb3V0cHV0W29wKytdID0gaztcblxuICAgIGNoYXNlID0gY2hhc2VfY29kZTtcbiAgICB3aGlsZSAoY2hhc2VfbGVuZ3RoLS0pIHtcbiAgICAgIGNoYXNlID0gY29kZV90YWJsZVtjaGFzZV07XG4gICAgICBvdXRwdXRbLS1iXSA9IGNoYXNlICYgMHhmZjsgIC8vIFdyaXRlIGJhY2t3YXJkcy5cbiAgICAgIGNoYXNlID4+PSA4OyAgLy8gUHVsbCBkb3duIHRvIHRoZSBwcmVmaXggY29kZS5cbiAgICB9XG5cbiAgICBpZiAocHJldl9jb2RlICE9PSBudWxsICYmIG5leHRfY29kZSA8IDQwOTYpIHtcbiAgICAgIGNvZGVfdGFibGVbbmV4dF9jb2RlKytdID0gcHJldl9jb2RlIDw8IDggfCBrO1xuICAgICAgLy8gVE9ETyhkZWFubSk6IEZpZ3VyZSBvdXQgdGhpcyBjbGVhcmluZyB2cyBjb2RlIGdyb3d0aCBsb2dpYyBiZXR0ZXIuICBJXG4gICAgICAvLyBoYXZlIGFuIGZlZWxpbmcgdGhhdCBpdCBzaG91bGQganVzdCBoYXBwZW4gc29tZXdoZXJlIGVsc2UsIGZvciBub3cgaXRcbiAgICAgIC8vIGlzIGF3a3dhcmQgYmV0d2VlbiB3aGVuIHdlIGdyb3cgcGFzdCB0aGUgbWF4IGFuZCB0aGVuIGhpdCBhIGNsZWFyIGNvZGUuXG4gICAgICAvLyBGb3Igbm93IGp1c3QgY2hlY2sgaWYgd2UgaGl0IHRoZSBtYXggMTItYml0cyAodGhlbiBhIGNsZWFyIGNvZGUgc2hvdWxkXG4gICAgICAvLyBmb2xsb3csIGFsc28gb2YgY291cnNlIGVuY29kZWQgaW4gMTItYml0cykuXG4gICAgICBpZiAobmV4dF9jb2RlID49IGNvZGVfbWFzaysxICYmIGN1cl9jb2RlX3NpemUgPCAxMikge1xuICAgICAgICArK2N1cl9jb2RlX3NpemU7XG4gICAgICAgIGNvZGVfbWFzayA9IGNvZGVfbWFzayA8PCAxIHwgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2X2NvZGUgPSBjb2RlO1xuICB9XG5cbiAgaWYgKG9wICE9PSBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgY29uc29sZS5sb2coXCJXYXJuaW5nLCBnaWYgc3RyZWFtIHNob3J0ZXIgdGhhbiBleHBlY3RlZC5cIik7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBDb21tb25KUy5cbnRyeSB7IGV4cG9ydHMuR2lmV3JpdGVyID0gR2lmV3JpdGVyOyBleHBvcnRzLkdpZlJlYWRlciA9IEdpZlJlYWRlciB9IGNhdGNoKGUpIHt9XG4iXSwibmFtZXMiOlsiR2lmV3JpdGVyIiwiYnVmIiwid2lkdGgiLCJoZWlnaHQiLCJnb3B0cyIsInAiLCJ1bmRlZmluZWQiLCJsb29wX2NvdW50IiwibG9vcCIsImdsb2JhbF9wYWxldHRlIiwicGFsZXR0ZSIsIkVycm9yIiwiY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyIsIm51bV9jb2xvcnMiLCJsZW5ndGgiLCJncF9udW1fY29sb3JzX3BvdzIiLCJiYWNrZ3JvdW5kIiwiZ3BfbnVtX2NvbG9ycyIsImkiLCJpbCIsInJnYiIsImVuZGVkIiwiYWRkRnJhbWUiLCJ4IiwieSIsInciLCJoIiwiaW5kZXhlZF9waXhlbHMiLCJvcHRzIiwidXNpbmdfbG9jYWxfcGFsZXR0ZSIsIm1pbl9jb2RlX3NpemUiLCJkZWxheSIsImRpc3Bvc2FsIiwidXNlX3RyYW5zcGFyZW5jeSIsInRyYW5zcGFyZW50X2luZGV4IiwidHJhbnNwYXJlbnQiLCJHaWZXcml0ZXJPdXRwdXRMWldDb2RlU3RyZWFtIiwiZW5kIiwiZ2V0T3V0cHV0QnVmZmVyIiwic2V0T3V0cHV0QnVmZmVyIiwidiIsImdldE91dHB1dEJ1ZmZlclBvc2l0aW9uIiwic2V0T3V0cHV0QnVmZmVyUG9zaXRpb24iLCJpbmRleF9zdHJlYW0iLCJjdXJfc3ViYmxvY2siLCJjbGVhcl9jb2RlIiwiY29kZV9tYXNrIiwiZW9pX2NvZGUiLCJuZXh0X2NvZGUiLCJjdXJfY29kZV9zaXplIiwiY3VyX3NoaWZ0IiwiY3VyIiwiZW1pdF9ieXRlc190b19idWZmZXIiLCJiaXRfYmxvY2tfc2l6ZSIsImVtaXRfY29kZSIsImMiLCJpYl9jb2RlIiwiY29kZV90YWJsZSIsImsiLCJjdXJfa2V5IiwiY3VyX2NvZGUiLCJHaWZSZWFkZXIiLCJwZjAiLCJnbG9iYWxfcGFsZXR0ZV9mbGFnIiwibnVtX2dsb2JhbF9jb2xvcnNfcG93MiIsIm51bV9nbG9iYWxfY29sb3JzIiwiZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0IiwiZ2xvYmFsX3BhbGV0dGVfc2l6ZSIsIm5vX2VvZiIsImZyYW1lcyIsImJsb2NrX3NpemUiLCJwZjEiLCJ0b1N0cmluZyIsInBmMiIsImxvY2FsX3BhbGV0dGVfZmxhZyIsImludGVybGFjZV9mbGFnIiwibnVtX2xvY2FsX2NvbG9yc19wb3cyIiwibnVtX2xvY2FsX2NvbG9ycyIsInBhbGV0dGVfb2Zmc2V0IiwicGFsZXR0ZV9zaXplIiwiaGFzX2xvY2FsX3BhbGV0dGUiLCJkYXRhX29mZnNldCIsInB1c2giLCJkYXRhX2xlbmd0aCIsImludGVybGFjZWQiLCJudW1GcmFtZXMiLCJsb29wQ291bnQiLCJmcmFtZUluZm8iLCJmcmFtZV9udW0iLCJkZWNvZGVBbmRCbGl0RnJhbWVCR1JBIiwicGl4ZWxzIiwiZnJhbWUiLCJudW1fcGl4ZWxzIiwiVWludDhBcnJheSIsIkdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtIiwidHJhbnMiLCJmcmFtZXdpZHRoIiwiZnJhbWVzdHJpZGUiLCJ4bGVmdCIsIm9wYmVnIiwib3BlbmQiLCJvcCIsInNjYW5zdHJpZGUiLCJpbnRlcmxhY2Vza2lwIiwiaW5kZXgiLCJyIiwiZyIsImIiLCJkZWNvZGVBbmRCbGl0RnJhbWVSR0JBIiwiY29kZV9zdHJlYW0iLCJvdXRwdXQiLCJvdXRwdXRfbGVuZ3RoIiwic3ViYmxvY2tfc2l6ZSIsIkludDMyQXJyYXkiLCJwcmV2X2NvZGUiLCJjb2RlIiwiY2hhc2VfY29kZSIsImNoYXNlX2xlbmd0aCIsImNoYXNlIiwib3BfZW5kIiwiY29uc29sZSIsImxvZyIsImV4cG9ydHMiLCJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/omggif/omggif.js\n");

/***/ })

};
;