/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ericblade";
exports.ids = ["vendor-chunks/@ericblade"];
exports.modules = {

/***/ "(ssr)/./node_modules/@ericblade/quagga2/lib/quagga.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ericblade/quagga2/lib/quagga.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("(function(e, a) {\n    for(var i in a)e[i] = a[i];\n})(exports, /******/ function(modules) {\n    /******/ // The module cache\n    /******/ var installedModules = {};\n    /******/ /******/ // The require function\n    /******/ function __nested_webpack_require_223__(moduleId) {\n        /******/ /******/ // Check if module is in cache\n        /******/ if (installedModules[moduleId]) {\n            /******/ return installedModules[moduleId].exports;\n        /******/ }\n        /******/ // Create a new module (and put it into the cache)\n        /******/ var module = installedModules[moduleId] = {\n            /******/ i: moduleId,\n            /******/ l: false,\n            /******/ exports: {}\n        };\n        /******/ /******/ // Execute the module function\n        /******/ modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_223__);\n        /******/ /******/ // Flag the module as loaded\n        /******/ module.l = true;\n        /******/ /******/ // Return the exports of the module\n        /******/ return module.exports;\n    /******/ }\n    /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n    /******/ __nested_webpack_require_223__.m = modules;\n    /******/ /******/ // expose the module cache\n    /******/ __nested_webpack_require_223__.c = installedModules;\n    /******/ /******/ // define getter function for harmony exports\n    /******/ __nested_webpack_require_223__.d = function(exports1, name, getter) {\n        /******/ if (!__nested_webpack_require_223__.o(exports1, name)) {\n            /******/ Object.defineProperty(exports1, name, {\n                enumerable: true,\n                get: getter\n            });\n        /******/ }\n    /******/ };\n    /******/ /******/ // define __esModule on exports\n    /******/ __nested_webpack_require_223__.r = function(exports1) {\n        /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n            /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                value: \"Module\"\n            });\n        /******/ }\n        /******/ Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n    /******/ };\n    /******/ /******/ // create a fake namespace object\n    /******/ // mode & 1: value is a module id, require it\n    /******/ // mode & 2: merge all properties of value into the ns\n    /******/ // mode & 4: return value when already ns object\n    /******/ // mode & 8|1: behave like require\n    /******/ __nested_webpack_require_223__.t = function(value, mode) {\n        /******/ if (mode & 1) value = __nested_webpack_require_223__(value);\n        /******/ if (mode & 8) return value;\n        /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n        /******/ var ns = Object.create(null);\n        /******/ __nested_webpack_require_223__.r(ns);\n        /******/ Object.defineProperty(ns, \"default\", {\n            enumerable: true,\n            value: value\n        });\n        /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_223__.d(ns, key, (function(key) {\n            return value[key];\n        }).bind(null, key));\n        /******/ return ns;\n    /******/ };\n    /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n    /******/ __nested_webpack_require_223__.n = function(module) {\n        /******/ var getter = module && module.__esModule ? /******/ function getDefault() {\n            return module[\"default\"];\n        } : /******/ function getModuleExports() {\n            return module;\n        };\n        /******/ __nested_webpack_require_223__.d(getter, \"a\", getter);\n        /******/ return getter;\n    /******/ };\n    /******/ /******/ // Object.prototype.hasOwnProperty.call\n    /******/ __nested_webpack_require_223__.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n    };\n    /******/ /******/ // __webpack_public_path__\n    /******/ __nested_webpack_require_223__.p = \"/\";\n    /******/ /******/ /******/ // Load entry module and return exports\n    /******/ return __nested_webpack_require_223__(__nested_webpack_require_223__.s = 69);\n/******/ }([\n    /* 0 */ /***/ function(module, exports1, __nested_webpack_require_4103__) {\n        var toPropertyKey = __nested_webpack_require_4103__(62);\n        function _defineProperty(obj, key, value) {\n            key = toPropertyKey(key);\n            if (key in obj) {\n                Object.defineProperty(obj, key, {\n                    value: value,\n                    enumerable: true,\n                    configurable: true,\n                    writable: true\n                });\n            } else {\n                obj[key] = value;\n            }\n            return obj;\n        }\n        module.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 1 */ /***/ function(module, exports1) {\n        function _assertThisInitialized(self1) {\n            if (self1 === void 0) {\n                throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            }\n            return self1;\n        }\n        module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 2 */ /***/ function(module, exports1) {\n        function _getPrototypeOf(o) {\n            module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                return o.__proto__ || Object.getPrototypeOf(o);\n            }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n            return _getPrototypeOf(o);\n        }\n        module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 3 */ /***/ function(module, exports1) {\n        function _classCallCheck(instance, Constructor) {\n            if (!(instance instanceof Constructor)) {\n                throw new TypeError(\"Cannot call a class as a function\");\n            }\n        }\n        module.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 4 */ /***/ function(module, exports1, __nested_webpack_require_6168__) {\n        var toPropertyKey = __nested_webpack_require_6168__(62);\n        function _defineProperties(target, props) {\n            for(var i = 0; i < props.length; i++){\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n            }\n        }\n        function _createClass(Constructor, protoProps, staticProps) {\n            if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) _defineProperties(Constructor, staticProps);\n            Object.defineProperty(Constructor, \"prototype\", {\n                writable: false\n            });\n            return Constructor;\n        }\n        module.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 5 */ /***/ function(module, exports1) {\n        module.exports = __webpack_require__(/*! gl-matrix */ \"(ssr)/./node_modules/gl-matrix/esm/index.js\");\n    /***/ },\n    /* 6 */ /***/ function(module, exports1, __nested_webpack_require_7355__) {\n        var _typeof = __nested_webpack_require_7355__(13)[\"default\"];\n        var assertThisInitialized = __nested_webpack_require_7355__(1);\n        function _possibleConstructorReturn(self1, call) {\n            if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n                return call;\n            } else if (call !== void 0) {\n                throw new TypeError(\"Derived constructors may only return object or undefined\");\n            }\n            return assertThisInitialized(self1);\n        }\n        module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 7 */ /***/ function(module, exports1, __nested_webpack_require_8071__) {\n        var setPrototypeOf = __nested_webpack_require_8071__(41);\n        function _inherits(subClass, superClass) {\n            if (typeof superClass !== \"function\" && superClass !== null) {\n                throw new TypeError(\"Super expression must either be null or a function\");\n            }\n            subClass.prototype = Object.create(superClass && superClass.prototype, {\n                constructor: {\n                    value: subClass,\n                    writable: true,\n                    configurable: true\n                }\n            });\n            Object.defineProperty(subClass, \"prototype\", {\n                writable: false\n            });\n            if (superClass) setPrototypeOf(subClass, superClass);\n        }\n        module.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 8 */ /***/ function(module, exports1, __nested_webpack_require_8996__) {\n        // TODO(Babel 8): Remove this file.\n        var runtime = __nested_webpack_require_8996__(137)();\n        module.exports = runtime;\n        // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=\n        try {\n            regeneratorRuntime = runtime;\n        } catch (accidentalStrictMode) {\n            if (typeof globalThis === \"object\") {\n                globalThis.regeneratorRuntime = runtime;\n            } else {\n                Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n            }\n        }\n    /***/ },\n    /* 9 */ /***/ function(module, __nested_webpack_exports__, __webpack_require__) {\n        \"use strict\";\n        /* eslint-disable no-param-reassign */ /* harmony default export */ __nested_webpack_exports__[\"a\"] = {\n            init: function init(arr, val) {\n                arr.fill(val);\n            },\n            /**\n   * IN-PLACE Shuffles the content of an array\n   */ shuffle: function shuffle(arr) {\n                // Durstenfeld shuffle algorithm\n                // https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n                for(var i = arr.length - 1; i > 0; i--){\n                    var j = Math.floor(Math.random() * (i + 1));\n                    var _ref = [\n                        arr[j],\n                        arr[i]\n                    ];\n                    arr[i] = _ref[0];\n                    arr[j] = _ref[1];\n                }\n                return arr;\n            },\n            toPointList: function toPointList(arr) {\n                var rows = arr.reduce(function(p, n) {\n                    var row = \"[\".concat(n.join(\",\"), \"]\");\n                    p.push(row);\n                    return p;\n                }, []);\n                return \"[\".concat(rows.join(\",\\r\\n\"), \"]\");\n            },\n            /**\n   * returns the elements which's score is bigger than the threshold\n   */ // eslint-disable-next-line no-unused-vars\n            threshold: function threshold(arr, _threshold, scoreFunc) {\n                var queue = arr.reduce(function(prev, next) {\n                    if (scoreFunc.apply(arr, [\n                        next\n                    ]) >= _threshold) {\n                        prev.push(next);\n                    }\n                    return prev;\n                }, []);\n                return queue;\n            },\n            maxIndex: function maxIndex(arr) {\n                var max = 0;\n                for(var i = 0; i < arr.length; i++){\n                    if (arr[i] > arr[max]) {\n                        max = i;\n                    }\n                }\n                return max;\n            },\n            max: function max(arr) {\n                var max = 0;\n                for(var i = 0; i < arr.length; i++){\n                    if (arr[i] > max) {\n                        max = arr[i];\n                    }\n                }\n                return max;\n            },\n            sum: function sum(arr) {\n                var length = arr.length;\n                var sum = 0;\n                while(length--){\n                    sum += arr[length];\n                }\n                return sum;\n            }\n        };\n    /***/ },\n    /* 10 */ /***/ function(module, __nested_webpack_exports__, __nested_webpack_require_12284__) {\n        \"use strict\";\n        /* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_12284__(33);\n        /* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_12284__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);\n        /* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_12284__(3);\n        /* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_12284__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);\n        /* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_12284__(4);\n        /* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_12284__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);\n        /* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_12284__(0);\n        /* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_12284__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);\n        /* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_12284__(5);\n        /* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_12284__.n(gl_matrix__WEBPACK_IMPORTED_MODULE_4__);\n        /* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_12284__(9);\n        /* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_12284__(12);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_4__[\"glMatrix\"].setMatrixArrayType(Array);\n        function assertNumberPositive(val) {\n            if (val < 0) {\n                throw new Error(\"expected positive number, received \".concat(val));\n            }\n        }\n        var ImageWrapper = /*#__PURE__*/ function() {\n            // Represents a basic image combining the data and size. In addition, some methods for\n            // manipulation are contained within.\n            function ImageWrapper(size, data) {\n                var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;\n                var initialize = arguments.length > 3 ? arguments[3] : undefined;\n                _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, ImageWrapper);\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, \"data\", void 0);\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, \"size\", void 0);\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, \"indexMapping\", void 0);\n                if (!data) {\n                    this.data = new ArrayType(size.x * size.y);\n                    if (initialize) {\n                        _array_helper__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].init(this.data, 0);\n                    }\n                } else {\n                    this.data = data;\n                }\n                this.size = size;\n            }\n            // tests if a position is within the image, extended out by a border on each side\n            _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(ImageWrapper, [\n                {\n                    key: \"inImageWithBorder\",\n                    value: function inImageWithBorder(imgRef) {\n                        var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                        assertNumberPositive(border);\n                        return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;\n                    }\n                },\n                {\n                    key: \"subImageAsCopy\",\n                    value: function subImageAsCopy(imageWrapper, from) {\n                        assertNumberPositive(from.x);\n                        assertNumberPositive(from.y);\n                        var _imageWrapper$size = imageWrapper.size, sizeX = _imageWrapper$size.x, sizeY = _imageWrapper$size.y;\n                        for(var x = 0; x < sizeX; x++){\n                            for(var y = 0; y < sizeY; y++){\n                                // eslint-disable-next-line no-param-reassign\n                                imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];\n                            }\n                        }\n                        return imageWrapper;\n                    // TODO: this function really probably should call into ImageWrapper somewhere to make\n                    // sure that all of it's parameters are set properly, something like\n                    // ImageWrapper.UpdateFrom()\n                    // that might take a provided data and size, and make sure there's no invalid indexMapping\n                    // hanging around, and such.\n                    }\n                },\n                {\n                    key: \"get\",\n                    value: function get(x, y) {\n                        return this.data[y * this.size.x + x];\n                    }\n                },\n                {\n                    key: \"getSafe\",\n                    value: function getSafe(x, y) {\n                        // cache indexMapping because if we're using it once, we'll probably need it a bunch more\n                        // too\n                        if (!this.indexMapping) {\n                            this.indexMapping = {\n                                x: [],\n                                y: []\n                            };\n                            for(var i = 0; i < this.size.x; i++){\n                                this.indexMapping.x[i] = i;\n                                this.indexMapping.x[i + this.size.x] = i;\n                            }\n                            for(var _i = 0; _i < this.size.y; _i++){\n                                this.indexMapping.y[_i] = _i;\n                                this.indexMapping.y[_i + this.size.y] = _i;\n                            }\n                        }\n                        return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];\n                    }\n                },\n                {\n                    key: \"set\",\n                    value: function set(x, y, value) {\n                        this.data[y * this.size.x + x] = value;\n                        delete this.indexMapping;\n                        return this;\n                    }\n                },\n                {\n                    key: \"zeroBorder\",\n                    value: function zeroBorder() {\n                        var _this$size = this.size, width = _this$size.x, height = _this$size.y;\n                        for(var i = 0; i < width; i++){\n                            // eslint-disable-next-line no-multi-assign\n                            this.data[i] = this.data[(height - 1) * width + i] = 0;\n                        }\n                        for(var _i2 = 1; _i2 < height - 1; _i2++){\n                            // eslint-disable-next-line no-multi-assign\n                            this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;\n                        }\n                        delete this.indexMapping;\n                        return this;\n                    }\n                },\n                {\n                    key: \"moments\",\n                    value: function moments(labelCount) {\n                        var data = this.data;\n                        var x;\n                        var y;\n                        var height = this.size.y;\n                        var width = this.size.x;\n                        var val;\n                        var ysq;\n                        var labelSum = [];\n                        var i;\n                        var label;\n                        var mu11;\n                        var mu02;\n                        var mu20;\n                        var x_;\n                        var y_;\n                        var tmp;\n                        var result = [];\n                        var PI = Math.PI;\n                        var PI_4 = PI / 4;\n                        if (labelCount <= 0) {\n                            return result;\n                        }\n                        for(i = 0; i < labelCount; i++){\n                            labelSum[i] = {\n                                m00: 0,\n                                m01: 0,\n                                m10: 0,\n                                m11: 0,\n                                m02: 0,\n                                m20: 0,\n                                theta: 0,\n                                rad: 0\n                            };\n                        }\n                        for(y = 0; y < height; y++){\n                            ysq = y * y;\n                            for(x = 0; x < width; x++){\n                                val = data[y * width + x];\n                                if (val > 0) {\n                                    label = labelSum[val - 1];\n                                    label.m00 += 1;\n                                    label.m01 += y;\n                                    label.m10 += x;\n                                    label.m11 += x * y;\n                                    label.m02 += ysq;\n                                    label.m20 += x * x;\n                                }\n                            }\n                        }\n                        for(i = 0; i < labelCount; i++){\n                            label = labelSum[i];\n                            // eslint-disable-next-line no-restricted-globals\n                            if (!isNaN(label.m00) && label.m00 !== 0) {\n                                x_ = label.m10 / label.m00;\n                                y_ = label.m01 / label.m00;\n                                mu11 = label.m11 / label.m00 - x_ * y_;\n                                mu02 = label.m02 / label.m00 - y_ * y_;\n                                mu20 = label.m20 / label.m00 - x_ * x_;\n                                tmp = (mu02 - mu20) / (2 * mu11);\n                                tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI;\n                                // eslint-disable-next-line no-mixed-operators\n                                label.theta = (tmp * 180 / PI + 90) % 180 - 90;\n                                if (label.theta < 0) {\n                                    label.theta += 180;\n                                }\n                                label.rad = tmp > PI ? tmp - PI : tmp;\n                                label.vec = gl_matrix__WEBPACK_IMPORTED_MODULE_4__[\"vec2\"].clone([\n                                    Math.cos(tmp),\n                                    Math.sin(tmp)\n                                ]);\n                                result.push(label);\n                            }\n                        }\n                        return result;\n                    }\n                },\n                {\n                    key: \"getAsRGBA\",\n                    value: function getAsRGBA() {\n                        var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;\n                        var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);\n                        for(var y = 0; y < this.size.y; y++){\n                            for(var x = 0; x < this.size.x; x++){\n                                var pixel = y * this.size.x + x;\n                                var current = this.get(x, y) * scale;\n                                ret[pixel * 4 + 0] = current;\n                                ret[pixel * 4 + 1] = current;\n                                ret[pixel * 4 + 2] = current;\n                                ret[pixel * 4 + 3] = 255;\n                            }\n                        }\n                        return ret;\n                    }\n                },\n                {\n                    key: \"show\",\n                    value: function show(canvas) {\n                        var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;\n                        console.warn(\"* imagewrapper show getcontext 2d\");\n                        var ctx = canvas.getContext(\"2d\");\n                        if (!ctx) {\n                            throw new Error(\"Unable to get canvas context\");\n                        }\n                        var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                        var data = this.getAsRGBA(scale);\n                        // eslint-disable-next-line no-param-reassign\n                        canvas.width = this.size.x;\n                        // eslint-disable-next-line no-param-reassign\n                        canvas.height = this.size.y;\n                        var newFrame = new ImageData(data, frame.width, frame.height);\n                        ctx.putImageData(newFrame, 0, 0);\n                    }\n                },\n                {\n                    key: \"overlay\",\n                    value: function overlay(canvas, inScale, from) {\n                        var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;\n                        var hsv = [\n                            0,\n                            1,\n                            1\n                        ];\n                        var rgb = [\n                            0,\n                            0,\n                            0\n                        ];\n                        var whiteRgb = [\n                            255,\n                            255,\n                            255\n                        ];\n                        var blackRgb = [\n                            0,\n                            0,\n                            0\n                        ];\n                        var result = [];\n                        console.warn(\"* imagewrapper overlay getcontext 2d\");\n                        var ctx = canvas.getContext(\"2d\");\n                        if (!ctx) {\n                            throw new Error(\"Unable to get canvas context\");\n                        }\n                        var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);\n                        var data = frame.data;\n                        var length = this.data.length;\n                        while(length--){\n                            hsv[0] = this.data[length] * adjustedScale;\n                            // eslint-disable-next-line no-nested-ternary\n                            result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : Object(_cv_utils__WEBPACK_IMPORTED_MODULE_6__[\"hsv2rgb\"])(hsv, rgb);\n                            var pos = length * 4;\n                            var _result = result;\n                            var _result2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_result, 3);\n                            data[pos] = _result2[0];\n                            data[pos + 1] = _result2[1];\n                            data[pos + 2] = _result2[2];\n                            data[pos + 3] = 255;\n                        }\n                        ctx.putImageData(frame, from.x, from.y);\n                    }\n                }\n            ]);\n            return ImageWrapper;\n        }();\n        /* harmony default export */ __nested_webpack_exports__[\"a\"] = ImageWrapper;\n    /***/ },\n    /* 11 */ /***/ function(module, exports1) {\n        function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n            try {\n                var info = gen[key](arg);\n                var value = info.value;\n            } catch (error) {\n                reject(error);\n                return;\n            }\n            if (info.done) {\n                resolve(value);\n            } else {\n                Promise.resolve(value).then(_next, _throw);\n            }\n        }\n        function _asyncToGenerator(fn) {\n            return function() {\n                var self1 = this, args = arguments;\n                return new Promise(function(resolve, reject) {\n                    var gen = fn.apply(self1, args);\n                    function _next(value) {\n                        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n                    }\n                    function _throw(err) {\n                        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n                    }\n                    _next(undefined);\n                });\n            };\n        }\n        module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 12 */ /***/ function(module, __nested_webpack_exports__, __nested_webpack_require_29541__) {\n        \"use strict\";\n        // ESM COMPAT FLAG\n        __nested_webpack_require_29541__.r(__nested_webpack_exports__);\n        // EXPORTS\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"imageRef\", function() {\n            return /* binding */ imageRef;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"computeIntegralImage2\", function() {\n            return /* binding */ computeIntegralImage2;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"computeIntegralImage\", function() {\n            return /* binding */ computeIntegralImage;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"thresholdImage\", function() {\n            return /* binding */ thresholdImage;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"computeHistogram\", function() {\n            return /* binding */ computeHistogram;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"sharpenLine\", function() {\n            return /* binding */ sharpenLine;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"determineOtsuThreshold\", function() {\n            return /* binding */ determineOtsuThreshold;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"otsuThreshold\", function() {\n            return /* binding */ otsuThreshold;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"computeBinaryImage\", function() {\n            return /* binding */ computeBinaryImage;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"cluster\", function() {\n            return /* binding */ cv_utils_cluster;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"Tracer\", function() {\n            return /* binding */ Tracer;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"DILATE\", function() {\n            return /* binding */ DILATE;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"ERODE\", function() {\n            return /* binding */ ERODE;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"dilate\", function() {\n            return /* binding */ dilate;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"erode\", function() {\n            return /* binding */ erode;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"subtract\", function() {\n            return /* binding */ subtract;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"bitwiseOr\", function() {\n            return /* binding */ bitwiseOr;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"countNonZero\", function() {\n            return /* binding */ countNonZero;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"topGeneric\", function() {\n            return /* binding */ topGeneric;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"grayArrayFromImage\", function() {\n            return /* binding */ grayArrayFromImage;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"grayArrayFromContext\", function() {\n            return /* binding */ grayArrayFromContext;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"grayAndHalfSampleFromCanvasData\", function() {\n            return /* binding */ grayAndHalfSampleFromCanvasData;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"computeGray\", function() {\n            return /* binding */ computeGray;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"loadImageArray\", function() {\n            return /* binding */ loadImageArray;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"halfSample\", function() {\n            return /* binding */ halfSample;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"hsv2rgb\", function() {\n            return /* binding */ hsv2rgb;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"_computeDivisors\", function() {\n            return /* binding */ _computeDivisors;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"calculatePatchSize\", function() {\n            return /* binding */ calculatePatchSize;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"_parseCSSDimensionValues\", function() {\n            return /* binding */ _parseCSSDimensionValues;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"_dimensionsConverters\", function() {\n            return /* binding */ _dimensionsConverters;\n        });\n        __nested_webpack_require_29541__.d(__nested_webpack_exports__, \"computeImageArea\", function() {\n            return /* binding */ computeImageArea;\n        });\n        // EXTERNAL MODULE: external \"gl-matrix\"\n        var external_gl_matrix_ = __nested_webpack_require_29541__(5);\n        // EXTERNAL MODULE: ./src/common/array_helper.ts\n        var array_helper = __nested_webpack_require_29541__(9);\n        // CONCATENATED MODULE: ./src/common/cluster.js\n        // TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion\n        // into typescript. be warned. :-)\n        external_gl_matrix_[\"glMatrix\"].setMatrixArrayType(Array);\n        /**\n * Creates a cluster for grouping similar orientations of datapoints\n */ /* harmony default export */ var cluster = {\n            create: function create(point, threshold) {\n                var points = [];\n                var center = {\n                    rad: 0,\n                    vec: external_gl_matrix_[\"vec2\"].clone([\n                        0,\n                        0\n                    ])\n                };\n                var pointMap = {};\n                function _add(pointToAdd) {\n                    pointMap[pointToAdd.id] = pointToAdd;\n                    points.push(pointToAdd);\n                }\n                function updateCenter() {\n                    var i;\n                    var sum = 0;\n                    for(i = 0; i < points.length; i++){\n                        sum += points[i].rad;\n                    }\n                    center.rad = sum / points.length;\n                    center.vec = external_gl_matrix_[\"vec2\"].clone([\n                        Math.cos(center.rad),\n                        Math.sin(center.rad)\n                    ]);\n                }\n                function init() {\n                    _add(point);\n                    updateCenter();\n                }\n                init();\n                return {\n                    add: function add(pointToAdd) {\n                        if (!pointMap[pointToAdd.id]) {\n                            _add(pointToAdd);\n                            updateCenter();\n                        }\n                    },\n                    fits: function fits(otherPoint) {\n                        // check cosine similarity to center-angle\n                        var similarity = Math.abs(external_gl_matrix_[\"vec2\"].dot(otherPoint.point.vec, center.vec));\n                        if (similarity > threshold) {\n                            return true;\n                        }\n                        return false;\n                    },\n                    getPoints: function getPoints() {\n                        return points;\n                    },\n                    getCenter: function getCenter() {\n                        return center;\n                    }\n                };\n            },\n            createPoint: function createPoint(newPoint, id, property) {\n                return {\n                    rad: newPoint[property],\n                    point: newPoint,\n                    id: id\n                };\n            }\n        };\n        // CONCATENATED MODULE: ./src/common/cv_utils.js\n        /* eslint-disable no-mixed-operators */ /* eslint-disable no-bitwise */ external_gl_matrix_[\"glMatrix\"].setMatrixArrayType(Array);\n        /**\n * @param x x-coordinate\n * @param y y-coordinate\n * @return ImageReference {x,y} Coordinate\n */ function imageRef(x, y) {\n            var that = {\n                x: x,\n                y: y,\n                toVec2: function toVec2() {\n                    return external_gl_matrix_[\"vec2\"].clone([\n                        this.x,\n                        this.y\n                    ]);\n                },\n                toVec3: function toVec3() {\n                    return external_gl_matrix_[\"vec3\"].clone([\n                        this.x,\n                        this.y,\n                        1\n                    ]);\n                },\n                round: function round() {\n                    this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);\n                    this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);\n                    return this;\n                }\n            };\n            return that;\n        }\n        /**\n * Computes an integral image of a given grayscale image.\n * @param imageDataContainer {ImageDataContainer} the image to be integrated\n */ function computeIntegralImage2(imageWrapper, integralWrapper) {\n            var imageData = imageWrapper.data;\n            var width = imageWrapper.size.x;\n            var height = imageWrapper.size.y;\n            var integralImageData = integralWrapper.data;\n            var sum = 0;\n            var posA = 0;\n            var posB = 0;\n            var posC = 0;\n            var posD = 0;\n            var x;\n            var y;\n            // sum up first column\n            posB = width;\n            sum = 0;\n            for(y = 1; y < height; y++){\n                sum += imageData[posA];\n                integralImageData[posB] += sum;\n                posA += width;\n                posB += width;\n            }\n            posA = 0;\n            posB = 1;\n            sum = 0;\n            for(x = 1; x < width; x++){\n                sum += imageData[posA];\n                integralImageData[posB] += sum;\n                posA++;\n                posB++;\n            }\n            for(y = 1; y < height; y++){\n                posA = y * width + 1;\n                posB = (y - 1) * width + 1;\n                posC = y * width;\n                posD = (y - 1) * width;\n                for(x = 1; x < width; x++){\n                    integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];\n                    posA++;\n                    posB++;\n                    posC++;\n                    posD++;\n                }\n            }\n        }\n        function computeIntegralImage(imageWrapper, integralWrapper) {\n            var imageData = imageWrapper.data;\n            var width = imageWrapper.size.x;\n            var height = imageWrapper.size.y;\n            var integralImageData = integralWrapper.data;\n            var sum = 0;\n            // sum up first row\n            for(var i = 0; i < width; i++){\n                sum += imageData[i];\n                integralImageData[i] = sum;\n            }\n            for(var v = 1; v < height; v++){\n                sum = 0;\n                for(var u = 0; u < width; u++){\n                    sum += imageData[v * width + u];\n                    integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];\n                }\n            }\n        }\n        function thresholdImage(imageWrapper, threshold, targetWrapper) {\n            if (!targetWrapper) {\n                // eslint-disable-next-line no-param-reassign\n                targetWrapper = imageWrapper;\n            }\n            var imageData = imageWrapper.data;\n            var length = imageData.length;\n            var targetData = targetWrapper.data;\n            while(length--){\n                targetData[length] = imageData[length] < threshold ? 1 : 0;\n            }\n        }\n        function computeHistogram(imageWrapper, bitsPerPixel) {\n            if (!bitsPerPixel) {\n                // eslint-disable-next-line no-param-reassign\n                bitsPerPixel = 8;\n            }\n            var imageData = imageWrapper.data;\n            var length = imageData.length;\n            var bitShift = 8 - bitsPerPixel;\n            var bucketCnt = 1 << bitsPerPixel;\n            var hist = new Int32Array(bucketCnt);\n            while(length--){\n                hist[imageData[length] >> bitShift]++;\n            }\n            return hist;\n        }\n        function sharpenLine(line) {\n            var i;\n            var length = line.length;\n            var left = line[0];\n            var center = line[1];\n            var right;\n            for(i = 1; i < length - 1; i++){\n                right = line[i + 1];\n                //  -1 4 -1 kernel\n                // eslint-disable-next-line no-param-reassign\n                line[i - 1] = center * 2 - left - right & 255;\n                left = center;\n                center = right;\n            }\n            return line;\n        }\n        function determineOtsuThreshold(imageWrapper) {\n            var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n            var hist;\n            var bitShift = 8 - bitsPerPixel;\n            function px(init, end) {\n                var sum = 0;\n                for(var i = init; i <= end; i++){\n                    sum += hist[i];\n                }\n                return sum;\n            }\n            function mx(init, end) {\n                var sum = 0;\n                for(var i = init; i <= end; i++){\n                    sum += i * hist[i];\n                }\n                return sum;\n            }\n            function determineThreshold() {\n                var vet = [\n                    0\n                ];\n                var p1;\n                var p2;\n                var p12;\n                var m1;\n                var m2;\n                var m12;\n                var max = (1 << bitsPerPixel) - 1;\n                hist = computeHistogram(imageWrapper, bitsPerPixel);\n                for(var k = 1; k < max; k++){\n                    p1 = px(0, k);\n                    p2 = px(k + 1, max);\n                    p12 = p1 * p2;\n                    if (p12 === 0) {\n                        p12 = 1;\n                    }\n                    m1 = mx(0, k) * p2;\n                    m2 = mx(k + 1, max) * p1;\n                    m12 = m1 - m2;\n                    vet[k] = m12 * m12 / p12;\n                }\n                return array_helper[\"a\" /* default */ ].maxIndex(vet);\n            }\n            var threshold = determineThreshold();\n            return threshold << bitShift;\n        }\n        function otsuThreshold(imageWrapper, targetWrapper) {\n            var threshold = determineOtsuThreshold(imageWrapper);\n            thresholdImage(imageWrapper, threshold, targetWrapper);\n            return threshold;\n        }\n        // local thresholding\n        function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {\n            computeIntegralImage(imageWrapper, integralWrapper);\n            if (!targetWrapper) {\n                // eslint-disable-next-line no-param-reassign\n                targetWrapper = imageWrapper;\n            }\n            var imageData = imageWrapper.data;\n            var targetData = targetWrapper.data;\n            var width = imageWrapper.size.x;\n            var height = imageWrapper.size.y;\n            var integralImageData = integralWrapper.data;\n            var sum = 0;\n            var v;\n            var u;\n            var kernel = 3;\n            var A;\n            var B;\n            var C;\n            var D;\n            var avg;\n            var size = (kernel * 2 + 1) * (kernel * 2 + 1);\n            // clear out top & bottom-border\n            for(v = 0; v <= kernel; v++){\n                for(u = 0; u < width; u++){\n                    targetData[v * width + u] = 0;\n                    targetData[(height - 1 - v) * width + u] = 0;\n                }\n            }\n            // clear out left & right border\n            for(v = kernel; v < height - kernel; v++){\n                for(u = 0; u <= kernel; u++){\n                    targetData[v * width + u] = 0;\n                    targetData[v * width + (width - 1 - u)] = 0;\n                }\n            }\n            for(v = kernel + 1; v < height - kernel - 1; v++){\n                for(u = kernel + 1; u < width - kernel; u++){\n                    A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];\n                    B = integralImageData[(v - kernel - 1) * width + (u + kernel)];\n                    C = integralImageData[(v + kernel) * width + (u - kernel - 1)];\n                    D = integralImageData[(v + kernel) * width + (u + kernel)];\n                    sum = D - C - B + A;\n                    avg = sum / size;\n                    targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;\n                }\n            }\n        }\n        function cv_utils_cluster(points, threshold, property) {\n            var i;\n            var k;\n            var thisCluster;\n            var point;\n            var clusters = [];\n            if (!property) {\n                // eslint-disable-next-line no-param-reassign\n                property = \"rad\";\n            }\n            function addToCluster(newPoint) {\n                var found = false;\n                for(k = 0; k < clusters.length; k++){\n                    thisCluster = clusters[k];\n                    if (thisCluster.fits(newPoint)) {\n                        thisCluster.add(newPoint);\n                        found = true;\n                    }\n                }\n                return found;\n            }\n            // iterate over each cloud\n            for(i = 0; i < points.length; i++){\n                point = cluster.createPoint(points[i], i, property);\n                if (!addToCluster(point)) {\n                    clusters.push(cluster.create(point, threshold));\n                }\n            }\n            return clusters;\n        }\n        var Tracer = {\n            trace: function trace(points, vec) {\n                var iteration;\n                var maxIterations = 10;\n                var top = [];\n                var result = [];\n                var centerPos = 0;\n                var currentPos = 0;\n                function trace(idx, forward) {\n                    var to;\n                    var toIdx;\n                    var predictedPos;\n                    var thresholdX = 1;\n                    var thresholdY = Math.abs(vec[1] / 10);\n                    var found = false;\n                    function match(pos, predicted) {\n                        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {\n                            return true;\n                        }\n                        return false;\n                    }\n                    // check if the next index is within the vec specifications\n                    // if not, check as long as the threshold is met\n                    var from = points[idx];\n                    if (forward) {\n                        predictedPos = {\n                            x: from.x + vec[0],\n                            y: from.y + vec[1]\n                        };\n                    } else {\n                        predictedPos = {\n                            x: from.x - vec[0],\n                            y: from.y - vec[1]\n                        };\n                    }\n                    toIdx = forward ? idx + 1 : idx - 1;\n                    to = points[toIdx];\n                    // eslint-disable-next-line no-cond-assign\n                    while(to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]){\n                        toIdx = forward ? toIdx + 1 : toIdx - 1;\n                        to = points[toIdx];\n                    }\n                    return found ? toIdx : null;\n                }\n                for(iteration = 0; iteration < maxIterations; iteration++){\n                    // randomly select point to start with\n                    centerPos = Math.floor(Math.random() * points.length);\n                    // trace forward\n                    top = [];\n                    currentPos = centerPos;\n                    top.push(points[currentPos]);\n                    // eslint-disable-next-line no-cond-assign\n                    while((currentPos = trace(currentPos, true)) !== null){\n                        top.push(points[currentPos]);\n                    }\n                    if (centerPos > 0) {\n                        currentPos = centerPos;\n                        // eslint-disable-next-line no-cond-assign\n                        while((currentPos = trace(currentPos, false)) !== null){\n                            top.push(points[currentPos]);\n                        }\n                    }\n                    if (top.length > result.length) {\n                        result = top;\n                    }\n                }\n                return result;\n            }\n        };\n        var DILATE = 1;\n        var ERODE = 2;\n        function dilate(inImageWrapper, outImageWrapper) {\n            var v;\n            var u;\n            var inImageData = inImageWrapper.data;\n            var outImageData = outImageWrapper.data;\n            var height = inImageWrapper.size.y;\n            var width = inImageWrapper.size.x;\n            var sum;\n            var yStart1;\n            var yStart2;\n            var xStart1;\n            var xStart2;\n            for(v = 1; v < height - 1; v++){\n                for(u = 1; u < width - 1; u++){\n                    yStart1 = v - 1;\n                    yStart2 = v + 1;\n                    xStart1 = u - 1;\n                    xStart2 = u + 1;\n                    sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];\n                    outImageData[v * width + u] = sum > 0 ? 1 : 0;\n                }\n            }\n        }\n        function erode(inImageWrapper, outImageWrapper) {\n            var v;\n            var u;\n            var inImageData = inImageWrapper.data;\n            var outImageData = outImageWrapper.data;\n            var height = inImageWrapper.size.y;\n            var width = inImageWrapper.size.x;\n            var sum;\n            var yStart1;\n            var yStart2;\n            var xStart1;\n            var xStart2;\n            for(v = 1; v < height - 1; v++){\n                for(u = 1; u < width - 1; u++){\n                    yStart1 = v - 1;\n                    yStart2 = v + 1;\n                    xStart1 = u - 1;\n                    xStart2 = u + 1;\n                    sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];\n                    outImageData[v * width + u] = sum === 5 ? 1 : 0;\n                }\n            }\n        }\n        function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {\n            if (!resultImageWrapper) {\n                // eslint-disable-next-line no-param-reassign\n                resultImageWrapper = aImageWrapper;\n            }\n            var length = aImageWrapper.data.length;\n            var aImageData = aImageWrapper.data;\n            var bImageData = bImageWrapper.data;\n            var cImageData = resultImageWrapper.data;\n            while(length--){\n                cImageData[length] = aImageData[length] - bImageData[length];\n            }\n        }\n        function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {\n            if (!resultImageWrapper) {\n                // eslint-disable-next-line no-param-reassign\n                resultImageWrapper = aImageWrapper;\n            }\n            var length = aImageWrapper.data.length;\n            var aImageData = aImageWrapper.data;\n            var bImageData = bImageWrapper.data;\n            var cImageData = resultImageWrapper.data;\n            while(length--){\n                cImageData[length] = aImageData[length] || bImageData[length];\n            }\n        }\n        function countNonZero(imageWrapper) {\n            var length = imageWrapper.data.length;\n            var data = imageWrapper.data;\n            var sum = 0;\n            while(length--){\n                sum += data[length];\n            }\n            return sum;\n        }\n        function topGeneric(list, top, scoreFunc) {\n            var i;\n            var minIdx = 0;\n            var min = 0;\n            var queue = [];\n            var score;\n            var hit;\n            var pos;\n            for(i = 0; i < top; i++){\n                queue[i] = {\n                    score: 0,\n                    item: null\n                };\n            }\n            for(i = 0; i < list.length; i++){\n                score = scoreFunc.apply(this, [\n                    list[i]\n                ]);\n                if (score > min) {\n                    hit = queue[minIdx];\n                    hit.score = score;\n                    hit.item = list[i];\n                    min = Number.MAX_VALUE;\n                    for(pos = 0; pos < top; pos++){\n                        if (queue[pos].score < min) {\n                            min = queue[pos].score;\n                            minIdx = pos;\n                        }\n                    }\n                }\n            }\n            return queue;\n        }\n        function grayArrayFromImage(htmlImage, offsetX, ctx, array) {\n            ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);\n            var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;\n            computeGray(ctxData, array);\n        }\n        function grayArrayFromContext(ctx, size, offset, array) {\n            var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;\n            computeGray(ctxData, array);\n        }\n        function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {\n            var topRowIdx = 0;\n            var bottomRowIdx = size.x;\n            var endIdx = Math.floor(canvasData.length / 4);\n            var outWidth = size.x / 2;\n            var outImgIdx = 0;\n            var inWidth = size.x;\n            var i;\n            while(bottomRowIdx < endIdx){\n                for(i = 0; i < outWidth; i++){\n                    // eslint-disable-next-line no-param-reassign\n                    outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;\n                    outImgIdx++;\n                    topRowIdx += 2;\n                    bottomRowIdx += 2;\n                }\n                topRowIdx += inWidth;\n                bottomRowIdx += inWidth;\n            }\n        }\n        function computeGray(imageData, outArray, config) {\n            var l = imageData.length / 4 | 0;\n            var singleChannel = config && config.singleChannel === true;\n            if (singleChannel) {\n                for(var i = 0; i < l; i++){\n                    // eslint-disable-next-line no-param-reassign\n                    outArray[i] = imageData[i * 4 + 0];\n                }\n            } else {\n                for(var _i = 0; _i < l; _i++){\n                    // eslint-disable-next-line no-param-reassign\n                    outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];\n                }\n            }\n        }\n        function loadImageArray(src, callback) {\n            var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement(\"canvas\");\n            var img = new Image();\n            img.callback = callback;\n            img.onload = function() {\n                // eslint-disable-next-line no-param-reassign\n                canvas.width = this.width;\n                // eslint-disable-next-line no-param-reassign\n                canvas.height = this.height;\n                console.warn(\"* loadImageArray getContext 2d\");\n                var ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(this, 0, 0);\n                var array = new Uint8Array(this.width * this.height);\n                ctx.drawImage(this, 0, 0);\n                var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height), data = _ctx$getImageData.data;\n                computeGray(data, array);\n                this.callback(array, {\n                    x: this.width,\n                    y: this.height\n                }, this);\n            };\n            img.src = src;\n        }\n        /**\n * @param inImg {ImageWrapper} input image to be sampled\n * @param outImg {ImageWrapper} to be stored in\n */ function halfSample(inImgWrapper, outImgWrapper) {\n            var inImg = inImgWrapper.data;\n            var inWidth = inImgWrapper.size.x;\n            var outImg = outImgWrapper.data;\n            var topRowIdx = 0;\n            var bottomRowIdx = inWidth;\n            var endIdx = inImg.length;\n            var outWidth = inWidth / 2;\n            var outImgIdx = 0;\n            while(bottomRowIdx < endIdx){\n                for(var i = 0; i < outWidth; i++){\n                    outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);\n                    outImgIdx++;\n                    topRowIdx += 2;\n                    bottomRowIdx += 2;\n                }\n                topRowIdx += inWidth;\n                bottomRowIdx += inWidth;\n            }\n        }\n        function hsv2rgb(hsv) {\n            var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [\n                0,\n                0,\n                0\n            ];\n            var h = hsv[0];\n            var s = hsv[1];\n            var v = hsv[2];\n            var c = v * s;\n            var x = c * (1 - Math.abs(h / 60 % 2 - 1));\n            var m = v - c;\n            var r = 0;\n            var g = 0;\n            var b = 0;\n            if (h < 60) {\n                r = c;\n                g = x;\n            } else if (h < 120) {\n                r = x;\n                g = c;\n            } else if (h < 180) {\n                g = c;\n                b = x;\n            } else if (h < 240) {\n                g = x;\n                b = c;\n            } else if (h < 300) {\n                r = x;\n                b = c;\n            } else if (h < 360) {\n                r = c;\n                b = x;\n            }\n            // eslint-disable-next-line no-param-reassign\n            rgb[0] = (r + m) * 255 | 0;\n            // eslint-disable-next-line no-param-reassign\n            rgb[1] = (g + m) * 255 | 0;\n            // eslint-disable-next-line no-param-reassign\n            rgb[2] = (b + m) * 255 | 0;\n            return rgb;\n        }\n        function _computeDivisors(n) {\n            var largeDivisors = [];\n            var divisors = [];\n            for(var i = 1; i < Math.sqrt(n) + 1; i++){\n                if (n % i === 0) {\n                    divisors.push(i);\n                    if (i !== n / i) {\n                        largeDivisors.unshift(Math.floor(n / i));\n                    }\n                }\n            }\n            return divisors.concat(largeDivisors);\n        }\n        function _computeIntersection(arr1, arr2) {\n            var i = 0;\n            var j = 0;\n            var result = [];\n            while(i < arr1.length && j < arr2.length){\n                if (arr1[i] === arr2[j]) {\n                    result.push(arr1[i]);\n                    i++;\n                    j++;\n                } else if (arr1[i] > arr2[j]) {\n                    j++;\n                } else {\n                    i++;\n                }\n            }\n            return result;\n        }\n        function calculatePatchSize(patchSize, imgSize) {\n            var divisorsX = _computeDivisors(imgSize.x);\n            var divisorsY = _computeDivisors(imgSize.y);\n            var wideSide = Math.max(imgSize.x, imgSize.y);\n            var common = _computeIntersection(divisorsX, divisorsY);\n            var nrOfPatchesList = [\n                8,\n                10,\n                15,\n                20,\n                32,\n                60,\n                80\n            ];\n            var nrOfPatchesMap = {\n                \"x-small\": 5,\n                small: 4,\n                medium: 3,\n                large: 2,\n                \"x-large\": 1\n            };\n            var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;\n            var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];\n            var desiredPatchSize = Math.floor(wideSide / nrOfPatches);\n            var optimalPatchSize;\n            function findPatchSizeForDivisors(divisors) {\n                var i = 0;\n                var found = divisors[Math.floor(divisors.length / 2)];\n                while(i < divisors.length - 1 && divisors[i] < desiredPatchSize){\n                    i++;\n                }\n                if (i > 0) {\n                    if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {\n                        found = divisors[i - 1];\n                    } else {\n                        found = divisors[i];\n                    }\n                }\n                if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {\n                    return {\n                        x: found,\n                        y: found\n                    };\n                }\n                return null;\n            }\n            optimalPatchSize = findPatchSizeForDivisors(common);\n            if (!optimalPatchSize) {\n                optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));\n                if (!optimalPatchSize) {\n                    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));\n                }\n            }\n            return optimalPatchSize;\n        }\n        function _parseCSSDimensionValues(value) {\n            var dimension = {\n                value: parseFloat(value),\n                unit: value.indexOf(\"%\") === value.length - 1 ? \"%\" : \"%\"\n            };\n            return dimension;\n        }\n        var _dimensionsConverters = {\n            top: function top(dimension, context) {\n                return dimension.unit === \"%\" ? Math.floor(context.height * (dimension.value / 100)) : null;\n            },\n            right: function right(dimension, context) {\n                return dimension.unit === \"%\" ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;\n            },\n            bottom: function bottom(dimension, context) {\n                return dimension.unit === \"%\" ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;\n            },\n            left: function left(dimension, context) {\n                return dimension.unit === \"%\" ? Math.floor(context.width * (dimension.value / 100)) : null;\n            }\n        };\n        function computeImageArea(inputWidth, inputHeight, area) {\n            var context = {\n                width: inputWidth,\n                height: inputHeight\n            };\n            var parsedArea = Object.keys(area).reduce(function(result, key) {\n                var value = area[key];\n                var parsed = _parseCSSDimensionValues(value);\n                var calculated = _dimensionsConverters[key](parsed, context);\n                // eslint-disable-next-line no-param-reassign\n                result[key] = calculated;\n                return result;\n            }, {});\n            return {\n                sx: parsedArea.left,\n                sy: parsedArea.top,\n                sw: parsedArea.right - parsedArea.left,\n                sh: parsedArea.bottom - parsedArea.top\n            };\n        }\n    /***/ },\n    /* 13 */ /***/ function(module, exports1) {\n        function _typeof(o) {\n            \"@babel/helpers - typeof\";\n            return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                return typeof o;\n            } : function(o) {\n                return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n            }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n        }\n        module.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 14 */ /***/ function(module, exports1, __nested_webpack_require_66715__) {\n        var superPropBase = __nested_webpack_require_66715__(138);\n        function _get() {\n            if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n            } else {\n                module.exports = _get = function _get(target, property, receiver) {\n                    var base = superPropBase(target, property);\n                    if (!base) return;\n                    var desc = Object.getOwnPropertyDescriptor(base, property);\n                    if (desc.get) {\n                        return desc.get.call(arguments.length < 3 ? target : receiver);\n                    }\n                    return desc.value;\n                }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n            }\n            return _get.apply(this, arguments);\n        }\n        module.exports = _get, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 15 */ /***/ function(module, exports1) {\n        /**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */ function isObject(value) {\n            var type = typeof value;\n            return value != null && (type == \"object\" || type == \"function\");\n        }\n        module.exports = isObject;\n    /***/ },\n    /* 16 */ /***/ function(module, exports1) {\n        /**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */ var isArray = Array.isArray;\n        module.exports = isArray;\n    /***/ },\n    /* 17 */ /***/ function(module, __nested_webpack_exports__, __webpack_require__) {\n        \"use strict\";\n        // TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.\n        // XYDefinition tells us which component of a given array or object is the \"X\" and which is the \"Y\".\n        // Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.\n        /* harmony default export */ __nested_webpack_exports__[\"a\"] = {\n            drawRect: function drawRect(pos, size, ctx, style) {\n                ctx.strokeStyle = style.color;\n                ctx.fillStyle = style.color;\n                ctx.lineWidth = style.lineWidth || 1;\n                ctx.beginPath();\n                ctx.strokeRect(pos.x, pos.y, size.x, size.y);\n            },\n            drawPath: function drawPath(path, def, ctx, style) {\n                ctx.strokeStyle = style.color;\n                ctx.fillStyle = style.color;\n                ctx.lineWidth = style.lineWidth;\n                ctx.beginPath();\n                ctx.moveTo(path[0][def.x], path[0][def.y]);\n                for(var j = 1; j < path.length; j++){\n                    ctx.lineTo(path[j][def.x], path[j][def.y]);\n                }\n                ctx.closePath();\n                ctx.stroke();\n            },\n            drawImage: function drawImage(imageData, size, ctx) {\n                var canvasData = ctx.getImageData(0, 0, size.x, size.y);\n                var data = canvasData.data;\n                var canvasDataPos = data.length;\n                var imageDataPos = imageData.length;\n                if (canvasDataPos / imageDataPos !== 4) {\n                    return false;\n                }\n                while(imageDataPos--){\n                    var value = imageData[imageDataPos];\n                    data[--canvasDataPos] = 255;\n                    data[--canvasDataPos] = value;\n                    data[--canvasDataPos] = value;\n                    data[--canvasDataPos] = value;\n                }\n                ctx.putImageData(canvasData, 0, 0);\n                return true;\n            }\n        };\n    /***/ },\n    /* 18 */ /***/ function(module, exports1, __nested_webpack_require_71379__) {\n        var baseMerge = __nested_webpack_require_71379__(70), createAssigner = __nested_webpack_require_71379__(125);\n        /**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */ var merge = createAssigner(function(object, source, srcIndex) {\n            baseMerge(object, source, srcIndex);\n        });\n        module.exports = merge;\n    /***/ },\n    /* 19 */ /***/ function(module, exports1, __nested_webpack_require_72713__) {\n        var freeGlobal = __nested_webpack_require_72713__(45);\n        /** Detect free variable `self`. */ var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n        /** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function(\"return this\")();\n        module.exports = root;\n    /***/ },\n    /* 20 */ /***/ function(module, exports1) {\n        /**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */ function isObjectLike(value) {\n            return value != null && typeof value == \"object\";\n        }\n        module.exports = isObjectLike;\n    /***/ },\n    /* 21 */ /***/ function(module, __nested_webpack_exports__, __webpack_require__) {\n        \"use strict\";\n        /**\n * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization\n */ var Tracer = {\n            searchDirections: [\n                [\n                    0,\n                    1\n                ],\n                [\n                    1,\n                    1\n                ],\n                [\n                    1,\n                    0\n                ],\n                [\n                    1,\n                    -1\n                ],\n                [\n                    0,\n                    -1\n                ],\n                [\n                    -1,\n                    -1\n                ],\n                [\n                    -1,\n                    0\n                ],\n                [\n                    -1,\n                    1\n                ]\n            ],\n            create: function create(imageWrapper, labelWrapper) {\n                var imageData = imageWrapper.data;\n                var labelData = labelWrapper.data;\n                var searchDirections = this.searchDirections;\n                var width = imageWrapper.size.x;\n                var pos;\n                function _trace(current, color, label, edgelabel) {\n                    var i;\n                    var y;\n                    var x;\n                    for(i = 0; i < searchDirections.length; i++){\n                        y = current.cy + searchDirections[current.dir][0];\n                        x = current.cx + searchDirections[current.dir][1];\n                        pos = y * width + x;\n                        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {\n                            labelData[pos] = label;\n                            current.cy = y;\n                            current.cx = x;\n                            return true;\n                        }\n                        if (labelData[pos] === 0) {\n                            labelData[pos] = edgelabel;\n                        }\n                        current.dir = (current.dir + 1) % 8;\n                    }\n                    return false;\n                }\n                function vertex2D(x, y, dir) {\n                    return {\n                        dir: dir,\n                        x: x,\n                        y: y,\n                        next: null,\n                        prev: null\n                    };\n                }\n                function _contourTracing(sy, sx, label, color, edgelabel) {\n                    var Fv = null;\n                    var Cv;\n                    var P;\n                    var ldir;\n                    var current = {\n                        cx: sx,\n                        cy: sy,\n                        dir: 0\n                    };\n                    if (_trace(current, color, label, edgelabel)) {\n                        Fv = vertex2D(sx, sy, current.dir);\n                        Cv = Fv;\n                        ldir = current.dir;\n                        P = vertex2D(current.cx, current.cy, 0);\n                        P.prev = Cv;\n                        Cv.next = P;\n                        P.next = null;\n                        Cv = P;\n                        var totalPixelCount = imageWrapper.size.x * imageWrapper.size.y;\n                        var pixelCounter = 0;\n                        do {\n                            current.dir = (current.dir + 6) % 8;\n                            _trace(current, color, label, edgelabel);\n                            if (ldir !== current.dir) {\n                                Cv.dir = current.dir;\n                                P = vertex2D(current.cx, current.cy, 0);\n                                P.prev = Cv;\n                                Cv.next = P;\n                                P.next = null;\n                                Cv = P;\n                            } else {\n                                Cv.dir = ldir;\n                                Cv.x = current.cx;\n                                Cv.y = current.cy;\n                            }\n                            ldir = current.dir;\n                        }while ((current.cx !== sx || current.cy !== sy) && ++pixelCounter < totalPixelCount);\n                        Fv.prev = Cv.prev;\n                        Cv.prev.next = Fv;\n                    }\n                    return Fv;\n                }\n                return {\n                    trace: function trace(current, color, label, edgelabel) {\n                        return _trace(current, color, label, edgelabel);\n                    },\n                    contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {\n                        return _contourTracing(sy, sx, label, color, edgelabel);\n                    }\n                };\n            }\n        };\n        /* harmony default export */ __nested_webpack_exports__[\"a\"] = Tracer;\n    /***/ },\n    /* 22 */ /***/ function(module, exports1, __nested_webpack_require_78825__) {\n        var Symbol1 = __nested_webpack_require_78825__(27), getRawTag = __nested_webpack_require_78825__(83), objectToString = __nested_webpack_require_78825__(84);\n        /** `Object#toString` result references. */ var nullTag = \"[object Null]\", undefinedTag = \"[object Undefined]\";\n        /** Built-in value references. */ var symToStringTag = Symbol1 ? Symbol1.toStringTag : undefined;\n        /**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */ function baseGetTag(value) {\n            if (value == null) {\n                return value === undefined ? undefinedTag : nullTag;\n            }\n            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n        }\n        module.exports = baseGetTag;\n    /***/ },\n    /* 23 */ /***/ function(module, __nested_webpack_exports__, __nested_webpack_require_79775__) {\n        \"use strict\";\n        /* WEBPACK VAR INJECTION */ (function(global) {\n            var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_79775__(5);\n            /* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_79775__.n(gl_matrix__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_79775__(10);\n            /* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_79775__(12);\n            /* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_79775__(9);\n            /* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_79775__(17);\n            /* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_79775__(67);\n            /* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_79775__(21);\n            /* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_79775__(68);\n            gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"glMatrix\"].setMatrixArrayType(Array);\n            var _config;\n            var _currentImageWrapper;\n            var _skelImageWrapper;\n            var _subImageWrapper;\n            var _labelImageWrapper;\n            var _patchGrid;\n            var _patchLabelGrid;\n            var _imageToPatchGrid;\n            var _binaryImageWrapper;\n            var _patchSize;\n            var _canvasContainer = {\n                ctx: {\n                    binary: null\n                },\n                dom: {\n                    binary: null\n                }\n            };\n            var _numPatches = {\n                x: 0,\n                y: 0\n            };\n            var _inputImageWrapper;\n            var _skeletonizer;\n            function initBuffers() {\n                if (_config.halfSample) {\n                    _currentImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]({\n                        // eslint-disable-next-line no-bitwise\n                        x: _inputImageWrapper.size.x / 2 | 0,\n                        // eslint-disable-next-line no-bitwise\n                        y: _inputImageWrapper.size.y / 2 | 0\n                    });\n                } else {\n                    _currentImageWrapper = _inputImageWrapper;\n                }\n                _patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[\"calculatePatchSize\"])(_config.patchSize, _currentImageWrapper.size);\n                // eslint-disable-next-line no-bitwise\n                _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0;\n                // eslint-disable-next-line no-bitwise\n                _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;\n                _binaryImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](_currentImageWrapper.size, undefined, Uint8Array, false);\n                _labelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](_patchSize, undefined, Array, true);\n                var skeletonImageData = new ArrayBuffer(64 * 1024);\n                _subImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));\n                _skelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);\n                _skeletonizer = Object(_skeletonizer__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])( false ? 0 : typeof self !== \"undefined\" ? self : global, {\n                    size: _patchSize.x\n                }, skeletonImageData);\n                _imageToPatchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]({\n                    // eslint-disable-next-line no-bitwise\n                    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,\n                    // eslint-disable-next-line no-bitwise\n                    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0\n                }, undefined, Array, true);\n                _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](_imageToPatchGrid.size, undefined, undefined, true);\n                _patchLabelGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](_imageToPatchGrid.size, undefined, Int32Array, true);\n            }\n            function initCanvas() {\n                if (_config.useWorker || typeof document === \"undefined\") {\n                    return;\n                }\n                _canvasContainer.dom.binary = document.createElement(\"canvas\");\n                _canvasContainer.dom.binary.className = \"binaryBuffer\";\n                if (false) {}\n                var willReadFrequently = !!_config.willReadFrequently;\n                console.warn(\"* initCanvas willReadFrequently\", willReadFrequently, _config);\n                _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext(\"2d\", {\n                    willReadFrequently: willReadFrequently\n                });\n                _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;\n                _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;\n            }\n            /**\n * Creates a bounding box which encloses all the given patches\n * @returns {Array} The minimal bounding box\n */ function boxFromPatches(patches) {\n                var overAvg;\n                var i;\n                var j;\n                var patch;\n                var transMat;\n                var minx = _binaryImageWrapper.size.x;\n                var miny = _binaryImageWrapper.size.y;\n                var maxx = -_binaryImageWrapper.size.x;\n                var maxy = -_binaryImageWrapper.size.y;\n                var box;\n                var scale;\n                // draw all patches which are to be taken into consideration\n                overAvg = 0;\n                for(i = 0; i < patches.length; i++){\n                    patch = patches[i];\n                    overAvg += patch.rad;\n                    if (false) {}\n                }\n                overAvg /= patches.length;\n                overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;\n                if (overAvg < 0) {\n                    overAvg += 180;\n                }\n                overAvg = (180 - overAvg) * Math.PI / 180;\n                transMat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat2\"].copy(gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat2\"].create(), [\n                    Math.cos(overAvg),\n                    Math.sin(overAvg),\n                    -Math.sin(overAvg),\n                    Math.cos(overAvg)\n                ]);\n                // iterate over patches and rotate by angle\n                for(i = 0; i < patches.length; i++){\n                    patch = patches[i];\n                    for(j = 0; j < 4; j++){\n                        gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec2\"].transformMat2(patch.box[j], patch.box[j], transMat);\n                    }\n                    if (false) {}\n                }\n                // find bounding box\n                for(i = 0; i < patches.length; i++){\n                    patch = patches[i];\n                    for(j = 0; j < 4; j++){\n                        if (patch.box[j][0] < minx) {\n                            minx = patch.box[j][0];\n                        }\n                        if (patch.box[j][0] > maxx) {\n                            maxx = patch.box[j][0];\n                        }\n                        if (patch.box[j][1] < miny) {\n                            miny = patch.box[j][1];\n                        }\n                        if (patch.box[j][1] > maxy) {\n                            maxy = patch.box[j][1];\n                        }\n                    }\n                }\n                box = [\n                    [\n                        minx,\n                        miny\n                    ],\n                    [\n                        maxx,\n                        miny\n                    ],\n                    [\n                        maxx,\n                        maxy\n                    ],\n                    [\n                        minx,\n                        maxy\n                    ]\n                ];\n                if (false) {}\n                scale = _config.halfSample ? 2 : 1;\n                // reverse rotation;\n                transMat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat2\"].invert(transMat, transMat);\n                for(j = 0; j < 4; j++){\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec2\"].transformMat2(box[j], box[j], transMat);\n                }\n                if (false) {}\n                for(j = 0; j < 4; j++){\n                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec2\"].scale(box[j], box[j], scale);\n                }\n                return box;\n            }\n            /**\n * Creates a binary image of the current image\n */ function binarizeImage() {\n                Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[\"otsuThreshold\"])(_currentImageWrapper, _binaryImageWrapper);\n                _binaryImageWrapper.zeroBorder();\n                if (false) {}\n            }\n            /**\n * Iterate over the entire image\n * extract patches\n */ function findPatches() {\n                var i;\n                var j;\n                var x;\n                var y;\n                var moments;\n                var patchesFound = [];\n                var rasterizer;\n                var rasterResult;\n                var patch;\n                for(i = 0; i < _numPatches.x; i++){\n                    for(j = 0; j < _numPatches.y; j++){\n                        x = _subImageWrapper.size.x * i;\n                        y = _subImageWrapper.size.y * j;\n                        // seperate parts\n                        skeletonize(x, y);\n                        // Rasterize, find individual bars\n                        _skelImageWrapper.zeroBorder();\n                        _common_array_helper__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].init(_labelImageWrapper.data, 0);\n                        rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].create(_skelImageWrapper, _labelImageWrapper);\n                        rasterResult = rasterizer.rasterize(0);\n                        if (false) {}\n                        // calculate moments from the skeletonized patch\n                        moments = _labelImageWrapper.moments(rasterResult.count);\n                        // extract eligible patches\n                        patchesFound = patchesFound.concat(describePatch(moments, [\n                            i,\n                            j\n                        ], x, y));\n                    }\n                }\n                if (false) {}\n                return patchesFound;\n            }\n            /**\n * Finds those connected areas which contain at least 6 patches\n * and returns them ordered DESC by the number of contained patches\n * @param {Number} maxLabel\n */ function findBiggestConnectedAreas(maxLabel) {\n                var i;\n                var sum;\n                var labelHist = [];\n                var topLabels = [];\n                for(i = 0; i < maxLabel; i++){\n                    labelHist.push(0);\n                }\n                sum = _patchLabelGrid.data.length;\n                while(sum--){\n                    if (_patchLabelGrid.data[sum] > 0) {\n                        labelHist[_patchLabelGrid.data[sum] - 1]++;\n                    }\n                }\n                labelHist = labelHist.map(function(val, idx) {\n                    return {\n                        val: val,\n                        label: idx + 1\n                    };\n                });\n                labelHist.sort(function(a, b) {\n                    return b.val - a.val;\n                });\n                // extract top areas with at least 6 patches present\n                topLabels = labelHist.filter(function(el) {\n                    return el.val >= 5;\n                });\n                return topLabels;\n            }\n            /**\n *\n */ function findBoxes(topLabels, maxLabel) {\n                var i;\n                var j;\n                var sum;\n                var patches = [];\n                var patch;\n                var box;\n                var boxes = [];\n                var hsv = [\n                    0,\n                    1,\n                    1\n                ];\n                var rgb = [\n                    0,\n                    0,\n                    0\n                ];\n                for(i = 0; i < topLabels.length; i++){\n                    sum = _patchLabelGrid.data.length;\n                    patches.length = 0;\n                    while(sum--){\n                        if (_patchLabelGrid.data[sum] === topLabels[i].label) {\n                            patch = _imageToPatchGrid.data[sum];\n                            patches.push(patch);\n                        }\n                    }\n                    box = boxFromPatches(patches);\n                    if (box) {\n                        boxes.push(box);\n                        // draw patch-labels if requested\n                        if (false) {}\n                    }\n                }\n                return boxes;\n            }\n            /**\n * Find similar moments (via cluster)\n * @param {Object} moments\n */ function similarMoments(moments) {\n                var clusters = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[\"cluster\"])(moments, 0.90);\n                var topCluster = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[\"topGeneric\"])(clusters, 1, function(e) {\n                    return e.getPoints().length;\n                });\n                var points = [];\n                var result = [];\n                if (topCluster.length === 1) {\n                    points = topCluster[0].item.getPoints();\n                    for(var i = 0; i < points.length; i++){\n                        result.push(points[i].point);\n                    }\n                }\n                return result;\n            }\n            function skeletonize(x, y) {\n                _binaryImageWrapper.subImageAsCopy(_subImageWrapper, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[\"imageRef\"])(x, y));\n                _skeletonizer.skeletonize();\n                // Show skeleton if requested\n                if (false) {}\n            }\n            /**\n * Extracts and describes those patches which seem to contain a barcode pattern\n * @param {Array} moments\n * @param {Object} patchPos,\n * @param {Number} x\n * @param {Number} y\n * @returns {Array} list of patches\n */ function describePatch(moments, patchPos, x, y) {\n                var k;\n                var avg;\n                var eligibleMoments = [];\n                var matchingMoments;\n                var patch;\n                var patchesFound = [];\n                var minComponentWeight = Math.ceil(_patchSize.x / 3);\n                if (moments.length >= 2) {\n                    // only collect moments which's area covers at least minComponentWeight pixels.\n                    for(k = 0; k < moments.length; k++){\n                        if (moments[k].m00 > minComponentWeight) {\n                            eligibleMoments.push(moments[k]);\n                        }\n                    }\n                    // if at least 2 moments are found which have at least minComponentWeights covered\n                    if (eligibleMoments.length >= 2) {\n                        matchingMoments = similarMoments(eligibleMoments);\n                        avg = 0;\n                        // determine the similarity of the moments\n                        for(k = 0; k < matchingMoments.length; k++){\n                            var _matchingMoments$k$ra, _matchingMoments$k;\n                            avg += (_matchingMoments$k$ra = (_matchingMoments$k = matchingMoments[k]) === null || _matchingMoments$k === void 0 ? void 0 : _matchingMoments$k.rad) !== null && _matchingMoments$k$ra !== void 0 ? _matchingMoments$k$ra : 0;\n                        }\n                        // Only two of the moments are allowed not to fit into the equation\n                        // add the patch to the set\n                        if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {\n                            avg /= matchingMoments.length;\n                            patch = {\n                                index: patchPos[1] * _numPatches.x + patchPos[0],\n                                pos: {\n                                    x: x,\n                                    y: y\n                                },\n                                box: [\n                                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec2\"].clone([\n                                        x,\n                                        y\n                                    ]),\n                                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec2\"].clone([\n                                        x + _subImageWrapper.size.x,\n                                        y\n                                    ]),\n                                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec2\"].clone([\n                                        x + _subImageWrapper.size.x,\n                                        y + _subImageWrapper.size.y\n                                    ]),\n                                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec2\"].clone([\n                                        x,\n                                        y + _subImageWrapper.size.y\n                                    ])\n                                ],\n                                moments: matchingMoments,\n                                rad: avg,\n                                vec: gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec2\"].clone([\n                                    Math.cos(avg),\n                                    Math.sin(avg)\n                                ])\n                            };\n                            patchesFound.push(patch);\n                        }\n                    }\n                }\n                return patchesFound;\n            }\n            /**\n * finds patches which are connected and share the same orientation\n * @param {Object} patchesFound\n */ function rasterizeAngularSimilarity(patchesFound) {\n                var label = 0;\n                var threshold = 0.95;\n                var currIdx = 0;\n                var j;\n                var patch;\n                var hsv = [\n                    0,\n                    1,\n                    1\n                ];\n                var rgb = [\n                    0,\n                    0,\n                    0\n                ];\n                function notYetProcessed() {\n                    var i;\n                    for(i = 0; i < _patchLabelGrid.data.length; i++){\n                        if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {\n                            return i;\n                        }\n                    }\n                    return _patchLabelGrid.data.length;\n                }\n                function trace(currentIdx) {\n                    var x;\n                    var y;\n                    var currentPatch;\n                    var idx;\n                    var dir;\n                    var current = {\n                        x: currentIdx % _patchLabelGrid.size.x,\n                        y: currentIdx / _patchLabelGrid.size.x | 0\n                    };\n                    var similarity;\n                    if (currentIdx < _patchLabelGrid.data.length) {\n                        currentPatch = _imageToPatchGrid.data[currentIdx];\n                        // assign label\n                        _patchLabelGrid.data[currentIdx] = label;\n                        for(dir = 0; dir < _tracer__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"].searchDirections.length; dir++){\n                            y = current.y + _tracer__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"].searchDirections[dir][0];\n                            x = current.x + _tracer__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"].searchDirections[dir][1];\n                            idx = y * _patchLabelGrid.size.x + x;\n                            // continue if patch empty\n                            if (_patchGrid.data[idx] === 0) {\n                                _patchLabelGrid.data[idx] = Number.MAX_VALUE;\n                                continue;\n                            }\n                            if (_patchLabelGrid.data[idx] === 0) {\n                                similarity = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec2\"].dot(_imageToPatchGrid.data[idx].vec, currentPatch.vec));\n                                if (similarity > threshold) {\n                                    trace(idx);\n                                }\n                            }\n                        }\n                    }\n                }\n                // prepare for finding the right patches\n                _common_array_helper__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].init(_patchGrid.data, 0);\n                _common_array_helper__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].init(_patchLabelGrid.data, 0);\n                _common_array_helper__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].init(_imageToPatchGrid.data, null);\n                for(j = 0; j < patchesFound.length; j++){\n                    patch = patchesFound[j];\n                    _imageToPatchGrid.data[patch.index] = patch;\n                    _patchGrid.data[patch.index] = 1;\n                }\n                // rasterize the patches found to determine area\n                _patchGrid.zeroBorder();\n                // eslint-disable-next-line no-cond-assign\n                while((currIdx = notYetProcessed()) < _patchLabelGrid.data.length){\n                    label++;\n                    trace(currIdx);\n                }\n                // draw patch-labels if requested\n                if (false) {}\n                return label;\n            }\n            /* harmony default export */ __nested_webpack_exports__[\"a\"] = {\n                init: function init(inputImageWrapper, config) {\n                    _config = config;\n                    _inputImageWrapper = inputImageWrapper;\n                    initBuffers();\n                    initCanvas();\n                },\n                locate: function locate() {\n                    if (_config.halfSample) {\n                        Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[\"halfSample\"])(_inputImageWrapper, _currentImageWrapper);\n                    }\n                    binarizeImage();\n                    var patchesFound = findPatches();\n                    // return unless 5% or more patches are found\n                    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {\n                        return null;\n                    }\n                    // rasterrize area by comparing angular similarity;\n                    var maxLabel = rasterizeAngularSimilarity(patchesFound);\n                    if (maxLabel < 1) {\n                        return null;\n                    }\n                    // search for area with the most patches (biggest connected area)\n                    var topLabels = findBiggestConnectedAreas(maxLabel);\n                    if (topLabels.length === 0) {\n                        return null;\n                    }\n                    var boxes = findBoxes(topLabels, maxLabel);\n                    return boxes;\n                },\n                checkImageConstraints: function checkImageConstraints(inputStream, config) {\n                    var patchSize;\n                    var width = inputStream.getWidth();\n                    var height = inputStream.getHeight();\n                    var thisHalfSample = config.halfSample ? 0.5 : 1;\n                    var area;\n                    // calculate width and height based on area\n                    if (inputStream.getConfig().area) {\n                        area = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[\"computeImageArea\"])(width, height, inputStream.getConfig().area);\n                        inputStream.setTopRight({\n                            x: area.sx,\n                            y: area.sy\n                        });\n                        inputStream.setCanvasSize({\n                            x: width,\n                            y: height\n                        });\n                        width = area.sw;\n                        height = area.sh;\n                    }\n                    var size = {\n                        x: Math.floor(width * thisHalfSample),\n                        y: Math.floor(height * thisHalfSample)\n                    };\n                    patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[\"calculatePatchSize\"])(config.patchSize, size);\n                    if (false) {}\n                    inputStream.setWidth(Math.max(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x), patchSize.x));\n                    inputStream.setHeight(Math.max(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y), patchSize.y));\n                    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {\n                        return true;\n                    }\n                    throw new Error(\"Image dimensions do not comply with the current settings: Width (\".concat(width, \" )and height (\").concat(height, \") must a multiple of \").concat(patchSize.x));\n                }\n            };\n        /* WEBPACK VAR INJECTION */ }).call(this, __nested_webpack_require_79775__(46));\n    /***/ },\n    /* 24 */ /***/ function(module, exports1, __nested_webpack_require_106077__) {\n        var listCacheClear = __nested_webpack_require_106077__(72), listCacheDelete = __nested_webpack_require_106077__(73), listCacheGet = __nested_webpack_require_106077__(74), listCacheHas = __nested_webpack_require_106077__(75), listCacheSet = __nested_webpack_require_106077__(76);\n        /**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function ListCache(entries) {\n            var index = -1, length = entries == null ? 0 : entries.length;\n            this.clear();\n            while(++index < length){\n                var entry = entries[index];\n                this.set(entry[0], entry[1]);\n            }\n        }\n        // Add methods to `ListCache`.\n        ListCache.prototype.clear = listCacheClear;\n        ListCache.prototype[\"delete\"] = listCacheDelete;\n        ListCache.prototype.get = listCacheGet;\n        ListCache.prototype.has = listCacheHas;\n        ListCache.prototype.set = listCacheSet;\n        module.exports = ListCache;\n    /***/ },\n    /* 25 */ /***/ function(module, exports1, __nested_webpack_require_107124__) {\n        var eq = __nested_webpack_require_107124__(26);\n        /**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */ function assocIndexOf(array, key) {\n            var length = array.length;\n            while(length--){\n                if (eq(array[length][0], key)) {\n                    return length;\n                }\n            }\n            return -1;\n        }\n        module.exports = assocIndexOf;\n    /***/ },\n    /* 26 */ /***/ function(module, exports1) {\n        /**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */ function eq(value, other) {\n            return value === other || value !== value && other !== other;\n        }\n        module.exports = eq;\n    /***/ },\n    /* 27 */ /***/ function(module, exports1, __nested_webpack_require_108698__) {\n        var root = __nested_webpack_require_108698__(19);\n        /** Built-in value references. */ var Symbol1 = root.Symbol;\n        module.exports = Symbol1;\n    /***/ },\n    /* 28 */ /***/ function(module, exports1, __nested_webpack_require_108927__) {\n        var getNative = __nested_webpack_require_108927__(35);\n        /* Built-in method references that are verified to be native. */ var nativeCreate = getNative(Object, \"create\");\n        module.exports = nativeCreate;\n    /***/ },\n    /* 29 */ /***/ function(module, exports1, __nested_webpack_require_109218__) {\n        var isKeyable = __nested_webpack_require_109218__(97);\n        /**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */ function getMapData(map, key) {\n            var data = map.__data__;\n            return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n        }\n        module.exports = getMapData;\n    /***/ },\n    /* 30 */ /***/ function(module, exports1, __nested_webpack_require_109742__) {\n        var baseIsArguments = __nested_webpack_require_109742__(112), isObjectLike = __nested_webpack_require_109742__(20);\n        /** Used for built-in method references. */ var objectProto = Object.prototype;\n        /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n        /** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;\n        /**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */ var isArguments = baseIsArguments(function() {\n            return arguments;\n        }()) ? baseIsArguments : function(value) {\n            return isObjectLike(value) && hasOwnProperty.call(value, \"callee\") && !propertyIsEnumerable.call(value, \"callee\");\n        };\n        module.exports = isArguments;\n    /***/ },\n    /* 31 */ /***/ function(module, exports1) {\n        /** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;\n        /** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\\d*)$/;\n        /**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */ function isIndex(value, length) {\n            var type = typeof value;\n            length = length == null ? MAX_SAFE_INTEGER : length;\n            return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n        }\n        module.exports = isIndex;\n    /***/ },\n    /* 32 */ /***/ function(module, exports1, __nested_webpack_require_111780__) {\n        var isArray = __nested_webpack_require_111780__(16), isKey = __nested_webpack_require_111780__(145), stringToPath = __nested_webpack_require_111780__(146), toString = __nested_webpack_require_111780__(149);\n        /**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */ function castPath(value, object) {\n            if (isArray(value)) {\n                return value;\n            }\n            return isKey(value, object) ? [\n                value\n            ] : stringToPath(toString(value));\n        }\n        module.exports = castPath;\n    /***/ },\n    /* 33 */ /***/ function(module, exports1, __nested_webpack_require_112530__) {\n        var arrayWithHoles = __nested_webpack_require_112530__(133);\n        var iterableToArrayLimit = __nested_webpack_require_112530__(134);\n        var unsupportedIterableToArray = __nested_webpack_require_112530__(60);\n        var nonIterableRest = __nested_webpack_require_112530__(135);\n        function _slicedToArray(arr, i) {\n            return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n        }\n        module.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 34 */ /***/ function(module, exports1, __nested_webpack_require_113152__) {\n        var arrayWithoutHoles = __nested_webpack_require_113152__(139);\n        var iterableToArray = __nested_webpack_require_113152__(140);\n        var unsupportedIterableToArray = __nested_webpack_require_113152__(60);\n        var nonIterableSpread = __nested_webpack_require_113152__(141);\n        function _toConsumableArray(arr) {\n            return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n        }\n        module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 35 */ /***/ function(module, exports1, __nested_webpack_require_113773__) {\n        var baseIsNative = __nested_webpack_require_113773__(82), getValue = __nested_webpack_require_113773__(88);\n        /**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */ function getNative(object, key) {\n            var value = getValue(object, key);\n            return baseIsNative(value) ? value : undefined;\n        }\n        module.exports = getNative;\n    /***/ },\n    /* 36 */ /***/ function(module, exports1, __nested_webpack_require_114382__) {\n        var baseGetTag = __nested_webpack_require_114382__(22), isObject = __nested_webpack_require_114382__(15);\n        /** `Object#toString` result references. */ var asyncTag = \"[object AsyncFunction]\", funcTag = \"[object Function]\", genTag = \"[object GeneratorFunction]\", proxyTag = \"[object Proxy]\";\n        /**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */ function isFunction(value) {\n            if (!isObject(value)) {\n                return false;\n            }\n            // The use of `Object#toString` avoids issues with the `typeof` operator\n            // in Safari 9 which returns 'object' for typed arrays and other constructors.\n            var tag = baseGetTag(value);\n            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n        }\n        module.exports = isFunction;\n    /***/ },\n    /* 37 */ /***/ function(module, exports1, __nested_webpack_require_115551__) {\n        var defineProperty = __nested_webpack_require_115551__(49);\n        /**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */ function baseAssignValue(object, key, value) {\n            if (key == \"__proto__\" && defineProperty) {\n                defineProperty(object, key, {\n                    \"configurable\": true,\n                    \"enumerable\": true,\n                    \"value\": value,\n                    \"writable\": true\n                });\n            } else {\n                object[key] = value;\n            }\n        }\n        module.exports = baseAssignValue;\n    /***/ },\n    /* 38 */ /***/ function(module, exports1) {\n        module.exports = function(module) {\n            if (!module.webpackPolyfill) {\n                module.deprecate = function() {};\n                module.paths = [];\n                // module.parent = undefined by default\n                if (!module.children) module.children = [];\n                Object.defineProperty(module, \"loaded\", {\n                    enumerable: true,\n                    get: function() {\n                        return module.l;\n                    }\n                });\n                Object.defineProperty(module, \"id\", {\n                    enumerable: true,\n                    get: function() {\n                        return module.i;\n                    }\n                });\n                module.webpackPolyfill = 1;\n            }\n            return module;\n        };\n    /***/ },\n    /* 39 */ /***/ function(module, exports1, __nested_webpack_require_117280__) {\n        var isFunction = __nested_webpack_require_117280__(36), isLength = __nested_webpack_require_117280__(40);\n        /**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */ function isArrayLike(value) {\n            return value != null && isLength(value.length) && !isFunction(value);\n        }\n        module.exports = isArrayLike;\n    /***/ },\n    /* 40 */ /***/ function(module, exports1) {\n        /** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;\n        /**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */ function isLength(value) {\n            return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n        }\n        module.exports = isLength;\n    /***/ },\n    /* 41 */ /***/ function(module, exports1) {\n        function _setPrototypeOf(o, p) {\n            module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                o.__proto__ = p;\n                return o;\n            }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n            return _setPrototypeOf(o, p);\n        }\n        module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 42 */ /***/ function(module, exports1, __nested_webpack_require_119690__) {\n        var baseGetTag = __nested_webpack_require_119690__(22), isObjectLike = __nested_webpack_require_119690__(20);\n        /** `Object#toString` result references. */ var symbolTag = \"[object Symbol]\";\n        /**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */ function isSymbol(value) {\n            return typeof value == \"symbol\" || isObjectLike(value) && baseGetTag(value) == symbolTag;\n        }\n        module.exports = isSymbol;\n    /***/ },\n    /* 43 */ /***/ function(module, exports1, __nested_webpack_require_120488__) {\n        var isSymbol = __nested_webpack_require_120488__(42);\n        /** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;\n        /**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */ function toKey(value) {\n            if (typeof value == \"string\" || isSymbol(value)) {\n                return value;\n            }\n            var result = value + \"\";\n            return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n        }\n        module.exports = toKey;\n    /***/ },\n    /* 44 */ /***/ function(module, exports1, __nested_webpack_require_121178__) {\n        var getNative = __nested_webpack_require_121178__(35), root = __nested_webpack_require_121178__(19);\n        /* Built-in method references that are verified to be native. */ var Map1 = getNative(root, \"Map\");\n        module.exports = Map1;\n    /***/ },\n    /* 45 */ /***/ function(module, exports1, __nested_webpack_require_121480__) {\n        /* WEBPACK VAR INJECTION */ (function(global) {\n            var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n            module.exports = freeGlobal;\n        /* WEBPACK VAR INJECTION */ }).call(this, __nested_webpack_require_121480__(46));\n    /***/ },\n    /* 46 */ /***/ function(module, exports1) {\n        var g;\n        // This works in non-strict mode\n        g = function() {\n            return this;\n        }();\n        try {\n            // This works if eval is allowed (see CSP)\n            g = g || new Function(\"return this\")();\n        } catch (e) {\n            // This works if the window reference is available\n            if (false) {}\n        }\n        // g can still be undefined, but nothing to do about it...\n        // We return undefined, instead of nothing here, so it's\n        // easier to handle this case. if(!global) { ...}\n        module.exports = g;\n    /***/ },\n    /* 47 */ /***/ function(module, exports1, __nested_webpack_require_122507__) {\n        var mapCacheClear = __nested_webpack_require_122507__(89), mapCacheDelete = __nested_webpack_require_122507__(96), mapCacheGet = __nested_webpack_require_122507__(98), mapCacheHas = __nested_webpack_require_122507__(99), mapCacheSet = __nested_webpack_require_122507__(100);\n        /**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function MapCache(entries) {\n            var index = -1, length = entries == null ? 0 : entries.length;\n            this.clear();\n            while(++index < length){\n                var entry = entries[index];\n                this.set(entry[0], entry[1]);\n            }\n        }\n        // Add methods to `MapCache`.\n        MapCache.prototype.clear = mapCacheClear;\n        MapCache.prototype[\"delete\"] = mapCacheDelete;\n        MapCache.prototype.get = mapCacheGet;\n        MapCache.prototype.has = mapCacheHas;\n        MapCache.prototype.set = mapCacheSet;\n        module.exports = MapCache;\n    /***/ },\n    /* 48 */ /***/ function(module, exports1, __nested_webpack_require_123560__) {\n        var baseAssignValue = __nested_webpack_require_123560__(37), eq = __nested_webpack_require_123560__(26);\n        /**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */ function assignMergeValue(object, key, value) {\n            if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {\n                baseAssignValue(object, key, value);\n            }\n        }\n        module.exports = assignMergeValue;\n    /***/ },\n    /* 49 */ /***/ function(module, exports1, __nested_webpack_require_124274__) {\n        var getNative = __nested_webpack_require_124274__(35);\n        var defineProperty = function() {\n            try {\n                var func = getNative(Object, \"defineProperty\");\n                func({}, \"\", {});\n                return func;\n            } catch (e) {}\n        }();\n        module.exports = defineProperty;\n    /***/ },\n    /* 50 */ /***/ function(module, exports1, __nested_webpack_require_124673__) {\n        var overArg = __nested_webpack_require_124673__(111);\n        /** Built-in value references. */ var getPrototype = overArg(Object.getPrototypeOf, Object);\n        module.exports = getPrototype;\n    /***/ },\n    /* 51 */ /***/ function(module, exports1) {\n        /** Used for built-in method references. */ var objectProto = Object.prototype;\n        /**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */ function isPrototype(value) {\n            var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto;\n            return value === proto;\n        }\n        module.exports = isPrototype;\n    /***/ },\n    /* 52 */ /***/ function(module, exports1, __nested_webpack_require_125525__) {\n        /* WEBPACK VAR INJECTION */ (function(module) {\n            var root = __nested_webpack_require_125525__(19), stubFalse = __nested_webpack_require_125525__(114);\n            /** Detect free variable `exports`. */ var freeExports =  true && exports1 && !exports1.nodeType && exports1;\n            /** Detect free variable `module`. */ var freeModule = freeExports && typeof module == \"object\" && module && !module.nodeType && module;\n            /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n            /** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined;\n            /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n            /**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */ var isBuffer = nativeIsBuffer || stubFalse;\n            module.exports = isBuffer;\n        /* WEBPACK VAR INJECTION */ }).call(this, __nested_webpack_require_125525__(38)(module));\n    /***/ },\n    /* 53 */ /***/ function(module, exports1, __nested_webpack_require_126934__) {\n        var baseIsTypedArray = __nested_webpack_require_126934__(116), baseUnary = __nested_webpack_require_126934__(117), nodeUtil = __nested_webpack_require_126934__(118);\n        /* Node.js helper references. */ var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n        /**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */ var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n        module.exports = isTypedArray;\n    /***/ },\n    /* 54 */ /***/ function(module, exports1) {\n        /**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */ function safeGet(object, key) {\n            if (key === \"constructor\" && typeof object[key] === \"function\") {\n                return;\n            }\n            if (key == \"__proto__\") {\n                return;\n            }\n            return object[key];\n        }\n        module.exports = safeGet;\n    /***/ },\n    /* 55 */ /***/ function(module, exports1, __nested_webpack_require_128341__) {\n        var baseAssignValue = __nested_webpack_require_128341__(37), eq = __nested_webpack_require_128341__(26);\n        /** Used for built-in method references. */ var objectProto = Object.prototype;\n        /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n        /**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */ function assignValue(object, key, value) {\n            var objValue = object[key];\n            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n                baseAssignValue(object, key, value);\n            }\n        }\n        module.exports = assignValue;\n    /***/ },\n    /* 56 */ /***/ function(module, exports1, __nested_webpack_require_129398__) {\n        var arrayLikeKeys = __nested_webpack_require_129398__(121), baseKeysIn = __nested_webpack_require_129398__(123), isArrayLike = __nested_webpack_require_129398__(39);\n        /**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */ function keysIn(object) {\n            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n        }\n        module.exports = keysIn;\n    /***/ },\n    /* 57 */ /***/ function(module, exports1) {\n        /**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */ function identity(value) {\n            return value;\n        }\n        module.exports = identity;\n    /***/ },\n    /* 58 */ /***/ function(module, exports1, __nested_webpack_require_130750__) {\n        var apply = __nested_webpack_require_130750__(127);\n        /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;\n        /**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */ function overRest(func, start, transform) {\n            start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n            return function() {\n                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);\n                while(++index < length){\n                    array[index] = args[start + index];\n                }\n                index = -1;\n                var otherArgs = Array(start + 1);\n                while(++index < start){\n                    otherArgs[index] = args[index];\n                }\n                otherArgs[start] = transform(array);\n                return apply(func, this, otherArgs);\n            };\n        }\n        module.exports = overRest;\n    /***/ },\n    /* 59 */ /***/ function(module, exports1, __nested_webpack_require_132105__) {\n        var baseSetToString = __nested_webpack_require_132105__(128), shortOut = __nested_webpack_require_132105__(130);\n        /**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */ var setToString = shortOut(baseSetToString);\n        module.exports = setToString;\n    /***/ },\n    /* 60 */ /***/ function(module, exports1, __nested_webpack_require_132594__) {\n        var arrayLikeToArray = __nested_webpack_require_132594__(61);\n        function _unsupportedIterableToArray(o, minLen) {\n            if (!o) return;\n            if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n            var n = Object.prototype.toString.call(o).slice(8, -1);\n            if (n === \"Object\" && o.constructor) n = o.constructor.name;\n            if (n === \"Map\" || n === \"Set\") return Array.from(o);\n            if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n        }\n        module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 61 */ /***/ function(module, exports1) {\n        function _arrayLikeToArray(arr, len) {\n            if (len == null || len > arr.length) len = arr.length;\n            for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n            return arr2;\n        }\n        module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 62 */ /***/ function(module, exports1, __nested_webpack_require_133780__) {\n        var _typeof = __nested_webpack_require_133780__(13)[\"default\"];\n        var toPrimitive = __nested_webpack_require_133780__(136);\n        function _toPropertyKey(arg) {\n            var key = toPrimitive(arg, \"string\");\n            return _typeof(key) === \"symbol\" ? key : String(key);\n        }\n        module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 63 */ /***/ function(module, exports1, __nested_webpack_require_134256__) {\n        var basePick = __nested_webpack_require_134256__(142), flatRest = __nested_webpack_require_134256__(156);\n        /**\n * Creates an object composed of the picked `object` properties.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to pick.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pick(object, ['a', 'c']);\n * // => { 'a': 1, 'c': 3 }\n */ var pick = flatRest(function(object, paths) {\n            return object == null ? {} : basePick(object, paths);\n        });\n        module.exports = pick;\n    /***/ },\n    /* 64 */ /***/ function(module, exports1, __nested_webpack_require_135007__) {\n        var getPrototypeOf = __nested_webpack_require_135007__(2);\n        var setPrototypeOf = __nested_webpack_require_135007__(41);\n        var isNativeFunction = __nested_webpack_require_135007__(161);\n        var construct = __nested_webpack_require_135007__(162);\n        function _wrapNativeSuper(Class) {\n            var _cache = typeof Map === \"function\" ? new Map() : undefined;\n            module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n                if (Class === null || !isNativeFunction(Class)) return Class;\n                if (typeof Class !== \"function\") {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                if (typeof _cache !== \"undefined\") {\n                    if (_cache.has(Class)) return _cache.get(Class);\n                    _cache.set(Class, Wrapper);\n                }\n                function Wrapper() {\n                    return construct(Class, arguments, getPrototypeOf(this).constructor);\n                }\n                Wrapper.prototype = Object.create(Class.prototype, {\n                    constructor: {\n                        value: Wrapper,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                return setPrototypeOf(Wrapper, Class);\n            }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n            return _wrapNativeSuper(Class);\n        }\n        module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 65 */ /***/ function(module, exports1, __nested_webpack_require_136715__) {\n        // NOTE FOR ANYONE IN HERE IN THE FUTURE: This module is used when the module is built for use in Node.\n        // Webpack.config.js explicitly REPLACES this module with the file called frame_grabber_browser when it is packing the Browser distribution.\n        var CVUtils = __nested_webpack_require_136715__(12);\n        var Ndarray = __nested_webpack_require_136715__(164);\n        var Interp2D = __nested_webpack_require_136715__(165).d2;\n        var FrameGrabber = {};\n        FrameGrabber.create = function(inputStream, canvas) {\n            // console.warn('*** FrameGrabberNode create()');\n            var _that = {};\n            var _videoSize = CVUtils.imageRef(inputStream.getRealWidth(), inputStream.getRealHeight());\n            var _canvasSize = inputStream.getCanvasSize();\n            var _size = CVUtils.imageRef(inputStream.getWidth(), inputStream.getHeight());\n            var _topRight = inputStream.getTopRight();\n            var _data = new Uint8Array(_size.x * _size.y);\n            var _grayData = new Uint8Array(_videoSize.x * _videoSize.y);\n            var _canvasData = new Uint8Array(_canvasSize.x * _canvasSize.y);\n            /* eslint-disable new-cap */ var _grayImageArray = Ndarray(_grayData, [\n                _videoSize.y,\n                _videoSize.x\n            ]).transpose(1, 0);\n            var _canvasImageArray = Ndarray(_canvasData, [\n                _canvasSize.y,\n                _canvasSize.x\n            ]).transpose(1, 0);\n            var _targetImageArray = _canvasImageArray.hi(_topRight.x + _size.x, _topRight.y + _size.y).lo(_topRight.x, _topRight.y);\n            var _stepSizeX = _videoSize.x / _canvasSize.x;\n            var _stepSizeY = _videoSize.y / _canvasSize.y;\n            if (false) {}\n            /**\n   * Uses the given array as frame-buffer\n   */ _that.attachData = function(data) {\n                _data = data;\n            };\n            /**\n   * Returns the used frame-buffer\n   */ _that.getData = function() {\n                return _data;\n            };\n            /**\n   * Fetches a frame from the input-stream and puts into the frame-buffer.\n   * The image-data is converted to gray-scale and then half-sampled if configured.\n   */ _that.grab = function() {\n                var frame = inputStream.getFrame();\n                if (frame) {\n                    this.scaleAndCrop(frame);\n                    return true;\n                }\n                return false;\n            };\n            // eslint-disable-next-line\n            _that.scaleAndCrop = function(frame) {\n                // 1. compute full-sized gray image\n                CVUtils.computeGray(frame.data, _grayData);\n                // 2. interpolate\n                for(var y = 0; y < _canvasSize.y; y++){\n                    for(var x = 0; x < _canvasSize.x; x++){\n                        // eslint-disable-next-line no-bitwise\n                        _canvasImageArray.set(x, y, Interp2D(_grayImageArray, x * _stepSizeX, y * _stepSizeY) | 0);\n                    }\n                }\n                // targetImageArray must be equal to targetSize\n                if (_targetImageArray.shape[0] !== _size.x || _targetImageArray.shape[1] !== _size.y) {\n                    throw new Error(\"Shapes do not match!\");\n                }\n                // 3. crop\n                for(var _y = 0; _y < _size.y; _y++){\n                    for(var _x = 0; _x < _size.x; _x++){\n                        _data[_y * _size.x + _x] = _targetImageArray.get(_x, _y);\n                    }\n                }\n            };\n            _that.getSize = function() {\n                return _size;\n            };\n            return _that;\n        };\n        module.exports = FrameGrabber;\n    /***/ },\n    /* 66 */ /***/ function(module, exports1) {\n        module.exports = __webpack_require__(/*! get-pixels */ \"(ssr)/./node_modules/get-pixels/node-pixels.js\");\n    /***/ },\n    /* 67 */ /***/ function(module, __nested_webpack_exports__, __nested_webpack_require_140591__) {\n        \"use strict\";\n        /* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_140591__(21);\n        /**\n * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization\n */ var Rasterizer = {\n            createContour2D: function createContour2D() {\n                return {\n                    dir: null,\n                    index: null,\n                    firstVertex: null,\n                    insideContours: null,\n                    nextpeer: null,\n                    prevpeer: null\n                };\n            },\n            CONTOUR_DIR: {\n                CW_DIR: 0,\n                CCW_DIR: 1,\n                UNKNOWN_DIR: 2\n            },\n            DIR: {\n                OUTSIDE_EDGE: -32767,\n                INSIDE_EDGE: -32766\n            },\n            create: function create(imageWrapper, labelWrapper) {\n                var imageData = imageWrapper.data;\n                var labelData = labelWrapper.data;\n                var width = imageWrapper.size.x;\n                var height = imageWrapper.size.y;\n                var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].create(imageWrapper, labelWrapper);\n                return {\n                    rasterize: function rasterize(depthlabel) {\n                        var color;\n                        var bc;\n                        var lc;\n                        var labelindex;\n                        var cx;\n                        var cy;\n                        var colorMap = [];\n                        var vertex;\n                        var p;\n                        var cc;\n                        var sc;\n                        var pos;\n                        var connectedCount = 0;\n                        var i;\n                        for(i = 0; i < 400; i++){\n                            colorMap[i] = 0;\n                        }\n                        colorMap[0] = imageData[0];\n                        cc = null;\n                        for(cy = 1; cy < height - 1; cy++){\n                            labelindex = 0;\n                            bc = colorMap[0];\n                            for(cx = 1; cx < width - 1; cx++){\n                                pos = cy * width + cx;\n                                if (labelData[pos] === 0) {\n                                    color = imageData[pos];\n                                    if (color !== bc) {\n                                        if (labelindex === 0) {\n                                            lc = connectedCount + 1;\n                                            colorMap[lc] = color;\n                                            bc = color;\n                                            vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);\n                                            if (vertex !== null) {\n                                                connectedCount++;\n                                                labelindex = lc;\n                                                p = Rasterizer.createContour2D();\n                                                p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;\n                                                p.index = labelindex;\n                                                p.firstVertex = vertex;\n                                                p.nextpeer = cc;\n                                                p.insideContours = null;\n                                                if (cc !== null) {\n                                                    cc.prevpeer = p;\n                                                }\n                                                cc = p;\n                                            }\n                                        } else {\n                                            vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);\n                                            if (vertex !== null) {\n                                                p = Rasterizer.createContour2D();\n                                                p.firstVertex = vertex;\n                                                p.insideContours = null;\n                                                if (depthlabel === 0) {\n                                                    p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;\n                                                } else {\n                                                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;\n                                                }\n                                                p.index = depthlabel;\n                                                sc = cc;\n                                                while(sc !== null && sc.index !== labelindex){\n                                                    sc = sc.nextpeer;\n                                                }\n                                                if (sc !== null) {\n                                                    p.nextpeer = sc.insideContours;\n                                                    if (sc.insideContours !== null) {\n                                                        sc.insideContours.prevpeer = p;\n                                                    }\n                                                    sc.insideContours = p;\n                                                }\n                                            }\n                                        }\n                                    } else {\n                                        labelData[pos] = labelindex;\n                                    }\n                                } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {\n                                    labelindex = 0;\n                                    if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {\n                                        bc = imageData[pos];\n                                    } else {\n                                        bc = colorMap[0];\n                                    }\n                                } else {\n                                    labelindex = labelData[pos];\n                                    bc = colorMap[labelindex];\n                                }\n                            }\n                        }\n                        sc = cc;\n                        while(sc !== null){\n                            sc.index = depthlabel;\n                            sc = sc.nextpeer;\n                        }\n                        return {\n                            cc: cc,\n                            count: connectedCount\n                        };\n                    },\n                    debug: {\n                        drawContour: function drawContour(canvas, firstContour) {\n                            var ctx = canvas.getContext(\"2d\");\n                            var pq = firstContour;\n                            var iq;\n                            var q;\n                            var p;\n                            ctx.strokeStyle = \"red\";\n                            ctx.fillStyle = \"red\";\n                            ctx.lineWidth = 1;\n                            if (pq !== null) {\n                                iq = pq.insideContours;\n                            } else {\n                                iq = null;\n                            }\n                            while(pq !== null){\n                                if (iq !== null) {\n                                    q = iq;\n                                    iq = iq.nextpeer;\n                                } else {\n                                    q = pq;\n                                    pq = pq.nextpeer;\n                                    if (pq !== null) {\n                                        iq = pq.insideContours;\n                                    } else {\n                                        iq = null;\n                                    }\n                                }\n                                switch(q.dir){\n                                    case Rasterizer.CONTOUR_DIR.CW_DIR:\n                                        ctx.strokeStyle = \"red\";\n                                        break;\n                                    case Rasterizer.CONTOUR_DIR.CCW_DIR:\n                                        ctx.strokeStyle = \"blue\";\n                                        break;\n                                    case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:\n                                        ctx.strokeStyle = \"green\";\n                                        break;\n                                }\n                                p = q.firstVertex;\n                                ctx.beginPath();\n                                ctx.moveTo(p.x, p.y);\n                                do {\n                                    p = p.next;\n                                    ctx.lineTo(p.x, p.y);\n                                }while (p !== q.firstVertex);\n                                ctx.stroke();\n                            }\n                        }\n                    }\n                };\n            }\n        };\n        /* harmony default export */ __nested_webpack_exports__[\"a\"] = Rasterizer;\n    /***/ },\n    /* 68 */ /***/ function(module, __nested_webpack_exports__, __webpack_require__) {\n        \"use strict\";\n        /* eslint-disable no-param-reassign */ /* eslint-disable no-bitwise */ /* eslint-disable eqeqeq */ /* @preserve ASM BEGIN */ function Skeletonizer(stdlib, foreign, buffer) {\n            \"use asm\";\n            var images = new stdlib.Uint8Array(buffer);\n            var size = foreign.size | 0;\n            var imul = stdlib.Math.imul;\n            function erode(inImagePtr, outImagePtr) {\n                inImagePtr |= 0;\n                outImagePtr |= 0;\n                var v = 0;\n                var u = 0;\n                var sum = 0;\n                var yStart1 = 0;\n                var yStart2 = 0;\n                var xStart1 = 0;\n                var xStart2 = 0;\n                var offset = 0;\n                for(v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0){\n                    offset = offset + size | 0;\n                    for(u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0){\n                        yStart1 = offset - size | 0;\n                        yStart2 = offset + size | 0;\n                        xStart1 = u - 1 | 0;\n                        xStart2 = u + 1 | 0;\n                        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;\n                        if ((sum | 0) == (5 | 0)) {\n                            images[outImagePtr + offset + u | 0] = 1;\n                        } else {\n                            images[outImagePtr + offset + u | 0] = 0;\n                        }\n                    }\n                }\n            }\n            function subtract(aImagePtr, bImagePtr, outImagePtr) {\n                aImagePtr |= 0;\n                bImagePtr |= 0;\n                outImagePtr |= 0;\n                var length = 0;\n                length = imul(size, size) | 0;\n                while((length | 0) > 0){\n                    length = length - 1 | 0;\n                    images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;\n                }\n            }\n            function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {\n                aImagePtr |= 0;\n                bImagePtr |= 0;\n                outImagePtr |= 0;\n                var length = 0;\n                length = imul(size, size) | 0;\n                while((length | 0) > 0){\n                    length = length - 1 | 0;\n                    images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;\n                }\n            }\n            function countNonZero(imagePtr) {\n                imagePtr |= 0;\n                var sum = 0;\n                var length = 0;\n                length = imul(size, size) | 0;\n                while((length | 0) > 0){\n                    length = length - 1 | 0;\n                    sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;\n                }\n                return sum | 0;\n            }\n            function init(imagePtr, value) {\n                imagePtr |= 0;\n                value |= 0;\n                var length = 0;\n                length = imul(size, size) | 0;\n                while((length | 0) > 0){\n                    length = length - 1 | 0;\n                    images[imagePtr + length | 0] = value;\n                }\n            }\n            function dilate(inImagePtr, outImagePtr) {\n                inImagePtr |= 0;\n                outImagePtr |= 0;\n                var v = 0;\n                var u = 0;\n                var sum = 0;\n                var yStart1 = 0;\n                var yStart2 = 0;\n                var xStart1 = 0;\n                var xStart2 = 0;\n                var offset = 0;\n                for(v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0){\n                    offset = offset + size | 0;\n                    for(u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0){\n                        yStart1 = offset - size | 0;\n                        yStart2 = offset + size | 0;\n                        xStart1 = u - 1 | 0;\n                        xStart2 = u + 1 | 0;\n                        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;\n                        if ((sum | 0) > (0 | 0)) {\n                            images[outImagePtr + offset + u | 0] = 1;\n                        } else {\n                            images[outImagePtr + offset + u | 0] = 0;\n                        }\n                    }\n                }\n            }\n            function memcpy(srcImagePtr, dstImagePtr) {\n                srcImagePtr |= 0;\n                dstImagePtr |= 0;\n                var length = 0;\n                length = imul(size, size) | 0;\n                while((length | 0) > 0){\n                    length = length - 1 | 0;\n                    images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;\n                }\n            }\n            function zeroBorder(imagePtr) {\n                imagePtr |= 0;\n                var x = 0;\n                var y = 0;\n                for(x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0){\n                    images[imagePtr + x | 0] = 0;\n                    images[imagePtr + y | 0] = 0;\n                    y = y + size - 1 | 0;\n                    images[imagePtr + y | 0] = 0;\n                    y = y + 1 | 0;\n                }\n                for(x = 0; (x | 0) < (size | 0); x = x + 1 | 0){\n                    images[imagePtr + y | 0] = 0;\n                    y = y + 1 | 0;\n                }\n            }\n            function skeletonize() {\n                var subImagePtr = 0;\n                var erodedImagePtr = 0;\n                var tempImagePtr = 0;\n                var skelImagePtr = 0;\n                var sum = 0;\n                var done = 0;\n                erodedImagePtr = imul(size, size) | 0;\n                tempImagePtr = erodedImagePtr + erodedImagePtr | 0;\n                skelImagePtr = tempImagePtr + erodedImagePtr | 0;\n                // init skel-image\n                init(skelImagePtr, 0);\n                zeroBorder(subImagePtr);\n                do {\n                    erode(subImagePtr, erodedImagePtr);\n                    dilate(erodedImagePtr, tempImagePtr);\n                    subtract(subImagePtr, tempImagePtr, tempImagePtr);\n                    bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);\n                    memcpy(erodedImagePtr, subImagePtr);\n                    sum = countNonZero(subImagePtr) | 0;\n                    done = (sum | 0) == 0 | 0;\n                }while (!done);\n            }\n            return {\n                skeletonize: skeletonize\n            };\n        }\n        /* @preserve ASM END */ /* harmony default export */ __nested_webpack_exports__[\"a\"] = Skeletonizer;\n    /* eslint-enable eqeqeq */ /***/ },\n    /* 69 */ /***/ function(module, exports1, __nested_webpack_require_157216__) {\n        module.exports = __nested_webpack_require_157216__(166);\n    /***/ },\n    /* 70 */ /***/ function(module, exports1, __nested_webpack_require_157349__) {\n        var Stack = __nested_webpack_require_157349__(71), assignMergeValue = __nested_webpack_require_157349__(48), baseFor = __nested_webpack_require_157349__(101), baseMergeDeep = __nested_webpack_require_157349__(103), isObject = __nested_webpack_require_157349__(15), keysIn = __nested_webpack_require_157349__(56), safeGet = __nested_webpack_require_157349__(54);\n        /**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */ function baseMerge(object, source, srcIndex, customizer, stack) {\n            if (object === source) {\n                return;\n            }\n            baseFor(source, function(srcValue, key) {\n                stack || (stack = new Stack());\n                if (isObject(srcValue)) {\n                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n                } else {\n                    var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + \"\", object, source, stack) : undefined;\n                    if (newValue === undefined) {\n                        newValue = srcValue;\n                    }\n                    assignMergeValue(object, key, newValue);\n                }\n            }, keysIn);\n        }\n        module.exports = baseMerge;\n    /***/ },\n    /* 71 */ /***/ function(module, exports1, __nested_webpack_require_158935__) {\n        var ListCache = __nested_webpack_require_158935__(24), stackClear = __nested_webpack_require_158935__(77), stackDelete = __nested_webpack_require_158935__(78), stackGet = __nested_webpack_require_158935__(79), stackHas = __nested_webpack_require_158935__(80), stackSet = __nested_webpack_require_158935__(81);\n        /**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function Stack(entries) {\n            var data = this.__data__ = new ListCache(entries);\n            this.size = data.size;\n        }\n        // Add methods to `Stack`.\n        Stack.prototype.clear = stackClear;\n        Stack.prototype[\"delete\"] = stackDelete;\n        Stack.prototype.get = stackGet;\n        Stack.prototype.has = stackHas;\n        Stack.prototype.set = stackSet;\n        module.exports = Stack;\n    /***/ },\n    /* 72 */ /***/ function(module, exports1) {\n        /**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */ function listCacheClear() {\n            this.__data__ = [];\n            this.size = 0;\n        }\n        module.exports = listCacheClear;\n    /***/ },\n    /* 73 */ /***/ function(module, exports1, __nested_webpack_require_160150__) {\n        var assocIndexOf = __nested_webpack_require_160150__(25);\n        /** Used for built-in method references. */ var arrayProto = Array.prototype;\n        /** Built-in value references. */ var splice = arrayProto.splice;\n        /**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function listCacheDelete(key) {\n            var data = this.__data__, index = assocIndexOf(data, key);\n            if (index < 0) {\n                return false;\n            }\n            var lastIndex = data.length - 1;\n            if (index == lastIndex) {\n                data.pop();\n            } else {\n                splice.call(data, index, 1);\n            }\n            --this.size;\n            return true;\n        }\n        module.exports = listCacheDelete;\n    /***/ },\n    /* 74 */ /***/ function(module, exports1, __nested_webpack_require_161167__) {\n        var assocIndexOf = __nested_webpack_require_161167__(25);\n        /**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function listCacheGet(key) {\n            var data = this.__data__, index = assocIndexOf(data, key);\n            return index < 0 ? undefined : data[index][1];\n        }\n        module.exports = listCacheGet;\n    /***/ },\n    /* 75 */ /***/ function(module, exports1, __nested_webpack_require_161709__) {\n        var assocIndexOf = __nested_webpack_require_161709__(25);\n        /**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function listCacheHas(key) {\n            return assocIndexOf(this.__data__, key) > -1;\n        }\n        module.exports = listCacheHas;\n    /***/ },\n    /* 76 */ /***/ function(module, exports1, __nested_webpack_require_162231__) {\n        var assocIndexOf = __nested_webpack_require_162231__(25);\n        /**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */ function listCacheSet(key, value) {\n            var data = this.__data__, index = assocIndexOf(data, key);\n            if (index < 0) {\n                ++this.size;\n                data.push([\n                    key,\n                    value\n                ]);\n            } else {\n                data[index][1] = value;\n            }\n            return this;\n        }\n        module.exports = listCacheSet;\n    /***/ },\n    /* 77 */ /***/ function(module, exports1, __nested_webpack_require_163030__) {\n        var ListCache = __nested_webpack_require_163030__(24);\n        /**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */ function stackClear() {\n            this.__data__ = new ListCache();\n            this.size = 0;\n        }\n        module.exports = stackClear;\n    /***/ },\n    /* 78 */ /***/ function(module, exports1) {\n        /**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function stackDelete(key) {\n            var data = this.__data__, result = data[\"delete\"](key);\n            this.size = data.size;\n            return result;\n        }\n        module.exports = stackDelete;\n    /***/ },\n    /* 79 */ /***/ function(module, exports1) {\n        /**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function stackGet(key) {\n            return this.__data__.get(key);\n        }\n        module.exports = stackGet;\n    /***/ },\n    /* 80 */ /***/ function(module, exports1) {\n        /**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function stackHas(key) {\n            return this.__data__.has(key);\n        }\n        module.exports = stackHas;\n    /***/ },\n    /* 81 */ /***/ function(module, exports1, __nested_webpack_require_164712__) {\n        var ListCache = __nested_webpack_require_164712__(24), Map1 = __nested_webpack_require_164712__(44), MapCache = __nested_webpack_require_164712__(47);\n        /** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;\n        /**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */ function stackSet(key, value) {\n            var data = this.__data__;\n            if (data instanceof ListCache) {\n                var pairs = data.__data__;\n                if (!Map1 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n                    pairs.push([\n                        key,\n                        value\n                    ]);\n                    this.size = ++data.size;\n                    return this;\n                }\n                data = this.__data__ = new MapCache(pairs);\n            }\n            data.set(key, value);\n            this.size = data.size;\n            return this;\n        }\n        module.exports = stackSet;\n    /***/ },\n    /* 82 */ /***/ function(module, exports1, __nested_webpack_require_165903__) {\n        var isFunction = __nested_webpack_require_165903__(36), isMasked = __nested_webpack_require_165903__(85), isObject = __nested_webpack_require_165903__(15), toSource = __nested_webpack_require_165903__(87);\n        /**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */ var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n        /** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n        /** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;\n        /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n        /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n        /** Used to detect if a method is native. */ var reIsNative = RegExp(\"^\" + funcToString.call(hasOwnProperty).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n        /**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */ function baseIsNative(value) {\n            if (!isObject(value) || isMasked(value)) {\n                return false;\n            }\n            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n            return pattern.test(toSource(value));\n        }\n        module.exports = baseIsNative;\n    /***/ },\n    /* 83 */ /***/ function(module, exports1, __nested_webpack_require_167508__) {\n        var Symbol1 = __nested_webpack_require_167508__(27);\n        /** Used for built-in method references. */ var objectProto = Object.prototype;\n        /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n        /**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var nativeObjectToString = objectProto.toString;\n        /** Built-in value references. */ var symToStringTag = Symbol1 ? Symbol1.toStringTag : undefined;\n        /**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */ function getRawTag(value) {\n            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n            try {\n                value[symToStringTag] = undefined;\n                var unmasked = true;\n            } catch (e) {}\n            var result = nativeObjectToString.call(value);\n            if (unmasked) {\n                if (isOwn) {\n                    value[symToStringTag] = tag;\n                } else {\n                    delete value[symToStringTag];\n                }\n            }\n            return result;\n        }\n        module.exports = getRawTag;\n    /***/ },\n    /* 84 */ /***/ function(module, exports1) {\n        /** Used for built-in method references. */ var objectProto = Object.prototype;\n        /**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var nativeObjectToString = objectProto.toString;\n        /**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */ function objectToString(value) {\n            return nativeObjectToString.call(value);\n        }\n        module.exports = objectToString;\n    /***/ },\n    /* 85 */ /***/ function(module, exports1, __nested_webpack_require_169616__) {\n        var coreJsData = __nested_webpack_require_169616__(86);\n        /** Used to detect methods masquerading as native. */ var maskSrcKey = function() {\n            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n            return uid ? \"Symbol(src)_1.\" + uid : \"\";\n        }();\n        /**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */ function isMasked(func) {\n            return !!maskSrcKey && maskSrcKey in func;\n        }\n        module.exports = isMasked;\n    /***/ },\n    /* 86 */ /***/ function(module, exports1, __nested_webpack_require_170330__) {\n        var root = __nested_webpack_require_170330__(19);\n        /** Used to detect overreaching core-js shims. */ var coreJsData = root[\"__core-js_shared__\"];\n        module.exports = coreJsData;\n    /***/ },\n    /* 87 */ /***/ function(module, exports1) {\n        /** Used for built-in method references. */ var funcProto = Function.prototype;\n        /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n        /**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */ function toSource(func) {\n            if (func != null) {\n                try {\n                    return funcToString.call(func);\n                } catch (e) {}\n                try {\n                    return func + \"\";\n                } catch (e) {}\n            }\n            return \"\";\n        }\n        module.exports = toSource;\n    /***/ },\n    /* 88 */ /***/ function(module, exports1) {\n        /**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */ function getValue(object, key) {\n            return object == null ? undefined : object[key];\n        }\n        module.exports = getValue;\n    /***/ },\n    /* 89 */ /***/ function(module, exports1, __nested_webpack_require_171773__) {\n        var Hash = __nested_webpack_require_171773__(90), ListCache = __nested_webpack_require_171773__(24), Map1 = __nested_webpack_require_171773__(44);\n        /**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */ function mapCacheClear() {\n            this.size = 0;\n            this.__data__ = {\n                \"hash\": new Hash(),\n                \"map\": new (Map1 || ListCache)(),\n                \"string\": new Hash()\n            };\n        }\n        module.exports = mapCacheClear;\n    /***/ },\n    /* 90 */ /***/ function(module, exports1, __nested_webpack_require_172355__) {\n        var hashClear = __nested_webpack_require_172355__(91), hashDelete = __nested_webpack_require_172355__(92), hashGet = __nested_webpack_require_172355__(93), hashHas = __nested_webpack_require_172355__(94), hashSet = __nested_webpack_require_172355__(95);\n        /**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function Hash(entries) {\n            var index = -1, length = entries == null ? 0 : entries.length;\n            this.clear();\n            while(++index < length){\n                var entry = entries[index];\n                this.set(entry[0], entry[1]);\n            }\n        }\n        // Add methods to `Hash`.\n        Hash.prototype.clear = hashClear;\n        Hash.prototype[\"delete\"] = hashDelete;\n        Hash.prototype.get = hashGet;\n        Hash.prototype.has = hashHas;\n        Hash.prototype.set = hashSet;\n        module.exports = Hash;\n    /***/ },\n    /* 91 */ /***/ function(module, exports1, __nested_webpack_require_173305__) {\n        var nativeCreate = __nested_webpack_require_173305__(28);\n        /**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */ function hashClear() {\n            this.__data__ = nativeCreate ? nativeCreate(null) : {};\n            this.size = 0;\n        }\n        module.exports = hashClear;\n    /***/ },\n    /* 92 */ /***/ function(module, exports1) {\n        /**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function hashDelete(key) {\n            var result = this.has(key) && delete this.__data__[key];\n            this.size -= result ? 1 : 0;\n            return result;\n        }\n        module.exports = hashDelete;\n    /***/ },\n    /* 93 */ /***/ function(module, exports1, __nested_webpack_require_174274__) {\n        var nativeCreate = __nested_webpack_require_174274__(28);\n        /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n        /** Used for built-in method references. */ var objectProto = Object.prototype;\n        /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n        /**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function hashGet(key) {\n            var data = this.__data__;\n            if (nativeCreate) {\n                var result = data[key];\n                return result === HASH_UNDEFINED ? undefined : result;\n            }\n            return hasOwnProperty.call(data, key) ? data[key] : undefined;\n        }\n        module.exports = hashGet;\n    /***/ },\n    /* 94 */ /***/ function(module, exports1, __nested_webpack_require_175240__) {\n        var nativeCreate = __nested_webpack_require_175240__(28);\n        /** Used for built-in method references. */ var objectProto = Object.prototype;\n        /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n        /**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function hashHas(key) {\n            var data = this.__data__;\n            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n        }\n        module.exports = hashHas;\n    /***/ },\n    /* 95 */ /***/ function(module, exports1, __nested_webpack_require_176007__) {\n        var nativeCreate = __nested_webpack_require_176007__(28);\n        /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n        /**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */ function hashSet(key, value) {\n            var data = this.__data__;\n            this.size += this.has(key) ? 0 : 1;\n            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n            return this;\n        }\n        module.exports = hashSet;\n    /***/ },\n    /* 96 */ /***/ function(module, exports1, __nested_webpack_require_176759__) {\n        var getMapData = __nested_webpack_require_176759__(29);\n        /**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function mapCacheDelete(key) {\n            var result = getMapData(this, key)[\"delete\"](key);\n            this.size -= result ? 1 : 0;\n            return result;\n        }\n        module.exports = mapCacheDelete;\n    /***/ },\n    /* 97 */ /***/ function(module, exports1) {\n        /**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */ function isKeyable(value) {\n            var type = typeof value;\n            return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n        }\n        module.exports = isKeyable;\n    /***/ },\n    /* 98 */ /***/ function(module, exports1, __nested_webpack_require_177870__) {\n        var getMapData = __nested_webpack_require_177870__(29);\n        /**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function mapCacheGet(key) {\n            return getMapData(this, key).get(key);\n        }\n        module.exports = mapCacheGet;\n    /***/ },\n    /* 99 */ /***/ function(module, exports1, __nested_webpack_require_178321__) {\n        var getMapData = __nested_webpack_require_178321__(29);\n        /**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function mapCacheHas(key) {\n            return getMapData(this, key).has(key);\n        }\n        module.exports = mapCacheHas;\n    /***/ },\n    /* 100 */ /***/ function(module, exports1, __nested_webpack_require_178825__) {\n        var getMapData = __nested_webpack_require_178825__(29);\n        /**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */ function mapCacheSet(key, value) {\n            var data = getMapData(this, key), size = data.size;\n            data.set(key, value);\n            this.size += data.size == size ? 0 : 1;\n            return this;\n        }\n        module.exports = mapCacheSet;\n    /***/ },\n    /* 101 */ /***/ function(module, exports1, __nested_webpack_require_179459__) {\n        var createBaseFor = __nested_webpack_require_179459__(102);\n        /**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */ var baseFor = createBaseFor();\n        module.exports = baseFor;\n    /***/ },\n    /* 102 */ /***/ function(module, exports1) {\n        /**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */ function createBaseFor(fromRight) {\n            return function(object, iteratee, keysFunc) {\n                var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;\n                while(length--){\n                    var key = props[fromRight ? length : ++index];\n                    if (iteratee(iterable[key], key, iterable) === false) {\n                        break;\n                    }\n                }\n                return object;\n            };\n        }\n        module.exports = createBaseFor;\n    /***/ },\n    /* 103 */ /***/ function(module, exports1, __nested_webpack_require_180986__) {\n        var assignMergeValue = __nested_webpack_require_180986__(48), cloneBuffer = __nested_webpack_require_180986__(104), cloneTypedArray = __nested_webpack_require_180986__(105), copyArray = __nested_webpack_require_180986__(108), initCloneObject = __nested_webpack_require_180986__(109), isArguments = __nested_webpack_require_180986__(30), isArray = __nested_webpack_require_180986__(16), isArrayLikeObject = __nested_webpack_require_180986__(113), isBuffer = __nested_webpack_require_180986__(52), isFunction = __nested_webpack_require_180986__(36), isObject = __nested_webpack_require_180986__(15), isPlainObject = __nested_webpack_require_180986__(115), isTypedArray = __nested_webpack_require_180986__(53), safeGet = __nested_webpack_require_180986__(54), toPlainObject = __nested_webpack_require_180986__(119);\n        /**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */ function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);\n            if (stacked) {\n                assignMergeValue(object, key, stacked);\n                return;\n            }\n            var newValue = customizer ? customizer(objValue, srcValue, key + \"\", object, source, stack) : undefined;\n            var isCommon = newValue === undefined;\n            if (isCommon) {\n                var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n                newValue = srcValue;\n                if (isArr || isBuff || isTyped) {\n                    if (isArray(objValue)) {\n                        newValue = objValue;\n                    } else if (isArrayLikeObject(objValue)) {\n                        newValue = copyArray(objValue);\n                    } else if (isBuff) {\n                        isCommon = false;\n                        newValue = cloneBuffer(srcValue, true);\n                    } else if (isTyped) {\n                        isCommon = false;\n                        newValue = cloneTypedArray(srcValue, true);\n                    } else {\n                        newValue = [];\n                    }\n                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n                    newValue = objValue;\n                    if (isArguments(objValue)) {\n                        newValue = toPlainObject(objValue);\n                    } else if (!isObject(objValue) || isFunction(objValue)) {\n                        newValue = initCloneObject(srcValue);\n                    }\n                } else {\n                    isCommon = false;\n                }\n            }\n            if (isCommon) {\n                // Recursively merge objects and arrays (susceptible to call stack limits).\n                stack.set(srcValue, newValue);\n                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n                stack[\"delete\"](srcValue);\n            }\n            assignMergeValue(object, key, newValue);\n        }\n        module.exports = baseMergeDeep;\n    /***/ },\n    /* 104 */ /***/ function(module, exports1, __nested_webpack_require_184553__) {\n        /* WEBPACK VAR INJECTION */ (function(module) {\n            var root = __nested_webpack_require_184553__(19);\n            /** Detect free variable `exports`. */ var freeExports =  true && exports1 && !exports1.nodeType && exports1;\n            /** Detect free variable `module`. */ var freeModule = freeExports && typeof module == \"object\" && module && !module.nodeType && module;\n            /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n            /** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n            /**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */ function cloneBuffer(buffer, isDeep) {\n                if (isDeep) {\n                    return buffer.slice();\n                }\n                var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n                buffer.copy(result);\n                return result;\n            }\n            module.exports = cloneBuffer;\n        /* WEBPACK VAR INJECTION */ }).call(this, __nested_webpack_require_184553__(38)(module));\n    /***/ },\n    /* 105 */ /***/ function(module, exports1, __nested_webpack_require_185983__) {\n        var cloneArrayBuffer = __nested_webpack_require_185983__(106);\n        /**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */ function cloneTypedArray(typedArray, isDeep) {\n            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n        }\n        module.exports = cloneTypedArray;\n    /***/ },\n    /* 106 */ /***/ function(module, exports1, __nested_webpack_require_186637__) {\n        var Uint8Array1 = __nested_webpack_require_186637__(107);\n        /**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */ function cloneArrayBuffer(arrayBuffer) {\n            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n            new Uint8Array1(result).set(new Uint8Array1(arrayBuffer));\n            return result;\n        }\n        module.exports = cloneArrayBuffer;\n    /***/ },\n    /* 107 */ /***/ function(module, exports1, __nested_webpack_require_187232__) {\n        var root = __nested_webpack_require_187232__(19);\n        /** Built-in value references. */ var Uint8Array1 = root.Uint8Array;\n        module.exports = Uint8Array1;\n    /***/ },\n    /* 108 */ /***/ function(module, exports1) {\n        /**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */ function copyArray(source, array) {\n            var index = -1, length = source.length;\n            array || (array = Array(length));\n            while(++index < length){\n                array[index] = source[index];\n            }\n            return array;\n        }\n        module.exports = copyArray;\n    /***/ },\n    /* 109 */ /***/ function(module, exports1, __nested_webpack_require_188066__) {\n        var baseCreate = __nested_webpack_require_188066__(110), getPrototype = __nested_webpack_require_188066__(50), isPrototype = __nested_webpack_require_188066__(51);\n        /**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */ function initCloneObject(object) {\n            return typeof object.constructor == \"function\" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};\n        }\n        module.exports = initCloneObject;\n    /***/ },\n    /* 110 */ /***/ function(module, exports1, __nested_webpack_require_188652__) {\n        var isObject = __nested_webpack_require_188652__(15);\n        /** Built-in value references. */ var objectCreate = Object.create;\n        /**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */ var baseCreate = function() {\n            function object() {}\n            return function(proto) {\n                if (!isObject(proto)) {\n                    return {};\n                }\n                if (objectCreate) {\n                    return objectCreate(proto);\n                }\n                object.prototype = proto;\n                var result = new object();\n                object.prototype = undefined;\n                return result;\n            };\n        }();\n        module.exports = baseCreate;\n    /***/ },\n    /* 111 */ /***/ function(module, exports1) {\n        /**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */ function overArg(func, transform) {\n            return function(arg) {\n                return func(transform(arg));\n            };\n        }\n        module.exports = overArg;\n    /***/ },\n    /* 112 */ /***/ function(module, exports1, __nested_webpack_require_190113__) {\n        var baseGetTag = __nested_webpack_require_190113__(22), isObjectLike = __nested_webpack_require_190113__(20);\n        /** `Object#toString` result references. */ var argsTag = \"[object Arguments]\";\n        /**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */ function baseIsArguments(value) {\n            return isObjectLike(value) && baseGetTag(value) == argsTag;\n        }\n        module.exports = baseIsArguments;\n    /***/ },\n    /* 113 */ /***/ function(module, exports1, __nested_webpack_require_190724__) {\n        var isArrayLike = __nested_webpack_require_190724__(39), isObjectLike = __nested_webpack_require_190724__(20);\n        /**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */ function isArrayLikeObject(value) {\n            return isObjectLike(value) && isArrayLike(value);\n        }\n        module.exports = isArrayLikeObject;\n    /***/ },\n    /* 114 */ /***/ function(module, exports1) {\n        /**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */ function stubFalse() {\n            return false;\n        }\n        module.exports = stubFalse;\n    /***/ },\n    /* 115 */ /***/ function(module, exports1, __nested_webpack_require_191957__) {\n        var baseGetTag = __nested_webpack_require_191957__(22), getPrototype = __nested_webpack_require_191957__(50), isObjectLike = __nested_webpack_require_191957__(20);\n        /** `Object#toString` result references. */ var objectTag = \"[object Object]\";\n        /** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;\n        /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n        /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n        /** Used to infer the `Object` constructor. */ var objectCtorString = funcToString.call(Object);\n        /**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */ function isPlainObject(value) {\n            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n                return false;\n            }\n            var proto = getPrototype(value);\n            if (proto === null) {\n                return true;\n            }\n            var Ctor = hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n            return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n        }\n        module.exports = isPlainObject;\n    /***/ },\n    /* 116 */ /***/ function(module, exports1, __nested_webpack_require_193827__) {\n        var baseGetTag = __nested_webpack_require_193827__(22), isLength = __nested_webpack_require_193827__(40), isObjectLike = __nested_webpack_require_193827__(20);\n        /** `Object#toString` result references. */ var argsTag = \"[object Arguments]\", arrayTag = \"[object Array]\", boolTag = \"[object Boolean]\", dateTag = \"[object Date]\", errorTag = \"[object Error]\", funcTag = \"[object Function]\", mapTag = \"[object Map]\", numberTag = \"[object Number]\", objectTag = \"[object Object]\", regexpTag = \"[object RegExp]\", setTag = \"[object Set]\", stringTag = \"[object String]\", weakMapTag = \"[object WeakMap]\";\n        var arrayBufferTag = \"[object ArrayBuffer]\", dataViewTag = \"[object DataView]\", float32Tag = \"[object Float32Array]\", float64Tag = \"[object Float64Array]\", int8Tag = \"[object Int8Array]\", int16Tag = \"[object Int16Array]\", int32Tag = \"[object Int32Array]\", uint8Tag = \"[object Uint8Array]\", uint8ClampedTag = \"[object Uint8ClampedArray]\", uint16Tag = \"[object Uint16Array]\", uint32Tag = \"[object Uint32Array]\";\n        /** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {};\n        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n        /**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */ function baseIsTypedArray(value) {\n            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n        }\n        module.exports = baseIsTypedArray;\n    /***/ },\n    /* 117 */ /***/ function(module, exports1) {\n        /**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */ function baseUnary(func) {\n            return function(value) {\n                return func(value);\n            };\n        }\n        module.exports = baseUnary;\n    /***/ },\n    /* 118 */ /***/ function(module, exports1, __nested_webpack_require_196557__) {\n        /* WEBPACK VAR INJECTION */ (function(module) {\n            var freeGlobal = __nested_webpack_require_196557__(45);\n            /** Detect free variable `exports`. */ var freeExports =  true && exports1 && !exports1.nodeType && exports1;\n            /** Detect free variable `module`. */ var freeModule = freeExports && typeof module == \"object\" && module && !module.nodeType && module;\n            /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n            /** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;\n            /** Used to access faster Node.js helpers. */ var nodeUtil = function() {\n                try {\n                    // Use `util.types` for Node.js 10+.\n                    var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n                    if (types) {\n                        return types;\n                    }\n                    // Legacy `process.binding('util')` for Node.js < 10.\n                    return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n                } catch (e) {}\n            }();\n            module.exports = nodeUtil;\n        /* WEBPACK VAR INJECTION */ }).call(this, __nested_webpack_require_196557__(38)(module));\n    /***/ },\n    /* 119 */ /***/ function(module, exports1, __nested_webpack_require_197983__) {\n        var copyObject = __nested_webpack_require_197983__(120), keysIn = __nested_webpack_require_197983__(56);\n        /**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */ function toPlainObject(value) {\n            return copyObject(value, keysIn(value));\n        }\n        module.exports = toPlainObject;\n    /***/ },\n    /* 120 */ /***/ function(module, exports1, __nested_webpack_require_198850__) {\n        var assignValue = __nested_webpack_require_198850__(55), baseAssignValue = __nested_webpack_require_198850__(37);\n        /**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */ function copyObject(source, props, object, customizer) {\n            var isNew = !object;\n            object || (object = {});\n            var index = -1, length = props.length;\n            while(++index < length){\n                var key = props[index];\n                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;\n                if (newValue === undefined) {\n                    newValue = source[key];\n                }\n                if (isNew) {\n                    baseAssignValue(object, key, newValue);\n                } else {\n                    assignValue(object, key, newValue);\n                }\n            }\n            return object;\n        }\n        module.exports = copyObject;\n    /***/ },\n    /* 121 */ /***/ function(module, exports1, __nested_webpack_require_200157__) {\n        var baseTimes = __nested_webpack_require_200157__(122), isArguments = __nested_webpack_require_200157__(30), isArray = __nested_webpack_require_200157__(16), isBuffer = __nested_webpack_require_200157__(52), isIndex = __nested_webpack_require_200157__(31), isTypedArray = __nested_webpack_require_200157__(53);\n        /** Used for built-in method references. */ var objectProto = Object.prototype;\n        /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n        /**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */ function arrayLikeKeys(value, inherited) {\n            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;\n            for(var key in value){\n                if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n                (key == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n                isBuff && (key == \"offset\" || key == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n                isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n                isIndex(key, length)))) {\n                    result.push(key);\n                }\n            }\n            return result;\n        }\n        module.exports = arrayLikeKeys;\n    /***/ },\n    /* 122 */ /***/ function(module, exports1) {\n        /**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */ function baseTimes(n, iteratee) {\n            var index = -1, result = Array(n);\n            while(++index < n){\n                result[index] = iteratee(index);\n            }\n            return result;\n        }\n        module.exports = baseTimes;\n    /***/ },\n    /* 123 */ /***/ function(module, exports1, __nested_webpack_require_202672__) {\n        var isObject = __nested_webpack_require_202672__(15), isPrototype = __nested_webpack_require_202672__(51), nativeKeysIn = __nested_webpack_require_202672__(124);\n        /** Used for built-in method references. */ var objectProto = Object.prototype;\n        /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n        /**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */ function baseKeysIn(object) {\n            if (!isObject(object)) {\n                return nativeKeysIn(object);\n            }\n            var isProto = isPrototype(object), result = [];\n            for(var key in object){\n                if (!(key == \"constructor\" && (isProto || !hasOwnProperty.call(object, key)))) {\n                    result.push(key);\n                }\n            }\n            return result;\n        }\n        module.exports = baseKeysIn;\n    /***/ },\n    /* 124 */ /***/ function(module, exports1) {\n        /**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */ function nativeKeysIn(object) {\n            var result = [];\n            if (object != null) {\n                for(var key in Object(object)){\n                    result.push(key);\n                }\n            }\n            return result;\n        }\n        module.exports = nativeKeysIn;\n    /***/ },\n    /* 125 */ /***/ function(module, exports1, __nested_webpack_require_204411__) {\n        var baseRest = __nested_webpack_require_204411__(126), isIterateeCall = __nested_webpack_require_204411__(131);\n        /**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */ function createAssigner(assigner) {\n            return baseRest(function(object, sources) {\n                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;\n                customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length--, customizer) : undefined;\n                if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n                    customizer = length < 3 ? undefined : customizer;\n                    length = 1;\n                }\n                object = Object(object);\n                while(++index < length){\n                    var source = sources[index];\n                    if (source) {\n                        assigner(object, source, index, customizer);\n                    }\n                }\n                return object;\n            });\n        }\n        module.exports = createAssigner;\n    /***/ },\n    /* 126 */ /***/ function(module, exports1, __nested_webpack_require_205720__) {\n        var identity = __nested_webpack_require_205720__(57), overRest = __nested_webpack_require_205720__(58), setToString = __nested_webpack_require_205720__(59);\n        /**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */ function baseRest(func, start) {\n            return setToString(overRest(func, start, identity), func + \"\");\n        }\n        module.exports = baseRest;\n    /***/ },\n    /* 127 */ /***/ function(module, exports1) {\n        /**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */ function apply(func, thisArg, args) {\n            switch(args.length){\n                case 0:\n                    return func.call(thisArg);\n                case 1:\n                    return func.call(thisArg, args[0]);\n                case 2:\n                    return func.call(thisArg, args[0], args[1]);\n                case 3:\n                    return func.call(thisArg, args[0], args[1], args[2]);\n            }\n            return func.apply(thisArg, args);\n        }\n        module.exports = apply;\n    /***/ },\n    /* 128 */ /***/ function(module, exports1, __nested_webpack_require_207350__) {\n        var constant = __nested_webpack_require_207350__(129), defineProperty = __nested_webpack_require_207350__(49), identity = __nested_webpack_require_207350__(57);\n        /**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */ var baseSetToString = !defineProperty ? identity : function(func, string) {\n            return defineProperty(func, \"toString\", {\n                \"configurable\": true,\n                \"enumerable\": false,\n                \"value\": constant(string),\n                \"writable\": true\n            });\n        };\n        module.exports = baseSetToString;\n    /***/ },\n    /* 129 */ /***/ function(module, exports1) {\n        /**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */ function constant(value) {\n            return function() {\n                return value;\n            };\n        }\n        module.exports = constant;\n    /***/ },\n    /* 130 */ /***/ function(module, exports1) {\n        /** Used to detect hot functions by number of calls within a span of milliseconds. */ var HOT_COUNT = 800, HOT_SPAN = 16;\n        /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeNow = Date.now;\n        /**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */ function shortOut(func) {\n            var count = 0, lastCalled = 0;\n            return function() {\n                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);\n                lastCalled = stamp;\n                if (remaining > 0) {\n                    if (++count >= HOT_COUNT) {\n                        return arguments[0];\n                    }\n                } else {\n                    count = 0;\n                }\n                return func.apply(undefined, arguments);\n            };\n        }\n        module.exports = shortOut;\n    /***/ },\n    /* 131 */ /***/ function(module, exports1, __nested_webpack_require_209989__) {\n        var eq = __nested_webpack_require_209989__(26), isArrayLike = __nested_webpack_require_209989__(39), isIndex = __nested_webpack_require_209989__(31), isObject = __nested_webpack_require_209989__(15);\n        /**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */ function isIterateeCall(value, index, object) {\n            if (!isObject(object)) {\n                return false;\n            }\n            var type = typeof index;\n            if (type == \"number\" ? isArrayLike(object) && isIndex(index, object.length) : type == \"string\" && index in object) {\n                return eq(object[index], value);\n            }\n            return false;\n        }\n        module.exports = isIterateeCall;\n    /***/ },\n    /* 132 */ /***/ function(module, exports1) {\n        /*\n * typedefs.js\n * Normalizes browser-specific prefixes and provide some basic polyfills\n */ if (false) {}\n        if (typeof Math.imul !== \"function\") {\n            /* eslint-disable no-bitwise */ Math.imul = function(a, b) {\n                var ah = a >>> 16 & 0xffff;\n                var al = a & 0xffff;\n                var bh = b >>> 16 & 0xffff;\n                var bl = b & 0xffff;\n                // the shift by 0 fixes the sign on the high part\n                // the final |0 converts the unsigned value into a signed value\n                return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;\n            };\n        /* eslint-enable no-bitwise */ }\n        if (typeof Object.assign !== \"function\") {\n            Object.assign = function(target) {\n                // .length of function is 2\n                \"use strict\";\n                if (target === null) {\n                    // TypeError if undefined or null\n                    throw new TypeError(\"Cannot convert undefined or null to object\");\n                }\n                var to = Object(target);\n                for(var index = 1; index < arguments.length; index++){\n                    // eslint-disable-next-line prefer-rest-params\n                    var nextSource = arguments[index];\n                    if (nextSource !== null) {\n                        // Skip over if undefined or null\n                        // eslint-disable-next-line no-restricted-syntax\n                        for(var nextKey in nextSource){\n                            // Avoid bugs when hasOwnProperty is shadowed\n                            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                                to[nextKey] = nextSource[nextKey];\n                            }\n                        }\n                    }\n                }\n                return to;\n            };\n        }\n    /***/ },\n    /* 133 */ /***/ function(module, exports1) {\n        function _arrayWithHoles(arr) {\n            if (Array.isArray(arr)) return arr;\n        }\n        module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 134 */ /***/ function(module, exports1) {\n        function _iterableToArrayLimit(r, l) {\n            var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n            if (null != t) {\n                var e, n, i, u, a = [], f = !0, o = !1;\n                try {\n                    if (i = (t = t.call(r)).next, 0 === l) {\n                        if (Object(t) !== t) return;\n                        f = !1;\n                    } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n                } catch (r) {\n                    o = !0, n = r;\n                } finally{\n                    try {\n                        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n                    } finally{\n                        if (o) throw n;\n                    }\n                }\n                return a;\n            }\n        }\n        module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 135 */ /***/ function(module, exports1) {\n        function _nonIterableRest() {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n        }\n        module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 136 */ /***/ function(module, exports1, __nested_webpack_require_215247__) {\n        var _typeof = __nested_webpack_require_215247__(13)[\"default\"];\n        function _toPrimitive(input, hint) {\n            if (_typeof(input) !== \"object\" || input === null) return input;\n            var prim = input[Symbol.toPrimitive];\n            if (prim !== undefined) {\n                var res = prim.call(input, hint || \"default\");\n                if (_typeof(res) !== \"object\") return res;\n                throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n            }\n            return (hint === \"string\" ? String : Number)(input);\n        }\n        module.exports = _toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 137 */ /***/ function(module, exports1, __nested_webpack_require_216011__) {\n        var _typeof = __nested_webpack_require_216011__(13)[\"default\"];\n        function _regeneratorRuntime() {\n            \"use strict\";\n            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ module.exports = _regeneratorRuntime = function _regeneratorRuntime() {\n                return e;\n            }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n            var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t, e, r) {\n                t[e] = r.value;\n            }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\";\n            function define(t, e, r) {\n                return Object.defineProperty(t, e, {\n                    value: r,\n                    enumerable: !0,\n                    configurable: !0,\n                    writable: !0\n                }), t[e];\n            }\n            try {\n                define({}, \"\");\n            } catch (t) {\n                define = function define(t, e, r) {\n                    return t[e] = r;\n                };\n            }\n            function wrap(t, e, r, n) {\n                var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []);\n                return o(a, \"_invoke\", {\n                    value: makeInvokeMethod(t, r, c)\n                }), a;\n            }\n            function tryCatch(t, e, r) {\n                try {\n                    return {\n                        type: \"normal\",\n                        arg: t.call(e, r)\n                    };\n                } catch (t) {\n                    return {\n                        type: \"throw\",\n                        arg: t\n                    };\n                }\n            }\n            e.wrap = wrap;\n            var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {};\n            function Generator() {}\n            function GeneratorFunction() {}\n            function GeneratorFunctionPrototype() {}\n            var p = {};\n            define(p, a, function() {\n                return this;\n            });\n            var d = Object.getPrototypeOf, v = d && d(d(values([])));\n            v && v !== r && n.call(v, a) && (p = v);\n            var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);\n            function defineIteratorMethods(t) {\n                [\n                    \"next\",\n                    \"throw\",\n                    \"return\"\n                ].forEach(function(e) {\n                    define(t, e, function(t) {\n                        return this._invoke(e, t);\n                    });\n                });\n            }\n            function AsyncIterator(t, e) {\n                function invoke(r, o, i, a) {\n                    var c = tryCatch(t[r], t, o);\n                    if (\"throw\" !== c.type) {\n                        var u = c.arg, h = u.value;\n                        return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function(t) {\n                            invoke(\"next\", t, i, a);\n                        }, function(t) {\n                            invoke(\"throw\", t, i, a);\n                        }) : e.resolve(h).then(function(t) {\n                            u.value = t, i(u);\n                        }, function(t) {\n                            return invoke(\"throw\", t, i, a);\n                        });\n                    }\n                    a(c.arg);\n                }\n                var r;\n                o(this, \"_invoke\", {\n                    value: function value(t, n) {\n                        function callInvokeWithMethodAndArg() {\n                            return new e(function(e, r) {\n                                invoke(t, n, e, r);\n                            });\n                        }\n                        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n                    }\n                });\n            }\n            function makeInvokeMethod(e, r, n) {\n                var o = h;\n                return function(i, a) {\n                    if (o === f) throw new Error(\"Generator is already running\");\n                    if (o === s) {\n                        if (\"throw\" === i) throw a;\n                        return {\n                            value: t,\n                            done: !0\n                        };\n                    }\n                    for(n.method = i, n.arg = a;;){\n                        var c = n.delegate;\n                        if (c) {\n                            var u = maybeInvokeDelegate(c, n);\n                            if (u) {\n                                if (u === y) continue;\n                                return u;\n                            }\n                        }\n                        if (\"next\" === n.method) n.sent = n._sent = n.arg;\n                        else if (\"throw\" === n.method) {\n                            if (o === h) throw o = s, n.arg;\n                            n.dispatchException(n.arg);\n                        } else \"return\" === n.method && n.abrupt(\"return\", n.arg);\n                        o = f;\n                        var p = tryCatch(e, r, n);\n                        if (\"normal\" === p.type) {\n                            if (o = n.done ? s : l, p.arg === y) continue;\n                            return {\n                                value: p.arg,\n                                done: n.done\n                            };\n                        }\n                        \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg);\n                    }\n                };\n            }\n            function maybeInvokeDelegate(e, r) {\n                var n = r.method, o = e.iterator[n];\n                if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y;\n                var i = tryCatch(o, e.iterator, r.arg);\n                if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y;\n                var a = i.arg;\n                return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y);\n            }\n            function pushTryEntry(t) {\n                var e = {\n                    tryLoc: t[0]\n                };\n                1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n            }\n            function resetTryEntry(t) {\n                var e = t.completion || {};\n                e.type = \"normal\", delete e.arg, t.completion = e;\n            }\n            function Context(t) {\n                this.tryEntries = [\n                    {\n                        tryLoc: \"root\"\n                    }\n                ], t.forEach(pushTryEntry, this), this.reset(!0);\n            }\n            function values(e) {\n                if (e || \"\" === e) {\n                    var r = e[a];\n                    if (r) return r.call(e);\n                    if (\"function\" == typeof e.next) return e;\n                    if (!isNaN(e.length)) {\n                        var o = -1, i = function next() {\n                            for(; ++o < e.length;)if (n.call(e, o)) return next.value = e[o], next.done = !1, next;\n                            return next.value = t, next.done = !0, next;\n                        };\n                        return i.next = i;\n                    }\n                }\n                throw new TypeError(_typeof(e) + \" is not iterable\");\n            }\n            return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", {\n                value: GeneratorFunctionPrototype,\n                configurable: !0\n            }), o(GeneratorFunctionPrototype, \"constructor\", {\n                value: GeneratorFunction,\n                configurable: !0\n            }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function(t) {\n                var e = \"function\" == typeof t && t.constructor;\n                return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name));\n            }, e.mark = function(t) {\n                return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t;\n            }, e.awrap = function(t) {\n                return {\n                    __await: t\n                };\n            }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {\n                return this;\n            }), e.AsyncIterator = AsyncIterator, e.async = function(t, r, n, o, i) {\n                void 0 === i && (i = Promise);\n                var a = new AsyncIterator(wrap(t, r, n, o), i);\n                return e.isGeneratorFunction(r) ? a : a.next().then(function(t) {\n                    return t.done ? t.value : a.next();\n                });\n            }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function() {\n                return this;\n            }), define(g, \"toString\", function() {\n                return \"[object Generator]\";\n            }), e.keys = function(t) {\n                var e = Object(t), r = [];\n                for(var n in e)r.push(n);\n                return r.reverse(), function next() {\n                    for(; r.length;){\n                        var t = r.pop();\n                        if (t in e) return next.value = t, next.done = !1, next;\n                    }\n                    return next.done = !0, next;\n                };\n            }, e.values = values, Context.prototype = {\n                constructor: Context,\n                reset: function reset(e) {\n                    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for(var r in this)\"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);\n                },\n                stop: function stop() {\n                    this.done = !0;\n                    var t = this.tryEntries[0].completion;\n                    if (\"throw\" === t.type) throw t.arg;\n                    return this.rval;\n                },\n                dispatchException: function dispatchException(e) {\n                    if (this.done) throw e;\n                    var r = this;\n                    function handle(n, o) {\n                        return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o;\n                    }\n                    for(var o = this.tryEntries.length - 1; o >= 0; --o){\n                        var i = this.tryEntries[o], a = i.completion;\n                        if (\"root\" === i.tryLoc) return handle(\"end\");\n                        if (i.tryLoc <= this.prev) {\n                            var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\");\n                            if (c && u) {\n                                if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n                                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n                            } else if (c) {\n                                if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n                            } else {\n                                if (!u) throw new Error(\"try statement without catch or finally\");\n                                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n                            }\n                        }\n                    }\n                },\n                abrupt: function abrupt(t, e) {\n                    for(var r = this.tryEntries.length - 1; r >= 0; --r){\n                        var o = this.tryEntries[r];\n                        if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) {\n                            var i = o;\n                            break;\n                        }\n                    }\n                    i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);\n                    var a = i ? i.completion : {};\n                    return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a);\n                },\n                complete: function complete(t, e) {\n                    if (\"throw\" === t.type) throw t.arg;\n                    return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y;\n                },\n                finish: function finish(t) {\n                    for(var e = this.tryEntries.length - 1; e >= 0; --e){\n                        var r = this.tryEntries[e];\n                        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;\n                    }\n                },\n                \"catch\": function _catch(t) {\n                    for(var e = this.tryEntries.length - 1; e >= 0; --e){\n                        var r = this.tryEntries[e];\n                        if (r.tryLoc === t) {\n                            var n = r.completion;\n                            if (\"throw\" === n.type) {\n                                var o = n.arg;\n                                resetTryEntry(r);\n                            }\n                            return o;\n                        }\n                    }\n                    throw new Error(\"illegal catch attempt\");\n                },\n                delegateYield: function delegateYield(e, r, n) {\n                    return this.delegate = {\n                        iterator: values(e),\n                        resultName: r,\n                        nextLoc: n\n                    }, \"next\" === this.method && (this.arg = t), y;\n                }\n            }, e;\n        }\n        module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 138 */ /***/ function(module, exports1, __nested_webpack_require_230977__) {\n        var getPrototypeOf = __nested_webpack_require_230977__(2);\n        function _superPropBase(object, property) {\n            while(!Object.prototype.hasOwnProperty.call(object, property)){\n                object = getPrototypeOf(object);\n                if (object === null) break;\n            }\n            return object;\n        }\n        module.exports = _superPropBase, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 139 */ /***/ function(module, exports1, __nested_webpack_require_231504__) {\n        var arrayLikeToArray = __nested_webpack_require_231504__(61);\n        function _arrayWithoutHoles(arr) {\n            if (Array.isArray(arr)) return arrayLikeToArray(arr);\n        }\n        module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 140 */ /***/ function(module, exports1) {\n        function _iterableToArray(iter) {\n            if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n        }\n        module.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 141 */ /***/ function(module, exports1) {\n        function _nonIterableSpread() {\n            throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n        }\n        module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 142 */ /***/ function(module, exports1, __nested_webpack_require_232659__) {\n        var basePickBy = __nested_webpack_require_232659__(143), hasIn = __nested_webpack_require_232659__(153);\n        /**\n * The base implementation of `_.pick` without support for individual\n * property identifiers.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @returns {Object} Returns the new object.\n */ function basePick(object, paths) {\n            return basePickBy(object, paths, function(value, path) {\n                return hasIn(object, path);\n            });\n        }\n        module.exports = basePick;\n    /***/ },\n    /* 143 */ /***/ function(module, exports1, __nested_webpack_require_233307__) {\n        var baseGet = __nested_webpack_require_233307__(144), baseSet = __nested_webpack_require_233307__(152), castPath = __nested_webpack_require_233307__(32);\n        /**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */ function basePickBy(object, paths, predicate) {\n            var index = -1, length = paths.length, result = {};\n            while(++index < length){\n                var path = paths[index], value = baseGet(object, path);\n                if (predicate(value, path)) {\n                    baseSet(result, castPath(path, object), value);\n                }\n            }\n            return result;\n        }\n        module.exports = basePickBy;\n    /***/ },\n    /* 144 */ /***/ function(module, exports1, __nested_webpack_require_234276__) {\n        var castPath = __nested_webpack_require_234276__(32), toKey = __nested_webpack_require_234276__(43);\n        /**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */ function baseGet(object, path) {\n            path = castPath(path, object);\n            var index = 0, length = path.length;\n            while(object != null && index < length){\n                object = object[toKey(path[index++])];\n            }\n            return index && index == length ? object : undefined;\n        }\n        module.exports = baseGet;\n    /***/ },\n    /* 145 */ /***/ function(module, exports1, __nested_webpack_require_235056__) {\n        var isArray = __nested_webpack_require_235056__(16), isSymbol = __nested_webpack_require_235056__(42);\n        /** Used to match property names within property paths. */ var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp = /^\\w*$/;\n        /**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */ function isKey(value, object) {\n            if (isArray(value)) {\n                return false;\n            }\n            var type = typeof value;\n            if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol(value)) {\n                return true;\n            }\n            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n        }\n        module.exports = isKey;\n    /***/ },\n    /* 146 */ /***/ function(module, exports1, __nested_webpack_require_236125__) {\n        var memoizeCapped = __nested_webpack_require_236125__(147);\n        /** Used to match property names within property paths. */ var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n        /** Used to match backslashes in property paths. */ var reEscapeChar = /\\\\(\\\\)?/g;\n        /**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */ var stringToPath = memoizeCapped(function(string) {\n            var result = [];\n            if (string.charCodeAt(0) === 46 /* . */ ) {\n                result.push(\"\");\n            }\n            string.replace(rePropName, function(match, number, quote, subString) {\n                result.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n            });\n            return result;\n        });\n        module.exports = stringToPath;\n    /***/ },\n    /* 147 */ /***/ function(module, exports1, __nested_webpack_require_237172__) {\n        var memoize = __nested_webpack_require_237172__(148);\n        /** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;\n        /**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */ function memoizeCapped(func) {\n            var result = memoize(func, function(key) {\n                if (cache.size === MAX_MEMOIZE_SIZE) {\n                    cache.clear();\n                }\n                return key;\n            });\n            var cache = result.cache;\n            return result;\n        }\n        module.exports = memoizeCapped;\n    /***/ },\n    /* 148 */ /***/ function(module, exports1, __nested_webpack_require_238018__) {\n        var MapCache = __nested_webpack_require_238018__(47);\n        /** Error message constants. */ var FUNC_ERROR_TEXT = \"Expected a function\";\n        /**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */ function memoize(func, resolver) {\n            if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            var memoized = function() {\n                var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n                if (cache.has(key)) {\n                    return cache.get(key);\n                }\n                var result = func.apply(this, args);\n                memoized.cache = cache.set(key, result) || cache;\n                return result;\n            };\n            memoized.cache = new (memoize.Cache || MapCache)();\n            return memoized;\n        }\n        // Expose `MapCache`.\n        memoize.Cache = MapCache;\n        module.exports = memoize;\n    /***/ },\n    /* 149 */ /***/ function(module, exports1, __nested_webpack_require_240519__) {\n        var baseToString = __nested_webpack_require_240519__(150);\n        /**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */ function toString(value) {\n            return value == null ? \"\" : baseToString(value);\n        }\n        module.exports = toString;\n    /***/ },\n    /* 150 */ /***/ function(module, exports1, __nested_webpack_require_241220__) {\n        var Symbol1 = __nested_webpack_require_241220__(27), arrayMap = __nested_webpack_require_241220__(151), isArray = __nested_webpack_require_241220__(16), isSymbol = __nested_webpack_require_241220__(42);\n        /** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;\n        /** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol1 ? Symbol1.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;\n        /**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */ function baseToString(value) {\n            // Exit early for strings to avoid a performance hit in some environments.\n            if (typeof value == \"string\") {\n                return value;\n            }\n            if (isArray(value)) {\n                // Recursively convert values (susceptible to call stack limits).\n                return arrayMap(value, baseToString) + \"\";\n            }\n            if (isSymbol(value)) {\n                return symbolToString ? symbolToString.call(value) : \"\";\n            }\n            var result = value + \"\";\n            return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n        }\n        module.exports = baseToString;\n    /***/ },\n    /* 151 */ /***/ function(module, exports1) {\n        /**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */ function arrayMap(array, iteratee) {\n            var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n            while(++index < length){\n                result[index] = iteratee(array[index], index, array);\n            }\n            return result;\n        }\n        module.exports = arrayMap;\n    /***/ },\n    /* 152 */ /***/ function(module, exports1, __nested_webpack_require_243308__) {\n        var assignValue = __nested_webpack_require_243308__(55), castPath = __nested_webpack_require_243308__(32), isIndex = __nested_webpack_require_243308__(31), isObject = __nested_webpack_require_243308__(15), toKey = __nested_webpack_require_243308__(43);\n        /**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */ function baseSet(object, path, value, customizer) {\n            if (!isObject(object)) {\n                return object;\n            }\n            path = castPath(path, object);\n            var index = -1, length = path.length, lastIndex = length - 1, nested = object;\n            while(nested != null && ++index < length){\n                var key = toKey(path[index]), newValue = value;\n                if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n                    return object;\n                }\n                if (index != lastIndex) {\n                    var objValue = nested[key];\n                    newValue = customizer ? customizer(objValue, key, nested) : undefined;\n                    if (newValue === undefined) {\n                        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n                    }\n                }\n                assignValue(nested, key, newValue);\n                nested = nested[key];\n            }\n            return object;\n        }\n        module.exports = baseSet;\n    /***/ },\n    /* 153 */ /***/ function(module, exports1, __nested_webpack_require_244995__) {\n        var baseHasIn = __nested_webpack_require_244995__(154), hasPath = __nested_webpack_require_244995__(155);\n        /**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */ function hasIn(object, path) {\n            return object != null && hasPath(object, path, baseHasIn);\n        }\n        module.exports = hasIn;\n    /***/ },\n    /* 154 */ /***/ function(module, exports1) {\n        /**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */ function baseHasIn(object, key) {\n            return object != null && key in Object(object);\n        }\n        module.exports = baseHasIn;\n    /***/ },\n    /* 155 */ /***/ function(module, exports1, __nested_webpack_require_246340__) {\n        var castPath = __nested_webpack_require_246340__(32), isArguments = __nested_webpack_require_246340__(30), isArray = __nested_webpack_require_246340__(16), isIndex = __nested_webpack_require_246340__(31), isLength = __nested_webpack_require_246340__(40), toKey = __nested_webpack_require_246340__(43);\n        /**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */ function hasPath(object, path, hasFunc) {\n            path = castPath(path, object);\n            var index = -1, length = path.length, result = false;\n            while(++index < length){\n                var key = toKey(path[index]);\n                if (!(result = object != null && hasFunc(object, key))) {\n                    break;\n                }\n                object = object[key];\n            }\n            if (result || ++index != length) {\n                return result;\n            }\n            length = object == null ? 0 : object.length;\n            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n        }\n        module.exports = hasPath;\n    /***/ },\n    /* 156 */ /***/ function(module, exports1, __nested_webpack_require_247663__) {\n        var flatten = __nested_webpack_require_247663__(157), overRest = __nested_webpack_require_247663__(58), setToString = __nested_webpack_require_247663__(59);\n        /**\n * A specialized version of `baseRest` which flattens the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @returns {Function} Returns the new function.\n */ function flatRest(func) {\n            return setToString(overRest(func, undefined, flatten), func + \"\");\n        }\n        module.exports = flatRest;\n    /***/ },\n    /* 157 */ /***/ function(module, exports1, __nested_webpack_require_248238__) {\n        var baseFlatten = __nested_webpack_require_248238__(158);\n        /**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */ function flatten(array) {\n            var length = array == null ? 0 : array.length;\n            return length ? baseFlatten(array, 1) : [];\n        }\n        module.exports = flatten;\n    /***/ },\n    /* 158 */ /***/ function(module, exports1, __nested_webpack_require_248859__) {\n        var arrayPush = __nested_webpack_require_248859__(159), isFlattenable = __nested_webpack_require_248859__(160);\n        /**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */ function baseFlatten(array, depth, predicate, isStrict, result) {\n            var index = -1, length = array.length;\n            predicate || (predicate = isFlattenable);\n            result || (result = []);\n            while(++index < length){\n                var value = array[index];\n                if (depth > 0 && predicate(value)) {\n                    if (depth > 1) {\n                        // Recursively flatten arrays (susceptible to call stack limits).\n                        baseFlatten(value, depth - 1, predicate, isStrict, result);\n                    } else {\n                        arrayPush(result, value);\n                    }\n                } else if (!isStrict) {\n                    result[result.length] = value;\n                }\n            }\n            return result;\n        }\n        module.exports = baseFlatten;\n    /***/ },\n    /* 159 */ /***/ function(module, exports1) {\n        /**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */ function arrayPush(array, values) {\n            var index = -1, length = values.length, offset = array.length;\n            while(++index < length){\n                array[offset + index] = values[index];\n            }\n            return array;\n        }\n        module.exports = arrayPush;\n    /***/ },\n    /* 160 */ /***/ function(module, exports1, __nested_webpack_require_250928__) {\n        var Symbol1 = __nested_webpack_require_250928__(27), isArguments = __nested_webpack_require_250928__(30), isArray = __nested_webpack_require_250928__(16);\n        /** Built-in value references. */ var spreadableSymbol = Symbol1 ? Symbol1.isConcatSpreadable : undefined;\n        /**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */ function isFlattenable(value) {\n            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n        }\n        module.exports = isFlattenable;\n    /***/ },\n    /* 161 */ /***/ function(module, exports1) {\n        function _isNativeFunction(fn) {\n            try {\n                return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n            } catch (e) {\n                return typeof fn === \"function\";\n            }\n        }\n        module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 162 */ /***/ function(module, exports1, __nested_webpack_require_252087__) {\n        var setPrototypeOf = __nested_webpack_require_252087__(41);\n        var isNativeReflectConstruct = __nested_webpack_require_252087__(163);\n        function _construct(Parent, args, Class) {\n            if (isNativeReflectConstruct()) {\n                module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n            } else {\n                module.exports = _construct = function _construct(Parent, args, Class) {\n                    var a = [\n                        null\n                    ];\n                    a.push.apply(a, args);\n                    var Constructor = Function.bind.apply(Parent, a);\n                    var instance = new Constructor();\n                    if (Class) setPrototypeOf(instance, Class.prototype);\n                    return instance;\n                }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n            }\n            return _construct.apply(null, arguments);\n        }\n        module.exports = _construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 163 */ /***/ function(module, exports1) {\n        function _isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    /***/ },\n    /* 164 */ /***/ function(module, exports1) {\n        module.exports = __webpack_require__(/*! ndarray */ \"(ssr)/./node_modules/ndarray/ndarray.js\");\n    /***/ },\n    /* 165 */ /***/ function(module, exports1) {\n        module.exports = __webpack_require__(/*! ndarray-linear-interpolate */ \"(ssr)/./node_modules/ndarray-linear-interpolate/interp.js\");\n    /***/ },\n    /* 166 */ /***/ function(module, __nested_webpack_exports__, __nested_webpack_require_254197__) {\n        \"use strict\";\n        // ESM COMPAT FLAG\n        __nested_webpack_require_254197__.r(__nested_webpack_exports__);\n        // EXPORTS\n        __nested_webpack_require_254197__.d(__nested_webpack_exports__, \"BarcodeDecoder\", function() {\n            return /* reexport */ barcode_decoder;\n        });\n        __nested_webpack_require_254197__.d(__nested_webpack_exports__, \"Readers\", function() {\n            return /* reexport */ reader_namespaceObject;\n        });\n        __nested_webpack_require_254197__.d(__nested_webpack_exports__, \"CameraAccess\", function() {\n            return /* reexport */ camera_access;\n        });\n        __nested_webpack_require_254197__.d(__nested_webpack_exports__, \"ImageDebug\", function() {\n            return /* reexport */ image_debug[\"a\" /* default */ ];\n        });\n        __nested_webpack_require_254197__.d(__nested_webpack_exports__, \"ImageWrapper\", function() {\n            return /* reexport */ image_wrapper[\"a\" /* default */ ];\n        });\n        __nested_webpack_require_254197__.d(__nested_webpack_exports__, \"ResultCollector\", function() {\n            return /* reexport */ result_collector;\n        });\n        // NAMESPACE OBJECT: ./src/reader/index.ts\n        var reader_namespaceObject = {};\n        __nested_webpack_require_254197__.r(reader_namespaceObject);\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"BarcodeReader\", function() {\n            return barcode_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"TwoOfFiveReader\", function() {\n            return _2of5_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"NewCodabarReader\", function() {\n            return codabar_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"Code128Reader\", function() {\n            return code_128_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"Code32Reader\", function() {\n            return code_32_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"Code39Reader\", function() {\n            return code_39_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"Code39VINReader\", function() {\n            return code_39_vin_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"Code93Reader\", function() {\n            return code_93_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"EAN2Reader\", function() {\n            return ean_2_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"EAN5Reader\", function() {\n            return ean_5_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"EAN8Reader\", function() {\n            return ean_8_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"EANReader\", function() {\n            return ean_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"I2of5Reader\", function() {\n            return i2of5_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"UPCEReader\", function() {\n            return upc_e_reader;\n        });\n        __nested_webpack_require_254197__.d(reader_namespaceObject, \"UPCReader\", function() {\n            return upc_reader;\n        });\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js\n        var helpers_typeof = __nested_webpack_require_254197__(13);\n        var typeof_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(helpers_typeof);\n        // EXTERNAL MODULE: ./node_modules/lodash/merge.js\n        var merge = __nested_webpack_require_254197__(18);\n        var merge_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(merge);\n        // EXTERNAL MODULE: ./src/common/typedefs.js\n        var typedefs = __nested_webpack_require_254197__(132);\n        // EXTERNAL MODULE: ./src/common/image_wrapper.ts\n        var image_wrapper = __nested_webpack_require_254197__(10);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\n        var asyncToGenerator = __nested_webpack_require_254197__(11);\n        var asyncToGenerator_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(asyncToGenerator);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\n        var regenerator = __nested_webpack_require_254197__(8);\n        var regenerator_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(regenerator);\n        // EXTERNAL MODULE: ./src/common/image_debug.ts\n        var image_debug = __nested_webpack_require_254197__(17);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js\n        var classCallCheck = __nested_webpack_require_254197__(3);\n        var classCallCheck_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(classCallCheck);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js\n        var createClass = __nested_webpack_require_254197__(4);\n        var createClass_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(createClass);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js\n        var assertThisInitialized = __nested_webpack_require_254197__(1);\n        var assertThisInitialized_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(assertThisInitialized);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js\n        var inherits = __nested_webpack_require_254197__(7);\n        var inherits_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(inherits);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\n        var possibleConstructorReturn = __nested_webpack_require_254197__(6);\n        var possibleConstructorReturn_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(possibleConstructorReturn);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js\n        var getPrototypeOf = __nested_webpack_require_254197__(2);\n        var getPrototypeOf_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(getPrototypeOf);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js\n        var defineProperty = __nested_webpack_require_254197__(0);\n        var defineProperty_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(defineProperty);\n        // EXTERNAL MODULE: ./src/common/array_helper.ts\n        var array_helper = __nested_webpack_require_254197__(9);\n        // CONCATENATED MODULE: ./src/reader/barcode_reader.ts\n        /* eslint-disable no-unused-vars */ /* eslint-disable class-methods-use-this */ // eslint-disable-next-line import/no-cycle\n        // for some reason this throws a shadow error on itself?!\n        // eslint-disable-next-line no-shadow\n        var BarcodeDirection = /*#__PURE__*/ function(BarcodeDirection) {\n            BarcodeDirection[BarcodeDirection[\"Forward\"] = 1] = \"Forward\";\n            BarcodeDirection[BarcodeDirection[\"Reverse\"] = -1] = \"Reverse\";\n            return BarcodeDirection;\n        }({});\n        var barcode_reader_BarcodeReader = /*#__PURE__*/ function() {\n            function BarcodeReader(config, supplements) {\n                classCallCheck_default()(this, BarcodeReader);\n                defineProperty_default()(this, \"_row\", []);\n                defineProperty_default()(this, \"config\", {});\n                defineProperty_default()(this, \"supplements\", []);\n                defineProperty_default()(this, \"SINGLE_CODE_ERROR\", 0);\n                defineProperty_default()(this, \"FORMAT\", \"unknown\");\n                defineProperty_default()(this, \"CONFIG_KEYS\", {});\n                this._row = [];\n                this.config = config || {};\n                if (supplements) {\n                    this.supplements = supplements;\n                }\n            }\n            createClass_default()(BarcodeReader, [\n                {\n                    key: \"_nextUnset\",\n                    value: function _nextUnset(line) {\n                        var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                        for(var i = start; i < line.length; i++){\n                            if (!line[i]) return i;\n                        }\n                        return line.length;\n                    }\n                },\n                {\n                    key: \"_matchPattern\",\n                    value: function _matchPattern(counter, code) {\n                        var maxSingleError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.SINGLE_CODE_ERROR || 1;\n                        var error = 0;\n                        var singleError = 0;\n                        var sum = 0;\n                        var modulo = 0;\n                        var barWidth = 0;\n                        var count = 0;\n                        var scaled = 0;\n                        for(var i = 0; i < counter.length; i++){\n                            sum += counter[i];\n                            modulo += code[i];\n                        }\n                        if (sum < modulo) {\n                            return Number.MAX_VALUE;\n                        }\n                        barWidth = sum / modulo;\n                        // eslint-disable-next-line no-param-reassign\n                        maxSingleError *= barWidth;\n                        for(var _i = 0; _i < counter.length; _i++){\n                            count = counter[_i];\n                            scaled = code[_i] * barWidth;\n                            singleError = Math.abs(count - scaled) / scaled;\n                            if (singleError > maxSingleError) {\n                                return Number.MAX_VALUE;\n                            }\n                            error += singleError;\n                        }\n                        return error / modulo;\n                    }\n                },\n                {\n                    key: \"_nextSet\",\n                    value: function _nextSet(line) {\n                        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                        for(var i = offset; i < line.length; i++){\n                            if (line[i]) return i;\n                        }\n                        return line.length;\n                    }\n                },\n                {\n                    key: \"_correctBars\",\n                    value: function _correctBars(counter, correction, indices) {\n                        var length = indices.length;\n                        var tmp = 0;\n                        while(length--){\n                            tmp = counter[indices[length]] * (1 - (1 - correction) / 2);\n                            if (tmp > 1) {\n                                // eslint-disable-next-line no-param-reassign\n                                counter[indices[length]] = tmp;\n                            }\n                        }\n                    }\n                },\n                {\n                    key: \"decodePattern\",\n                    value: function decodePattern(pattern) {\n                        // console.warn('* decodePattern', pattern);\n                        this._row = pattern;\n                        // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));\n                        var result = this.decode();\n                        // console.warn('* first result=', result);\n                        if (result === null) {\n                            this._row.reverse();\n                            result = this.decode();\n                            // console.warn('* reversed result=', result);\n                            if (result) {\n                                result.direction = BarcodeDirection.Reverse;\n                                result.start = this._row.length - result.start;\n                                result.end = this._row.length - result.end;\n                            }\n                        } else {\n                            result.direction = BarcodeDirection.Forward;\n                        }\n                        if (result) {\n                            result.format = this.FORMAT;\n                        }\n                        // console.warn('* returning', result);\n                        return result;\n                    }\n                },\n                {\n                    key: \"_matchRange\",\n                    value: function _matchRange(start, end, value) {\n                        // eslint-disable-next-line no-param-reassign\n                        start = start < 0 ? 0 : start;\n                        var i;\n                        for(i = start; i < end; i++){\n                            if (this._row[i] !== value) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                },\n                {\n                    key: \"_fillCounters\",\n                    value: function _fillCounters() {\n                        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);\n                        var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;\n                        var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n                        var counters = [];\n                        var counterPos = 0;\n                        counters[counterPos] = 0;\n                        for(var i = offset; i < end; i++){\n                            // eslint-disable-next-line no-bitwise\n                            if (this._row[i] ^ (isWhite ? 1 : 0)) {\n                                counters[counterPos]++;\n                            } else {\n                                counterPos++;\n                                counters[counterPos] = 1;\n                                // eslint-disable-next-line no-param-reassign\n                                isWhite = !isWhite;\n                            }\n                        }\n                        return counters;\n                    }\n                },\n                {\n                    key: \"_toCounters\",\n                    value: function _toCounters(start, counters) {\n                        var numCounters = counters.length;\n                        var end = this._row.length;\n                        var isWhite = !this._row[start];\n                        var counterPos = 0;\n                        array_helper[\"a\" /* default */ ].init(counters, 0);\n                        for(var i = start; i < end; i++){\n                            // eslint-disable-next-line no-bitwise\n                            if (this._row[i] ^ (isWhite ? 1 : 0)) {\n                                // eslint-disable-next-line no-param-reassign\n                                counters[counterPos]++;\n                            } else {\n                                counterPos++;\n                                if (counterPos === numCounters) {\n                                    break;\n                                } else {\n                                    // eslint-disable-next-line no-param-reassign\n                                    counters[counterPos] = 1;\n                                    isWhite = !isWhite;\n                                }\n                            }\n                        }\n                        return counters;\n                    }\n                },\n                {\n                    key: \"decodeImage\",\n                    value: function decodeImage(imageWrapper) {\n                        // eslint-disable-next-line no-void\n                        void imageWrapper;\n                        return null;\n                    }\n                }\n            ], [\n                {\n                    key: \"Exception\",\n                    get: function get() {\n                        return {\n                            StartNotFoundException: \"Start-Info was not found!\",\n                            CodeNotFoundException: \"Code could not be found!\",\n                            PatternNotFoundException: \"Pattern could not be found!\"\n                        };\n                    }\n                }\n            ]);\n            return BarcodeReader;\n        }();\n        /* harmony default export */ var barcode_reader = barcode_reader_BarcodeReader;\n        // CONCATENATED MODULE: ./src/reader/2of5_reader.ts\n        function _createSuper(Derived) {\n            var hasNativeReflectConstruct = _isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function _isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        var N = 1;\n        var W = 3;\n        var START_PATTERN = [\n            W,\n            N,\n            W,\n            N,\n            N,\n            N\n        ];\n        var STOP_PATTERN = [\n            W,\n            N,\n            N,\n            N,\n            W\n        ];\n        var CODE_PATTERN = [\n            [\n                N,\n                N,\n                W,\n                W,\n                N\n            ],\n            [\n                W,\n                N,\n                N,\n                N,\n                W\n            ],\n            [\n                N,\n                W,\n                N,\n                N,\n                W\n            ],\n            [\n                W,\n                W,\n                N,\n                N,\n                N\n            ],\n            [\n                N,\n                N,\n                W,\n                N,\n                W\n            ],\n            [\n                W,\n                N,\n                W,\n                N,\n                N\n            ],\n            [\n                N,\n                W,\n                W,\n                N,\n                N\n            ],\n            [\n                N,\n                N,\n                N,\n                W,\n                W\n            ],\n            [\n                W,\n                N,\n                N,\n                W,\n                N\n            ],\n            [\n                N,\n                W,\n                N,\n                W,\n                N\n            ]\n        ];\n        var START_PATTERN_LENGTH = START_PATTERN.reduce(function(sum, val) {\n            return sum + val;\n        }, 0);\n        var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/ function(_BarcodeReader) {\n            inherits_default()(TwoOfFiveReader, _BarcodeReader);\n            var _super = _createSuper(TwoOfFiveReader);\n            function TwoOfFiveReader() {\n                var _this;\n                classCallCheck_default()(this, TwoOfFiveReader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"barSpaceRatio\", [\n                    1,\n                    1\n                ]);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"2of5\");\n                defineProperty_default()(assertThisInitialized_default()(_this), \"SINGLE_CODE_ERROR\", 0.78);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"AVG_CODE_ERROR\", 0.30);\n                return _this;\n            }\n            createClass_default()(TwoOfFiveReader, [\n                {\n                    key: \"_findPattern\",\n                    value: function _findPattern(pattern, offset) {\n                        var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                        var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n                        var counter = [];\n                        var counterPos = 0;\n                        var bestMatch = {\n                            error: Number.MAX_VALUE,\n                            code: -1,\n                            start: 0,\n                            end: 0\n                        };\n                        var sum = 0;\n                        var error = 0;\n                        var epsilon = this.AVG_CODE_ERROR;\n                        if (!offset) {\n                            offset = this._nextSet(this._row);\n                        }\n                        for(var i = 0; i < pattern.length; i++){\n                            counter[i] = 0;\n                        }\n                        for(var _i = offset; _i < this._row.length; _i++){\n                            if (this._row[_i] ^ (isWhite ? 1 : 0)) {\n                                counter[counterPos]++;\n                            } else {\n                                if (counterPos === counter.length - 1) {\n                                    sum = 0;\n                                    for(var j = 0; j < counter.length; j++){\n                                        sum += counter[j];\n                                    }\n                                    error = this._matchPattern(counter, pattern);\n                                    if (error < epsilon) {\n                                        bestMatch.error = error;\n                                        bestMatch.start = _i - sum;\n                                        bestMatch.end = _i;\n                                        return bestMatch;\n                                    }\n                                    if (tryHarder) {\n                                        for(var _j = 0; _j < counter.length - 2; _j++){\n                                            counter[_j] = counter[_j + 2];\n                                        }\n                                        counter[counter.length - 2] = 0;\n                                        counter[counter.length - 1] = 0;\n                                        counterPos--;\n                                    } else {\n                                        return null;\n                                    }\n                                } else {\n                                    counterPos++;\n                                }\n                                counter[counterPos] = 1;\n                                isWhite = !isWhite;\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_findStart\",\n                    value: function _findStart() {\n                        var startInfo = null;\n                        var offset = this._nextSet(this._row);\n                        var narrowBarWidth = 1;\n                        var leadingWhitespaceStart = 0;\n                        while(!startInfo){\n                            startInfo = this._findPattern(START_PATTERN, offset, false, true);\n                            if (!startInfo) {\n                                return null;\n                            }\n                            narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);\n                            leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;\n                            if (leadingWhitespaceStart >= 0) {\n                                if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {\n                                    return startInfo;\n                                }\n                            }\n                            offset = startInfo.end;\n                            startInfo = null;\n                        }\n                        return startInfo;\n                    }\n                },\n                {\n                    key: \"_verifyTrailingWhitespace\",\n                    value: function _verifyTrailingWhitespace(endInfo) {\n                        var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;\n                        if (trailingWhitespaceEnd < this._row.length) {\n                            if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {\n                                return endInfo;\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_findEnd\",\n                    value: function _findEnd() {\n                        // TODO: reverse, followed by some calcs, followed by another reverse? really?\n                        this._row.reverse();\n                        var offset = this._nextSet(this._row);\n                        var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);\n                        this._row.reverse();\n                        if (endInfo === null) {\n                            return null;\n                        }\n                        // reverse numbers\n                        var tmp = endInfo.start;\n                        endInfo.start = this._row.length - endInfo.end;\n                        endInfo.end = this._row.length - tmp;\n                        return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;\n                    }\n                },\n                {\n                    key: \"_verifyCounterLength\",\n                    value: function _verifyCounterLength(counters) {\n                        return counters.length % 10 === 0;\n                    }\n                },\n                {\n                    key: \"_decodeCode\",\n                    value: function _decodeCode(counter) {\n                        var epsilon = this.AVG_CODE_ERROR;\n                        var bestMatch = {\n                            error: Number.MAX_VALUE,\n                            code: -1,\n                            start: 0,\n                            end: 0\n                        };\n                        for(var code = 0; code < CODE_PATTERN.length; code++){\n                            var error = this._matchPattern(counter, CODE_PATTERN[code]);\n                            if (error < bestMatch.error) {\n                                bestMatch.code = code;\n                                bestMatch.error = error;\n                            }\n                        }\n                        if (bestMatch.error < epsilon) {\n                            return bestMatch;\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_decodePayload\",\n                    value: function _decodePayload(counters, result, decodedCodes) {\n                        var pos = 0;\n                        var counterLength = counters.length;\n                        var counter = [\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                        var code = null;\n                        while(pos < counterLength){\n                            for(var i = 0; i < 5; i++){\n                                counter[i] = counters[pos] * this.barSpaceRatio[0];\n                                pos += 2;\n                            }\n                            code = this._decodeCode(counter);\n                            if (!code) {\n                                return null;\n                            }\n                            result.push(\"\".concat(code.code));\n                            decodedCodes.push(code);\n                        }\n                        return code;\n                    }\n                },\n                {\n                    key: \"decode\",\n                    value: function decode(row, start) {\n                        var startInfo = this._findStart();\n                        if (!startInfo) {\n                            return null;\n                        }\n                        var endInfo = this._findEnd();\n                        if (!endInfo) {\n                            return null;\n                        }\n                        var counters = this._fillCounters(startInfo.end, endInfo.start, false);\n                        if (!this._verifyCounterLength(counters)) {\n                            return null;\n                        }\n                        var decodedCodes = [];\n                        decodedCodes.push(startInfo);\n                        var result = [];\n                        var code = this._decodePayload(counters, result, decodedCodes);\n                        if (!code) {\n                            return null;\n                        }\n                        if (result.length < 5) {\n                            return null;\n                        }\n                        decodedCodes.push(endInfo);\n                        return {\n                            code: result.join(\"\"),\n                            start: startInfo.start,\n                            end: endInfo.end,\n                            startInfo: startInfo,\n                            decodedCodes: decodedCodes,\n                            format: this.FORMAT\n                        };\n                    }\n                }\n            ]);\n            return TwoOfFiveReader;\n        }(barcode_reader);\n        /* harmony default export */ var _2of5_reader = _2of5_reader_TwoOfFiveReader;\n        // CONCATENATED MODULE: ./src/reader/codabar_reader.ts\n        function codabar_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = codabar_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function codabar_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';\n        var ALPHABET = [\n            48,\n            49,\n            50,\n            51,\n            52,\n            53,\n            54,\n            55,\n            56,\n            57,\n            45,\n            36,\n            58,\n            47,\n            46,\n            43,\n            65,\n            66,\n            67,\n            68\n        ];\n        var CHARACTER_ENCODINGS = [\n            0x003,\n            0x006,\n            0x009,\n            0x060,\n            0x012,\n            0x042,\n            0x021,\n            0x024,\n            0x030,\n            0x048,\n            0x00c,\n            0x018,\n            0x045,\n            0x051,\n            0x054,\n            0x015,\n            0x01A,\n            0x029,\n            0x00B,\n            0x00E\n        ];\n        var START_END = [\n            0x01A,\n            0x029,\n            0x00B,\n            0x00E\n        ];\n        var MIN_ENCODED_CHARS = 4;\n        var MAX_ACCEPTABLE = 2.0;\n        var PADDING = 1.5;\n        ;\n        ;\n        var codabar_reader_NewCodabarReader = /*#__PURE__*/ function(_BarcodeReader) {\n            inherits_default()(NewCodabarReader, _BarcodeReader);\n            var _super = codabar_reader_createSuper(NewCodabarReader);\n            function NewCodabarReader() {\n                var _this;\n                classCallCheck_default()(this, NewCodabarReader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"_counters\", []);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"codabar\");\n                return _this;\n            }\n            createClass_default()(NewCodabarReader, [\n                {\n                    key: \"_computeAlternatingThreshold\",\n                    value: function _computeAlternatingThreshold(offset, end) {\n                        var min = Number.MAX_VALUE;\n                        var max = 0;\n                        var counter = 0;\n                        for(var i = offset; i < end; i += 2){\n                            counter = this._counters[i];\n                            if (counter > max) {\n                                max = counter;\n                            }\n                            if (counter < min) {\n                                min = counter;\n                            }\n                        }\n                        return (min + max) / 2.0 | 0;\n                    }\n                },\n                {\n                    key: \"_toPattern\",\n                    value: function _toPattern(offset) {\n                        var numCounters = 7;\n                        var end = offset + numCounters;\n                        if (end > this._counters.length) {\n                            return -1;\n                        }\n                        var barThreshold = this._computeAlternatingThreshold(offset, end);\n                        var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);\n                        var bitmask = 1 << numCounters - 1;\n                        var threshold = 0;\n                        var pattern = 0;\n                        for(var i = 0; i < numCounters; i++){\n                            threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;\n                            if (this._counters[offset + i] > threshold) {\n                                pattern |= bitmask;\n                            }\n                            bitmask >>= 1;\n                        }\n                        return pattern;\n                    }\n                },\n                {\n                    key: \"_isStartEnd\",\n                    value: function _isStartEnd(pattern) {\n                        for(var i = 0; i < START_END.length; i++){\n                            if (START_END[i] === pattern) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    }\n                },\n                {\n                    key: \"_sumCounters\",\n                    value: function _sumCounters(start, end) {\n                        var sum = 0;\n                        for(var i = start; i < end; i++){\n                            sum += this._counters[i];\n                        }\n                        return sum;\n                    }\n                },\n                {\n                    key: \"_findStart\",\n                    value: function _findStart() {\n                        var start = this._nextUnset(this._row);\n                        var end = start;\n                        for(var i = 1; i < this._counters.length; i++){\n                            var pattern = this._toPattern(i);\n                            if (pattern !== -1 && this._isStartEnd(pattern)) {\n                                // TODO: Look for whitespace ahead\n                                start += this._sumCounters(0, i);\n                                end = start + this._sumCounters(i, i + 8);\n                                return {\n                                    start: start,\n                                    end: end,\n                                    startCounter: i,\n                                    endCounter: i + 8\n                                };\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_patternToChar\",\n                    value: function _patternToChar(pattern) {\n                        for(var i = 0; i < CHARACTER_ENCODINGS.length; i++){\n                            if (CHARACTER_ENCODINGS[i] === pattern) {\n                                return String.fromCharCode(ALPHABET[i]);\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_calculatePatternLength\",\n                    value: function _calculatePatternLength(offset) {\n                        var sum = 0;\n                        for(var i = offset; i < offset + 7; i++){\n                            sum += this._counters[i];\n                        }\n                        return sum;\n                    }\n                },\n                {\n                    key: \"_verifyWhitespace\",\n                    value: function _verifyWhitespace(startCounter, endCounter) {\n                        if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {\n                            if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    }\n                },\n                {\n                    key: \"_charToPattern\",\n                    value: function _charToPattern(_char) {\n                        var charCode = _char.charCodeAt(0);\n                        for(var i = 0; i < ALPHABET.length; i++){\n                            if (ALPHABET[i] === charCode) {\n                                return CHARACTER_ENCODINGS[i];\n                            }\n                        }\n                        return 0x0;\n                    }\n                },\n                {\n                    key: \"_thresholdResultPattern\",\n                    value: function _thresholdResultPattern(result, startCounter) {\n                        var categorization = {\n                            space: {\n                                narrow: {\n                                    size: 0,\n                                    counts: 0,\n                                    min: 0,\n                                    max: Number.MAX_VALUE\n                                },\n                                wide: {\n                                    size: 0,\n                                    counts: 0,\n                                    min: 0,\n                                    max: Number.MAX_VALUE\n                                }\n                            },\n                            bar: {\n                                narrow: {\n                                    size: 0,\n                                    counts: 0,\n                                    min: 0,\n                                    max: Number.MAX_VALUE\n                                },\n                                wide: {\n                                    size: 0,\n                                    counts: 0,\n                                    min: 0,\n                                    max: Number.MAX_VALUE\n                                }\n                            }\n                        };\n                        var pos = startCounter;\n                        var pattern;\n                        for(var i = 0; i < result.length; i++){\n                            pattern = this._charToPattern(result[i]);\n                            for(var j = 6; j >= 0; j--){\n                                var kind = (j & 1) === 2 ? categorization.bar : categorization.space;\n                                var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;\n                                cat.size += this._counters[pos + j];\n                                cat.counts++;\n                                pattern >>= 1;\n                            }\n                            pos += 8;\n                        }\n                        [\n                            \"space\",\n                            \"bar\"\n                        ].forEach(function(key) {\n                            var newkind = categorization[key];\n                            newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);\n                            newkind.narrow.max = Math.ceil(newkind.wide.min);\n                            newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);\n                        });\n                        return categorization;\n                    }\n                },\n                {\n                    key: \"_validateResult\",\n                    value: function _validateResult(result, startCounter) {\n                        var thresholds = this._thresholdResultPattern(result, startCounter);\n                        var pos = startCounter;\n                        var pattern;\n                        for(var i = 0; i < result.length; i++){\n                            pattern = this._charToPattern(result[i]);\n                            for(var j = 6; j >= 0; j--){\n                                var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;\n                                var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;\n                                var size = this._counters[pos + j];\n                                if (size < cat.min || size > cat.max) {\n                                    return false;\n                                }\n                                pattern >>= 1;\n                            }\n                            pos += 8;\n                        }\n                        return true;\n                    }\n                },\n                {\n                    key: \"decode\",\n                    value: function decode(row, start) {\n                        this._counters = this._fillCounters();\n                        start = this._findStart();\n                        if (!start) {\n                            return null;\n                        }\n                        var nextStart = start.startCounter;\n                        var result = [];\n                        var pattern;\n                        do {\n                            pattern = this._toPattern(nextStart);\n                            if (pattern < 0) {\n                                return null;\n                            }\n                            var decodedChar = this._patternToChar(pattern);\n                            if (decodedChar === null) {\n                                return null;\n                            }\n                            result.push(decodedChar);\n                            nextStart += 8;\n                            if (result.length > 1 && this._isStartEnd(pattern)) {\n                                break;\n                            }\n                        }while (nextStart < this._counters.length);\n                        // verify end\n                        if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {\n                            return null;\n                        }\n                        // verify end white space\n                        if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {\n                            return null;\n                        }\n                        if (!this._validateResult(result, start.startCounter)) {\n                            return null;\n                        }\n                        nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;\n                        var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);\n                        return {\n                            code: result.join(\"\"),\n                            start: start.start,\n                            end: end,\n                            startInfo: start,\n                            decodedCodes: result,\n                            format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway\n                        };\n                    }\n                }\n            ]);\n            return NewCodabarReader;\n        }(barcode_reader);\n        /* harmony default export */ var codabar_reader = codabar_reader_NewCodabarReader;\n        // CONCATENATED MODULE: ./src/reader/code_128_reader.ts\n        function code_128_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = code_128_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function code_128_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        var code_128_reader_Code128Reader = /*#__PURE__*/ function(_BarcodeReader) {\n            inherits_default()(Code128Reader, _BarcodeReader);\n            var _super = code_128_reader_createSuper(Code128Reader);\n            function Code128Reader() {\n                var _this;\n                classCallCheck_default()(this, Code128Reader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_SHIFT\", 98);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_C\", 99);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_B\", 100);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_A\", 101);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"START_CODE_A\", 103);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"START_CODE_B\", 104);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"START_CODE_C\", 105);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"STOP_CODE\", 106);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_PATTERN\", [\n                    [\n                        2,\n                        1,\n                        2,\n                        2,\n                        2,\n                        2\n                    ],\n                    [\n                        2,\n                        2,\n                        2,\n                        1,\n                        2,\n                        2\n                    ],\n                    [\n                        2,\n                        2,\n                        2,\n                        2,\n                        2,\n                        1\n                    ],\n                    [\n                        1,\n                        2,\n                        1,\n                        2,\n                        2,\n                        3\n                    ],\n                    [\n                        1,\n                        2,\n                        1,\n                        3,\n                        2,\n                        2\n                    ],\n                    [\n                        1,\n                        3,\n                        1,\n                        2,\n                        2,\n                        2\n                    ],\n                    [\n                        1,\n                        2,\n                        2,\n                        2,\n                        1,\n                        3\n                    ],\n                    [\n                        1,\n                        2,\n                        2,\n                        3,\n                        1,\n                        2\n                    ],\n                    [\n                        1,\n                        3,\n                        2,\n                        2,\n                        1,\n                        2\n                    ],\n                    [\n                        2,\n                        2,\n                        1,\n                        2,\n                        1,\n                        3\n                    ],\n                    [\n                        2,\n                        2,\n                        1,\n                        3,\n                        1,\n                        2\n                    ],\n                    [\n                        2,\n                        3,\n                        1,\n                        2,\n                        1,\n                        2\n                    ],\n                    [\n                        1,\n                        1,\n                        2,\n                        2,\n                        3,\n                        2\n                    ],\n                    [\n                        1,\n                        2,\n                        2,\n                        1,\n                        3,\n                        2\n                    ],\n                    [\n                        1,\n                        2,\n                        2,\n                        2,\n                        3,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        3,\n                        2,\n                        2,\n                        2\n                    ],\n                    [\n                        1,\n                        2,\n                        3,\n                        1,\n                        2,\n                        2\n                    ],\n                    [\n                        1,\n                        2,\n                        3,\n                        2,\n                        2,\n                        1\n                    ],\n                    [\n                        2,\n                        2,\n                        3,\n                        2,\n                        1,\n                        1\n                    ],\n                    [\n                        2,\n                        2,\n                        1,\n                        1,\n                        3,\n                        2\n                    ],\n                    [\n                        2,\n                        2,\n                        1,\n                        2,\n                        3,\n                        1\n                    ],\n                    [\n                        2,\n                        1,\n                        3,\n                        2,\n                        1,\n                        2\n                    ],\n                    [\n                        2,\n                        2,\n                        3,\n                        1,\n                        1,\n                        2\n                    ],\n                    [\n                        3,\n                        1,\n                        2,\n                        1,\n                        3,\n                        1\n                    ],\n                    [\n                        3,\n                        1,\n                        1,\n                        2,\n                        2,\n                        2\n                    ],\n                    [\n                        3,\n                        2,\n                        1,\n                        1,\n                        2,\n                        2\n                    ],\n                    [\n                        3,\n                        2,\n                        1,\n                        2,\n                        2,\n                        1\n                    ],\n                    [\n                        3,\n                        1,\n                        2,\n                        2,\n                        1,\n                        2\n                    ],\n                    [\n                        3,\n                        2,\n                        2,\n                        1,\n                        1,\n                        2\n                    ],\n                    [\n                        3,\n                        2,\n                        2,\n                        2,\n                        1,\n                        1\n                    ],\n                    [\n                        2,\n                        1,\n                        2,\n                        1,\n                        2,\n                        3\n                    ],\n                    [\n                        2,\n                        1,\n                        2,\n                        3,\n                        2,\n                        1\n                    ],\n                    [\n                        2,\n                        3,\n                        2,\n                        1,\n                        2,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        1,\n                        3,\n                        2,\n                        3\n                    ],\n                    [\n                        1,\n                        3,\n                        1,\n                        1,\n                        2,\n                        3\n                    ],\n                    [\n                        1,\n                        3,\n                        1,\n                        3,\n                        2,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        2,\n                        3,\n                        1,\n                        3\n                    ],\n                    [\n                        1,\n                        3,\n                        2,\n                        1,\n                        1,\n                        3\n                    ],\n                    [\n                        1,\n                        3,\n                        2,\n                        3,\n                        1,\n                        1\n                    ],\n                    [\n                        2,\n                        1,\n                        1,\n                        3,\n                        1,\n                        3\n                    ],\n                    [\n                        2,\n                        3,\n                        1,\n                        1,\n                        1,\n                        3\n                    ],\n                    [\n                        2,\n                        3,\n                        1,\n                        3,\n                        1,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        2,\n                        1,\n                        3,\n                        3\n                    ],\n                    [\n                        1,\n                        1,\n                        2,\n                        3,\n                        3,\n                        1\n                    ],\n                    [\n                        1,\n                        3,\n                        2,\n                        1,\n                        3,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        3,\n                        1,\n                        2,\n                        3\n                    ],\n                    [\n                        1,\n                        1,\n                        3,\n                        3,\n                        2,\n                        1\n                    ],\n                    [\n                        1,\n                        3,\n                        3,\n                        1,\n                        2,\n                        1\n                    ],\n                    [\n                        3,\n                        1,\n                        3,\n                        1,\n                        2,\n                        1\n                    ],\n                    [\n                        2,\n                        1,\n                        1,\n                        3,\n                        3,\n                        1\n                    ],\n                    [\n                        2,\n                        3,\n                        1,\n                        1,\n                        3,\n                        1\n                    ],\n                    [\n                        2,\n                        1,\n                        3,\n                        1,\n                        1,\n                        3\n                    ],\n                    [\n                        2,\n                        1,\n                        3,\n                        3,\n                        1,\n                        1\n                    ],\n                    [\n                        2,\n                        1,\n                        3,\n                        1,\n                        3,\n                        1\n                    ],\n                    [\n                        3,\n                        1,\n                        1,\n                        1,\n                        2,\n                        3\n                    ],\n                    [\n                        3,\n                        1,\n                        1,\n                        3,\n                        2,\n                        1\n                    ],\n                    [\n                        3,\n                        3,\n                        1,\n                        1,\n                        2,\n                        1\n                    ],\n                    [\n                        3,\n                        1,\n                        2,\n                        1,\n                        1,\n                        3\n                    ],\n                    [\n                        3,\n                        1,\n                        2,\n                        3,\n                        1,\n                        1\n                    ],\n                    [\n                        3,\n                        3,\n                        2,\n                        1,\n                        1,\n                        1\n                    ],\n                    [\n                        3,\n                        1,\n                        4,\n                        1,\n                        1,\n                        1\n                    ],\n                    [\n                        2,\n                        2,\n                        1,\n                        4,\n                        1,\n                        1\n                    ],\n                    [\n                        4,\n                        3,\n                        1,\n                        1,\n                        1,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        1,\n                        2,\n                        2,\n                        4\n                    ],\n                    [\n                        1,\n                        1,\n                        1,\n                        4,\n                        2,\n                        2\n                    ],\n                    [\n                        1,\n                        2,\n                        1,\n                        1,\n                        2,\n                        4\n                    ],\n                    [\n                        1,\n                        2,\n                        1,\n                        4,\n                        2,\n                        1\n                    ],\n                    [\n                        1,\n                        4,\n                        1,\n                        1,\n                        2,\n                        2\n                    ],\n                    [\n                        1,\n                        4,\n                        1,\n                        2,\n                        2,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        2,\n                        2,\n                        1,\n                        4\n                    ],\n                    [\n                        1,\n                        1,\n                        2,\n                        4,\n                        1,\n                        2\n                    ],\n                    [\n                        1,\n                        2,\n                        2,\n                        1,\n                        1,\n                        4\n                    ],\n                    [\n                        1,\n                        2,\n                        2,\n                        4,\n                        1,\n                        1\n                    ],\n                    [\n                        1,\n                        4,\n                        2,\n                        1,\n                        1,\n                        2\n                    ],\n                    [\n                        1,\n                        4,\n                        2,\n                        2,\n                        1,\n                        1\n                    ],\n                    [\n                        2,\n                        4,\n                        1,\n                        2,\n                        1,\n                        1\n                    ],\n                    [\n                        2,\n                        2,\n                        1,\n                        1,\n                        1,\n                        4\n                    ],\n                    [\n                        4,\n                        1,\n                        3,\n                        1,\n                        1,\n                        1\n                    ],\n                    [\n                        2,\n                        4,\n                        1,\n                        1,\n                        1,\n                        2\n                    ],\n                    [\n                        1,\n                        3,\n                        4,\n                        1,\n                        1,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        1,\n                        2,\n                        4,\n                        2\n                    ],\n                    [\n                        1,\n                        2,\n                        1,\n                        1,\n                        4,\n                        2\n                    ],\n                    [\n                        1,\n                        2,\n                        1,\n                        2,\n                        4,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        4,\n                        2,\n                        1,\n                        2\n                    ],\n                    [\n                        1,\n                        2,\n                        4,\n                        1,\n                        1,\n                        2\n                    ],\n                    [\n                        1,\n                        2,\n                        4,\n                        2,\n                        1,\n                        1\n                    ],\n                    [\n                        4,\n                        1,\n                        1,\n                        2,\n                        1,\n                        2\n                    ],\n                    [\n                        4,\n                        2,\n                        1,\n                        1,\n                        1,\n                        2\n                    ],\n                    [\n                        4,\n                        2,\n                        1,\n                        2,\n                        1,\n                        1\n                    ],\n                    [\n                        2,\n                        1,\n                        2,\n                        1,\n                        4,\n                        1\n                    ],\n                    [\n                        2,\n                        1,\n                        4,\n                        1,\n                        2,\n                        1\n                    ],\n                    [\n                        4,\n                        1,\n                        2,\n                        1,\n                        2,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        1,\n                        1,\n                        4,\n                        3\n                    ],\n                    [\n                        1,\n                        1,\n                        1,\n                        3,\n                        4,\n                        1\n                    ],\n                    [\n                        1,\n                        3,\n                        1,\n                        1,\n                        4,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        4,\n                        1,\n                        1,\n                        3\n                    ],\n                    [\n                        1,\n                        1,\n                        4,\n                        3,\n                        1,\n                        1\n                    ],\n                    [\n                        4,\n                        1,\n                        1,\n                        1,\n                        1,\n                        3\n                    ],\n                    [\n                        4,\n                        1,\n                        1,\n                        3,\n                        1,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        3,\n                        1,\n                        4,\n                        1\n                    ],\n                    [\n                        1,\n                        1,\n                        4,\n                        1,\n                        3,\n                        1\n                    ],\n                    [\n                        3,\n                        1,\n                        1,\n                        1,\n                        4,\n                        1\n                    ],\n                    [\n                        4,\n                        1,\n                        1,\n                        1,\n                        3,\n                        1\n                    ],\n                    [\n                        2,\n                        1,\n                        1,\n                        4,\n                        1,\n                        2\n                    ],\n                    [\n                        2,\n                        1,\n                        1,\n                        2,\n                        1,\n                        4\n                    ],\n                    [\n                        2,\n                        1,\n                        1,\n                        2,\n                        3,\n                        2\n                    ],\n                    [\n                        2,\n                        3,\n                        3,\n                        1,\n                        1,\n                        1,\n                        2\n                    ]\n                ]);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"SINGLE_CODE_ERROR\", 0.64);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"AVG_CODE_ERROR\", 0.30);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"code_128\");\n                defineProperty_default()(assertThisInitialized_default()(_this), \"MODULE_INDICES\", {\n                    bar: [\n                        0,\n                        2,\n                        4\n                    ],\n                    space: [\n                        1,\n                        3,\n                        5\n                    ]\n                });\n                return _this;\n            }\n            createClass_default()(Code128Reader, [\n                {\n                    key: \"_decodeCode\",\n                    value: function _decodeCode(start, correction) {\n                        var bestMatch = {\n                            error: Number.MAX_VALUE,\n                            code: -1,\n                            start: start,\n                            end: start,\n                            correction: {\n                                bar: 1,\n                                space: 1\n                            }\n                        };\n                        var counter = [\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                        var offset = start;\n                        var isWhite = !this._row[offset];\n                        var counterPos = 0;\n                        for(var i = offset; i < this._row.length; i++){\n                            if (this._row[i] ^ (isWhite ? 1 : 0)) {\n                                counter[counterPos]++;\n                            } else {\n                                if (counterPos === counter.length - 1) {\n                                    if (correction) {\n                                        this._correct(counter, correction);\n                                    }\n                                    for(var code = 0; code < this.CODE_PATTERN.length; code++){\n                                        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);\n                                        if (error < bestMatch.error) {\n                                            bestMatch.code = code;\n                                            bestMatch.error = error;\n                                        }\n                                    }\n                                    bestMatch.end = i;\n                                    if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {\n                                        return null;\n                                    }\n                                    if (this.CODE_PATTERN[bestMatch.code]) {\n                                        bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);\n                                        bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);\n                                    }\n                                    return bestMatch;\n                                } else {\n                                    counterPos++;\n                                }\n                                counter[counterPos] = 1;\n                                isWhite = !isWhite;\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_correct\",\n                    value: function _correct(counter, correction) {\n                        this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);\n                        this._correctBars(counter, correction.space, this.MODULE_INDICES.space);\n                    }\n                },\n                {\n                    key: \"_findStart\",\n                    value: // TODO: _findStart and decodeCode share similar code, can we re-use some?\n                    function _findStart() {\n                        var counter = [\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                        var offset = this._nextSet(this._row);\n                        var bestMatch = {\n                            error: Number.MAX_VALUE,\n                            code: -1,\n                            start: 0,\n                            end: 0,\n                            correction: {\n                                bar: 1,\n                                space: 1\n                            }\n                        };\n                        var isWhite = false;\n                        var counterPos = 0;\n                        for(var i = offset; i < this._row.length; i++){\n                            if (this._row[i] ^ (isWhite ? 1 : 0)) {\n                                counter[counterPos]++;\n                            } else {\n                                if (counterPos === counter.length - 1) {\n                                    var sum = counter.reduce(function(prev, next) {\n                                        return prev + next;\n                                    }, 0);\n                                    for(var code = this.START_CODE_A; code <= this.START_CODE_C; code++){\n                                        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);\n                                        if (error < bestMatch.error) {\n                                            bestMatch.code = code;\n                                            bestMatch.error = error;\n                                        }\n                                    }\n                                    if (bestMatch.error < this.AVG_CODE_ERROR) {\n                                        bestMatch.start = i - sum;\n                                        bestMatch.end = i;\n                                        bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);\n                                        bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);\n                                        return bestMatch;\n                                    }\n                                    for(var j = 0; j < 4; j++){\n                                        counter[j] = counter[j + 2];\n                                    }\n                                    counter[4] = 0;\n                                    counter[5] = 0;\n                                    counterPos--;\n                                } else {\n                                    counterPos++;\n                                }\n                                counter[counterPos] = 1;\n                                isWhite = !isWhite;\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"decode\",\n                    value: function decode(row, start) {\n                        var _this2 = this;\n                        var startInfo = this._findStart();\n                        if (startInfo === null) {\n                            return null;\n                        }\n                        // var self = this,\n                        //     done = false,\n                        //     result = [],\n                        //     multiplier = 0,\n                        //     checksum = 0,\n                        //     codeset,\n                        //     rawResult = [],\n                        //     decodedCodes = [],\n                        //     shiftNext = false,\n                        //     unshift,\n                        //     removeLastCharacter = true;\n                        var code = {\n                            code: startInfo.code,\n                            start: startInfo.start,\n                            end: startInfo.end,\n                            correction: {\n                                bar: startInfo.correction.bar,\n                                space: startInfo.correction.space\n                            }\n                        };\n                        var decodedCodes = [];\n                        decodedCodes.push(code);\n                        var checksum = code.code;\n                        var codeset = function(c) {\n                            switch(c){\n                                case _this2.START_CODE_A:\n                                    return _this2.CODE_A;\n                                case _this2.START_CODE_B:\n                                    return _this2.CODE_B;\n                                case _this2.START_CODE_C:\n                                    return _this2.CODE_C;\n                                default:\n                                    return null;\n                            }\n                        }(code.code);\n                        var done = false;\n                        var shiftNext = false;\n                        var unshift = shiftNext;\n                        var removeLastCharacter = true;\n                        var multiplier = 0;\n                        var rawResult = [];\n                        var result = []; // TODO: i think this should be string only, but it creates problems if it is\n                        while(!done){\n                            unshift = shiftNext;\n                            shiftNext = false;\n                            code = this._decodeCode(code.end, code.correction);\n                            if (code !== null) {\n                                if (code.code !== this.STOP_CODE) {\n                                    removeLastCharacter = true;\n                                }\n                                if (code.code !== this.STOP_CODE) {\n                                    rawResult.push(code.code);\n                                    multiplier++;\n                                    checksum += multiplier * code.code;\n                                }\n                                decodedCodes.push(code);\n                                switch(codeset){\n                                    case this.CODE_A:\n                                        if (code.code < 64) {\n                                            result.push(String.fromCharCode(32 + code.code));\n                                        } else if (code.code < 96) {\n                                            result.push(String.fromCharCode(code.code - 64));\n                                        } else {\n                                            if (code.code !== this.STOP_CODE) {\n                                                removeLastCharacter = false;\n                                            }\n                                            switch(code.code){\n                                                case this.CODE_SHIFT:\n                                                    shiftNext = true;\n                                                    codeset = this.CODE_B;\n                                                    break;\n                                                case this.CODE_B:\n                                                    codeset = this.CODE_B;\n                                                    break;\n                                                case this.CODE_C:\n                                                    codeset = this.CODE_C;\n                                                    break;\n                                                case this.STOP_CODE:\n                                                    done = true;\n                                                    break;\n                                            }\n                                        }\n                                        break;\n                                    case this.CODE_B:\n                                        if (code.code < 96) {\n                                            result.push(String.fromCharCode(32 + code.code));\n                                        } else {\n                                            if (code.code !== this.STOP_CODE) {\n                                                removeLastCharacter = false;\n                                            }\n                                            switch(code.code){\n                                                case this.CODE_SHIFT:\n                                                    shiftNext = true;\n                                                    codeset = this.CODE_A;\n                                                    break;\n                                                case this.CODE_A:\n                                                    codeset = this.CODE_A;\n                                                    break;\n                                                case this.CODE_C:\n                                                    codeset = this.CODE_C;\n                                                    break;\n                                                case this.STOP_CODE:\n                                                    done = true;\n                                                    break;\n                                            }\n                                        }\n                                        break;\n                                    case this.CODE_C:\n                                        if (code.code < 100) {\n                                            result.push(code.code < 10 ? \"0\" + code.code : code.code);\n                                        } else {\n                                            if (code.code !== this.STOP_CODE) {\n                                                removeLastCharacter = false;\n                                            }\n                                            switch(code.code){\n                                                case this.CODE_A:\n                                                    codeset = this.CODE_A;\n                                                    break;\n                                                case this.CODE_B:\n                                                    codeset = this.CODE_B;\n                                                    break;\n                                                case this.STOP_CODE:\n                                                    done = true;\n                                                    break;\n                                            }\n                                        }\n                                        break;\n                                }\n                            } else {\n                                done = true;\n                            }\n                            if (unshift) {\n                                codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;\n                            }\n                        }\n                        if (code === null) {\n                            return null;\n                        }\n                        code.end = this._nextUnset(this._row, code.end);\n                        if (!this._verifyTrailingWhitespace(code)) {\n                            return null;\n                        }\n                        checksum -= multiplier * rawResult[rawResult.length - 1];\n                        if (checksum % 103 !== rawResult[rawResult.length - 1]) {\n                            return null;\n                        }\n                        if (!result.length) {\n                            return null;\n                        }\n                        // remove last code from result (checksum)\n                        if (removeLastCharacter) {\n                            result.splice(result.length - 1, 1);\n                        }\n                        return {\n                            code: result.join(\"\"),\n                            start: startInfo.start,\n                            end: code.end,\n                            codeset: codeset,\n                            startInfo: startInfo,\n                            decodedCodes: decodedCodes,\n                            endInfo: code,\n                            format: this.FORMAT\n                        };\n                    }\n                },\n                {\n                    key: \"_verifyTrailingWhitespace\",\n                    value: function _verifyTrailingWhitespace(endInfo) {\n                        var self1 = this, trailingWhitespaceEnd;\n                        trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;\n                        if (trailingWhitespaceEnd < self1._row.length) {\n                            if (self1._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {\n                                return endInfo;\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"calculateCorrection\",\n                    value: function calculateCorrection(expected, normalized, indices) {\n                        var length = indices.length, sumNormalized = 0, sumExpected = 0;\n                        while(length--){\n                            sumExpected += expected[indices[length]];\n                            sumNormalized += normalized[indices[length]];\n                        }\n                        return sumExpected / sumNormalized;\n                    }\n                }\n            ]);\n            return Code128Reader;\n        }(barcode_reader);\n        /* harmony default export */ var code_128_reader = code_128_reader_Code128Reader;\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js\n        var get = __nested_webpack_require_254197__(14);\n        var get_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(get);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js\n        var toConsumableArray = __nested_webpack_require_254197__(34);\n        var toConsumableArray_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(toConsumableArray);\n        // CONCATENATED MODULE: ./src/reader/code_39_reader.ts\n        function code_39_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = code_39_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function code_39_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        /* eslint-disable class-methods-use-this */ var ALPHABETH_STRING = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%\";\n        var code_39_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function(_char) {\n            return _char.charCodeAt(0);\n        }));\n        var code_39_reader_CHARACTER_ENCODINGS = new Uint16Array([\n            0x034,\n            0x121,\n            0x061,\n            0x160,\n            0x031,\n            0x130,\n            0x070,\n            0x025,\n            0x124,\n            0x064,\n            0x109,\n            0x049,\n            0x148,\n            0x019,\n            0x118,\n            0x058,\n            0x00D,\n            0x10C,\n            0x04C,\n            0x01C,\n            0x103,\n            0x043,\n            0x142,\n            0x013,\n            0x112,\n            0x052,\n            0x007,\n            0x106,\n            0x046,\n            0x016,\n            0x181,\n            0x0C1,\n            0x1C0,\n            0x091,\n            0x190,\n            0x0D0,\n            0x085,\n            0x184,\n            0x0C4,\n            0x094,\n            0x0A8,\n            0x0A2,\n            0x08A,\n            0x02A\n        ]);\n        var ASTERISK = 0x094;\n        var code_39_reader_Code39Reader = /*#__PURE__*/ function(_BarcodeReader) {\n            inherits_default()(Code39Reader, _BarcodeReader);\n            var _super = code_39_reader_createSuper(Code39Reader);\n            function Code39Reader() {\n                var _this;\n                classCallCheck_default()(this, Code39Reader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"code_39\");\n                return _this;\n            }\n            createClass_default()(Code39Reader, [\n                {\n                    key: \"_findStart\",\n                    value: function _findStart() {\n                        var offset = this._nextSet(this._row);\n                        var patternStart = offset;\n                        var counter = new Uint16Array([\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ]);\n                        var counterPos = 0;\n                        var isWhite = false;\n                        for(var i = offset; i < this._row.length; i++){\n                            // eslint-disable-next-line no-bitwise\n                            if (this._row[i] ^ (isWhite ? 1 : 0)) {\n                                counter[counterPos]++;\n                            } else {\n                                if (counterPos === counter.length - 1) {\n                                    // find start pattern\n                                    if (this._toPattern(counter) === ASTERISK) {\n                                        var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));\n                                        if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {\n                                            return {\n                                                start: patternStart,\n                                                end: i\n                                            };\n                                        }\n                                    }\n                                    patternStart += counter[0] + counter[1];\n                                    for(var j = 0; j < 7; j++){\n                                        counter[j] = counter[j + 2];\n                                    }\n                                    counter[7] = 0;\n                                    counter[8] = 0;\n                                    counterPos--;\n                                } else {\n                                    counterPos++;\n                                }\n                                counter[counterPos] = 1;\n                                isWhite = !isWhite;\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_toPattern\",\n                    value: function _toPattern(counters) {\n                        var numCounters = counters.length;\n                        var maxNarrowWidth = 0;\n                        var numWideBars = numCounters;\n                        var wideBarWidth = 0;\n                        while(numWideBars > 3){\n                            maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);\n                            numWideBars = 0;\n                            var pattern = 0;\n                            for(var i = 0; i < numCounters; i++){\n                                if (counters[i] > maxNarrowWidth) {\n                                    // eslint-disable-next-line no-bitwise\n                                    pattern |= 1 << numCounters - 1 - i;\n                                    numWideBars++;\n                                    wideBarWidth += counters[i];\n                                }\n                            }\n                            if (numWideBars === 3) {\n                                for(var _i = 0; _i < numCounters && numWideBars > 0; _i++){\n                                    if (counters[_i] > maxNarrowWidth) {\n                                        numWideBars--;\n                                        if (counters[_i] * 2 >= wideBarWidth) {\n                                            return -1;\n                                        }\n                                    }\n                                }\n                                return pattern;\n                            }\n                        }\n                        return -1;\n                    }\n                },\n                {\n                    key: \"_findNextWidth\",\n                    value: function _findNextWidth(counters, current) {\n                        var minWidth = Number.MAX_VALUE;\n                        for(var i = 0; i < counters.length; i++){\n                            if (counters[i] < minWidth && counters[i] > current) {\n                                minWidth = counters[i];\n                            }\n                        }\n                        return minWidth;\n                    }\n                },\n                {\n                    key: \"_patternToChar\",\n                    value: function _patternToChar(pattern) {\n                        for(var i = 0; i < code_39_reader_CHARACTER_ENCODINGS.length; i++){\n                            if (code_39_reader_CHARACTER_ENCODINGS[i] === pattern) {\n                                return String.fromCharCode(code_39_reader_ALPHABET[i]);\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_verifyTrailingWhitespace\",\n                    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {\n                        var patternSize = array_helper[\"a\" /* default */ ].sum(counters);\n                        var trailingWhitespaceEnd = nextStart - lastStart - patternSize;\n                        if (trailingWhitespaceEnd * 3 >= patternSize) {\n                            return true;\n                        }\n                        return false;\n                    }\n                },\n                {\n                    key: \"decode\",\n                    value: function decode() {\n                        var counters = new Uint16Array([\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ]);\n                        var result = [];\n                        var start = this._findStart();\n                        if (!start) {\n                            return null;\n                        }\n                        var nextStart = this._nextSet(this._row, start.end);\n                        var decodedChar;\n                        var lastStart;\n                        do {\n                            counters = this._toCounters(nextStart, counters);\n                            var pattern = this._toPattern(counters);\n                            if (pattern < 0) {\n                                return null;\n                            }\n                            decodedChar = this._patternToChar(pattern);\n                            if (decodedChar === null) {\n                                return null;\n                            }\n                            result.push(decodedChar);\n                            lastStart = nextStart;\n                            nextStart += array_helper[\"a\" /* default */ ].sum(counters);\n                            nextStart = this._nextSet(this._row, nextStart);\n                        }while (decodedChar !== \"*\");\n                        result.pop();\n                        if (!result.length) {\n                            return null;\n                        }\n                        if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {\n                            return null;\n                        }\n                        return {\n                            code: result.join(\"\"),\n                            start: start.start,\n                            end: nextStart,\n                            startInfo: start,\n                            decodedCodes: result,\n                            format: this.FORMAT\n                        };\n                    }\n                }\n            ]);\n            return Code39Reader;\n        }(barcode_reader);\n        /* harmony default export */ var code_39_reader = code_39_reader_Code39Reader;\n        // CONCATENATED MODULE: ./src/reader/code_32_reader.ts\n        function code_32_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = code_32_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function code_32_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        var patterns = {\n            AEIO: /[AEIO]/g,\n            AZ09: /[A-Z0-9]/\n        };\n        var code32set = \"0123456789BCDFGHJKLMNPQRSTUVWXYZ\";\n        var code_32_reader_Code32Reader = /*#__PURE__*/ function(_Code39Reader) {\n            inherits_default()(Code32Reader, _Code39Reader);\n            var _super = code_32_reader_createSuper(Code32Reader);\n            function Code32Reader() {\n                var _this;\n                classCallCheck_default()(this, Code32Reader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"code_32_reader\");\n                return _this;\n            }\n            createClass_default()(Code32Reader, [\n                {\n                    key: \"_decodeCode32\",\n                    value: function _decodeCode32(code) {\n                        if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {\n                            return null;\n                        }\n                        var res = 0;\n                        for(var i = 0; i < code.length; i++){\n                            res = res * 32 + code32set.indexOf(code[i]);\n                        }\n                        var code32 = \"\".concat(res);\n                        if (code32.length < 9) {\n                            code32 = (\"000000000\" + code32).slice(-9);\n                        }\n                        return \"A\" + code32;\n                    }\n                },\n                {\n                    key: \"_checkChecksum\",\n                    value: function _checkChecksum(code) {\n                        return !!code;\n                    }\n                },\n                {\n                    key: \"decode\",\n                    value: function decode() {\n                        var result = get_default()(getPrototypeOf_default()(Code32Reader.prototype), \"decode\", this).call(this);\n                        if (!result) {\n                            return null;\n                        }\n                        var code = result.code;\n                        if (!code) {\n                            return null;\n                        }\n                        code = code.replace(patterns.AEIO, \"\");\n                        if (!this._checkChecksum(code)) {\n                            return null;\n                        }\n                        var code32 = this._decodeCode32(code);\n                        if (!code32) {\n                            return null;\n                        }\n                        result.code = code32;\n                        return result;\n                    }\n                }\n            ]);\n            return Code32Reader;\n        }(code_39_reader);\n        /* harmony default export */ var code_32_reader = code_32_reader_Code32Reader;\n        // CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts\n        function code_39_vin_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = code_39_vin_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function code_39_vin_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        /* eslint-disable class-methods-use-this */ var code_39_vin_reader_patterns = {\n            IOQ: /[IOQ]/g,\n            AZ09: /[A-Z0-9]{17}/\n        };\n        var code_39_vin_reader_Code39VINReader = /*#__PURE__*/ function(_Code39Reader) {\n            inherits_default()(Code39VINReader, _Code39Reader);\n            var _super = code_39_vin_reader_createSuper(Code39VINReader);\n            function Code39VINReader() {\n                var _this;\n                classCallCheck_default()(this, Code39VINReader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"code_39_vin\");\n                return _this;\n            }\n            createClass_default()(Code39VINReader, [\n                {\n                    key: \"_checkChecksum\",\n                    value: // TODO (this was todo in original repo, no text was there. sorry.)\n                    function _checkChecksum(code) {\n                        return !!code;\n                    }\n                },\n                {\n                    key: \"decode\",\n                    value: function decode() {\n                        var result = get_default()(getPrototypeOf_default()(Code39VINReader.prototype), \"decode\", this).call(this);\n                        if (!result) {\n                            return null;\n                        }\n                        var code = result.code;\n                        if (!code) {\n                            return null;\n                        }\n                        code = code.replace(code_39_vin_reader_patterns.IOQ, \"\");\n                        if (!code.match(code_39_vin_reader_patterns.AZ09)) {\n                            if (false) {}\n                            return null;\n                        }\n                        if (!this._checkChecksum(code)) {\n                            return null;\n                        }\n                        result.code = code;\n                        return result;\n                    }\n                }\n            ]);\n            return Code39VINReader;\n        }(code_39_reader);\n        /* harmony default export */ var code_39_vin_reader = code_39_vin_reader_Code39VINReader;\n        // CONCATENATED MODULE: ./src/reader/code_93_reader.ts\n        function code_93_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = code_93_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function code_93_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        var code_93_reader_ALPHABETH_STRING = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*\";\n        var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function(_char) {\n            return _char.charCodeAt(0);\n        }));\n        var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([\n            0x114,\n            0x148,\n            0x144,\n            0x142,\n            0x128,\n            0x124,\n            0x122,\n            0x150,\n            0x112,\n            0x10A,\n            0x1A8,\n            0x1A4,\n            0x1A2,\n            0x194,\n            0x192,\n            0x18A,\n            0x168,\n            0x164,\n            0x162,\n            0x134,\n            0x11A,\n            0x158,\n            0x14C,\n            0x146,\n            0x12C,\n            0x116,\n            0x1B4,\n            0x1B2,\n            0x1AC,\n            0x1A6,\n            0x196,\n            0x19A,\n            0x16C,\n            0x166,\n            0x136,\n            0x13A,\n            0x12E,\n            0x1D4,\n            0x1D2,\n            0x1CA,\n            0x16E,\n            0x176,\n            0x1AE,\n            0x126,\n            0x1DA,\n            0x1D6,\n            0x132,\n            0x15E\n        ]);\n        var code_93_reader_ASTERISK = 0x15E;\n        var code_93_reader_Code93Reader = /*#__PURE__*/ function(_BarcodeReader) {\n            inherits_default()(Code93Reader, _BarcodeReader);\n            var _super = code_93_reader_createSuper(Code93Reader);\n            function Code93Reader() {\n                var _this;\n                classCallCheck_default()(this, Code93Reader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"code_93\");\n                return _this;\n            }\n            createClass_default()(Code93Reader, [\n                {\n                    key: \"_patternToChar\",\n                    value: function _patternToChar(pattern) {\n                        for(var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++){\n                            if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {\n                                return String.fromCharCode(code_93_reader_ALPHABET[i]);\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_toPattern\",\n                    value: function _toPattern(counters) {\n                        var numCounters = counters.length;\n                        var sum = counters.reduce(function(prev, next) {\n                            return prev + next;\n                        }, 0);\n                        var pattern = 0;\n                        for(var i = 0; i < numCounters; i++){\n                            var normalized = Math.round(counters[i] * 9 / sum);\n                            if (normalized < 1 || normalized > 4) {\n                                return -1;\n                            }\n                            if ((i & 1) === 0) {\n                                for(var j = 0; j < normalized; j++){\n                                    pattern = pattern << 1 | 1;\n                                }\n                            } else {\n                                pattern <<= normalized;\n                            }\n                        }\n                        return pattern;\n                    }\n                },\n                {\n                    key: \"_findStart\",\n                    value: function _findStart() {\n                        var offset = this._nextSet(this._row);\n                        var patternStart = offset;\n                        var counter = new Uint16Array([\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ]);\n                        var counterPos = 0;\n                        var isWhite = false;\n                        for(var i = offset; i < this._row.length; i++){\n                            if (this._row[i] ^ (isWhite ? 1 : 0)) {\n                                counter[counterPos]++;\n                            } else {\n                                if (counterPos === counter.length - 1) {\n                                    // find start pattern\n                                    if (this._toPattern(counter) === code_93_reader_ASTERISK) {\n                                        var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));\n                                        if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {\n                                            return {\n                                                start: patternStart,\n                                                end: i\n                                            };\n                                        }\n                                    }\n                                    patternStart += counter[0] + counter[1];\n                                    for(var j = 0; j < 4; j++){\n                                        counter[j] = counter[j + 2];\n                                    }\n                                    counter[4] = 0;\n                                    counter[5] = 0;\n                                    counterPos--;\n                                } else {\n                                    counterPos++;\n                                }\n                                counter[counterPos] = 1;\n                                isWhite = !isWhite;\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_verifyEnd\",\n                    value: function _verifyEnd(lastStart, nextStart) {\n                        if (lastStart === nextStart || !this._row[nextStart]) {\n                            return false;\n                        }\n                        return true;\n                    }\n                },\n                {\n                    key: \"_decodeExtended\",\n                    value: function _decodeExtended(charArray) {\n                        var length = charArray.length;\n                        var result = [];\n                        for(var i = 0; i < length; i++){\n                            var _char2 = charArray[i];\n                            if (_char2 >= \"a\" && _char2 <= \"d\") {\n                                if (i > length - 2) {\n                                    return null;\n                                }\n                                var nextChar = charArray[++i];\n                                var nextCharCode = nextChar.charCodeAt(0);\n                                var decodedChar = void 0;\n                                switch(_char2){\n                                    case \"a\":\n                                        if (nextChar >= \"A\" && nextChar <= \"Z\") {\n                                            decodedChar = String.fromCharCode(nextCharCode - 64);\n                                        } else {\n                                            return null;\n                                        }\n                                        break;\n                                    case \"b\":\n                                        if (nextChar >= \"A\" && nextChar <= \"E\") {\n                                            decodedChar = String.fromCharCode(nextCharCode - 38);\n                                        } else if (nextChar >= \"F\" && nextChar <= \"J\") {\n                                            decodedChar = String.fromCharCode(nextCharCode - 11);\n                                        } else if (nextChar >= \"K\" && nextChar <= \"O\") {\n                                            decodedChar = String.fromCharCode(nextCharCode + 16);\n                                        } else if (nextChar >= \"P\" && nextChar <= \"S\") {\n                                            decodedChar = String.fromCharCode(nextCharCode + 43);\n                                        } else if (nextChar >= \"T\" && nextChar <= \"Z\") {\n                                            decodedChar = String.fromCharCode(127);\n                                        } else {\n                                            return null;\n                                        }\n                                        break;\n                                    case \"c\":\n                                        if (nextChar >= \"A\" && nextChar <= \"O\") {\n                                            decodedChar = String.fromCharCode(nextCharCode - 32);\n                                        } else if (nextChar === \"Z\") {\n                                            decodedChar = \":\";\n                                        } else {\n                                            return null;\n                                        }\n                                        break;\n                                    case \"d\":\n                                        if (nextChar >= \"A\" && nextChar <= \"Z\") {\n                                            decodedChar = String.fromCharCode(nextCharCode + 32);\n                                        } else {\n                                            return null;\n                                        }\n                                        break;\n                                    default:\n                                        console.warn(\"* code_93_reader _decodeExtended hit default case, this may be an error\", decodedChar);\n                                        return null;\n                                }\n                                result.push(decodedChar);\n                            } else {\n                                result.push(_char2);\n                            }\n                        }\n                        return result;\n                    }\n                },\n                {\n                    key: \"_matchCheckChar\",\n                    value: function _matchCheckChar(charArray, index, maxWeight) {\n                        var arrayToCheck = charArray.slice(0, index);\n                        var length = arrayToCheck.length;\n                        var weightedSums = arrayToCheck.reduce(function(sum, _char3, i) {\n                            var weight = (i * -1 + (length - 1)) % maxWeight + 1;\n                            var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));\n                            return sum + weight * value;\n                        }, 0);\n                        var checkChar = code_93_reader_ALPHABET[weightedSums % 47];\n                        return checkChar === charArray[index].charCodeAt(0);\n                    }\n                },\n                {\n                    key: \"_verifyChecksums\",\n                    value: function _verifyChecksums(charArray) {\n                        return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);\n                    }\n                },\n                {\n                    key: \"decode\",\n                    value: function decode(row, start) {\n                        start = this._findStart();\n                        if (!start) {\n                            return null;\n                        }\n                        var counters = new Uint16Array([\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ]);\n                        var result = [];\n                        var nextStart = this._nextSet(this._row, start.end);\n                        var lastStart;\n                        var decodedChar;\n                        do {\n                            counters = this._toCounters(nextStart, counters);\n                            var pattern = this._toPattern(counters);\n                            if (pattern < 0) {\n                                return null;\n                            }\n                            decodedChar = this._patternToChar(pattern);\n                            if (decodedChar === null) {\n                                return null;\n                            }\n                            result.push(decodedChar);\n                            lastStart = nextStart;\n                            nextStart += array_helper[\"a\" /* default */ ].sum(counters);\n                            nextStart = this._nextSet(this._row, nextStart);\n                        }while (decodedChar !== \"*\");\n                        result.pop();\n                        if (!result.length) {\n                            return null;\n                        }\n                        if (!this._verifyEnd(lastStart, nextStart)) {\n                            return null;\n                        }\n                        if (!this._verifyChecksums(result)) {\n                            return null;\n                        }\n                        result = result.slice(0, result.length - 2);\n                        // yes, this is an assign inside an if.\n                        if ((result = this._decodeExtended(result)) === null) {\n                            return null;\n                        }\n                        return {\n                            code: result.join(\"\"),\n                            start: start.start,\n                            end: nextStart,\n                            startInfo: start,\n                            decodedCodes: result,\n                            format: this.FORMAT\n                        };\n                    }\n                }\n            ]);\n            return Code93Reader;\n        }(barcode_reader);\n        /* harmony default export */ var code_93_reader = code_93_reader_Code93Reader;\n        // CONCATENATED MODULE: ./src/reader/ean_reader.ts\n        function ownKeys(e, r) {\n            var t = Object.keys(e);\n            if (Object.getOwnPropertySymbols) {\n                var o = Object.getOwnPropertySymbols(e);\n                r && (o = o.filter(function(r) {\n                    return Object.getOwnPropertyDescriptor(e, r).enumerable;\n                })), t.push.apply(t, o);\n            }\n            return t;\n        }\n        function _objectSpread(e) {\n            for(var r = 1; r < arguments.length; r++){\n                var t = null != arguments[r] ? arguments[r] : {};\n                r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n                    defineProperty_default()(e, r, t[r]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n                    Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n                });\n            }\n            return e;\n        }\n        function ean_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function ean_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        // const CODE_L_START = 0;\n        var CODE_G_START = 10;\n        var ean_reader_START_PATTERN = [\n            1,\n            1,\n            1\n        ];\n        var MIDDLE_PATTERN = [\n            1,\n            1,\n            1,\n            1,\n            1\n        ];\n        var EXTENSION_START_PATTERN = [\n            1,\n            1,\n            2\n        ];\n        var ean_reader_CODE_PATTERN = [\n            [\n                3,\n                2,\n                1,\n                1\n            ],\n            [\n                2,\n                2,\n                2,\n                1\n            ],\n            [\n                2,\n                1,\n                2,\n                2\n            ],\n            [\n                1,\n                4,\n                1,\n                1\n            ],\n            [\n                1,\n                1,\n                3,\n                2\n            ],\n            [\n                1,\n                2,\n                3,\n                1\n            ],\n            [\n                1,\n                1,\n                1,\n                4\n            ],\n            [\n                1,\n                3,\n                1,\n                2\n            ],\n            [\n                1,\n                2,\n                1,\n                3\n            ],\n            [\n                3,\n                1,\n                1,\n                2\n            ],\n            [\n                1,\n                1,\n                2,\n                3\n            ],\n            [\n                1,\n                2,\n                2,\n                2\n            ],\n            [\n                2,\n                2,\n                1,\n                2\n            ],\n            [\n                1,\n                1,\n                4,\n                1\n            ],\n            [\n                2,\n                3,\n                1,\n                1\n            ],\n            [\n                1,\n                3,\n                2,\n                1\n            ],\n            [\n                4,\n                1,\n                1,\n                1\n            ],\n            [\n                2,\n                1,\n                3,\n                1\n            ],\n            [\n                3,\n                1,\n                2,\n                1\n            ],\n            [\n                2,\n                1,\n                1,\n                3\n            ]\n        ];\n        var CODE_FREQUENCY = [\n            0,\n            11,\n            13,\n            14,\n            19,\n            25,\n            28,\n            21,\n            22,\n            26\n        ];\n        // const SINGLE_CODE_ERROR = 0.70;\n        var AVG_CODE_ERROR = 0.48;\n        var ean_reader_EANReader = /*#__PURE__*/ function(_BarcodeReader) {\n            inherits_default()(EANReader, _BarcodeReader);\n            var _super = ean_reader_createSuper(EANReader);\n            // TODO: does this need to be in the class?\n            function EANReader(config, supplements) {\n                var _this;\n                classCallCheck_default()(this, EANReader);\n                _this = _super.call(this, merge_default()({\n                    supplements: []\n                }, config), supplements);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"ean_13\");\n                defineProperty_default()(assertThisInitialized_default()(_this), \"SINGLE_CODE_ERROR\", 0.70);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"STOP_PATTERN\", [\n                    1,\n                    1,\n                    1\n                ]);\n                return _this;\n            }\n            createClass_default()(EANReader, [\n                {\n                    key: \"_findPattern\",\n                    value: function _findPattern(pattern, offset, isWhite, tryHarder) {\n                        var counter = new Array(pattern.length).fill(0);\n                        var bestMatch = {\n                            error: Number.MAX_VALUE,\n                            start: 0,\n                            end: 0\n                        };\n                        var epsilon = AVG_CODE_ERROR;\n                        // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);\n                        var counterPos = 0;\n                        if (!offset) {\n                            offset = this._nextSet(this._row);\n                        }\n                        var found = false;\n                        for(var i = offset; i < this._row.length; i++){\n                            // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);\n                            if (this._row[i] ^ (isWhite ? 1 : 0)) {\n                                counter[counterPos] += 1;\n                            } else {\n                                if (counterPos === counter.length - 1) {\n                                    var error = this._matchPattern(counter, pattern);\n                                    // console.warn('* matchPattern', error, counter, pattern);\n                                    if (error < epsilon && bestMatch.error && error < bestMatch.error) {\n                                        found = true;\n                                        bestMatch.error = error;\n                                        bestMatch.start = i - counter.reduce(function(sum, value) {\n                                            return sum + value;\n                                        }, 0);\n                                        bestMatch.end = i;\n                                        // console.warn('* return bestMatch', JSON.stringify(bestMatch));\n                                        return bestMatch;\n                                    }\n                                    if (tryHarder) {\n                                        for(var j = 0; j < counter.length - 2; j++){\n                                            counter[j] = counter[j + 2];\n                                        }\n                                        counter[counter.length - 2] = 0;\n                                        counter[counter.length - 1] = 0;\n                                        counterPos--;\n                                    }\n                                } else {\n                                    counterPos++;\n                                }\n                                counter[counterPos] = 1;\n                                isWhite = !isWhite;\n                            }\n                        }\n                        if (found) {\n                        // console.warn('* return bestMatch', JSON.stringify(bestMatch));\n                        } else {\n                        // console.warn('* return null');\n                        }\n                        return found ? bestMatch : null;\n                    }\n                },\n                {\n                    key: \"_decodeCode\",\n                    value: function _decodeCode(start, coderange) {\n                        // console.warn('* decodeCode', start, coderange);\n                        var counter = [\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                        var offset = start;\n                        var bestMatch = {\n                            error: Number.MAX_VALUE,\n                            code: -1,\n                            start: start,\n                            end: start\n                        };\n                        var epsilon = AVG_CODE_ERROR;\n                        var isWhite = !this._row[offset];\n                        var counterPos = 0;\n                        if (!coderange) {\n                            // console.warn('* decodeCode before length');\n                            coderange = ean_reader_CODE_PATTERN.length;\n                        // console.warn('* decodeCode after length');\n                        }\n                        var found = false;\n                        for(var i = offset; i < this._row.length; i++){\n                            if (this._row[i] ^ (isWhite ? 1 : 0)) {\n                                counter[counterPos]++;\n                            } else {\n                                if (counterPos === counter.length - 1) {\n                                    for(var code = 0; code < coderange; code++){\n                                        var error = this._matchPattern(counter, ean_reader_CODE_PATTERN[code]);\n                                        bestMatch.end = i;\n                                        if (error < bestMatch.error) {\n                                            bestMatch.code = code;\n                                            bestMatch.error = error;\n                                        }\n                                    }\n                                    if (bestMatch.error > epsilon) {\n                                        // console.warn('* return null');\n                                        return null;\n                                    }\n                                    // console.warn('* return bestMatch', JSON.stringify(bestMatch));\n                                    return bestMatch;\n                                } else {\n                                    counterPos++;\n                                }\n                                counter[counterPos] = 1;\n                                isWhite = !isWhite;\n                            }\n                        }\n                        return found ? bestMatch : null;\n                    }\n                },\n                {\n                    key: \"_findStart\",\n                    value: function _findStart() {\n                        // console.warn('* findStart');\n                        var offset = this._nextSet(this._row);\n                        var startInfo = null;\n                        while(!startInfo){\n                            startInfo = this._findPattern(ean_reader_START_PATTERN, offset, false, true);\n                            // console.warn('* startInfo=', JSON.stringify(startInfo));\n                            if (!startInfo) {\n                                return null;\n                            }\n                            var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);\n                            if (leadingWhitespaceStart >= 0) {\n                                if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {\n                                    // console.warn('* returning startInfo');\n                                    return startInfo;\n                                }\n                            }\n                            offset = startInfo.end;\n                            startInfo = null;\n                        }\n                        // console.warn('* returning null');\n                        return null;\n                    }\n                },\n                {\n                    key: \"_calculateFirstDigit\",\n                    value: function _calculateFirstDigit(codeFrequency) {\n                        // console.warn('* calculateFirstDigit', codeFrequency);\n                        for(var i = 0; i < CODE_FREQUENCY.length; i++){\n                            if (codeFrequency === CODE_FREQUENCY[i]) {\n                                // console.warn('* returning', i);\n                                return i;\n                            }\n                        }\n                        // console.warn('* return null');\n                        return null;\n                    }\n                },\n                {\n                    key: \"_decodePayload\",\n                    value: function _decodePayload(inCode, result, decodedCodes) {\n                        // console.warn('* decodePayload', inCode, result, decodedCodes);\n                        var outCode = _objectSpread({}, inCode);\n                        var codeFrequency = 0x0;\n                        for(var i = 0; i < 6; i++){\n                            outCode = this._decodeCode(outCode.end);\n                            // console.warn('* decodeCode=', outCode);\n                            if (!outCode) {\n                                // console.warn('* return null');\n                                return null;\n                            }\n                            if (outCode.code >= CODE_G_START) {\n                                outCode.code -= CODE_G_START;\n                                codeFrequency |= 1 << 5 - i;\n                            } else {\n                                codeFrequency |= 0 << 5 - i;\n                            }\n                            result.push(outCode.code);\n                            decodedCodes.push(outCode);\n                        }\n                        var firstDigit = this._calculateFirstDigit(codeFrequency);\n                        // console.warn('* firstDigit=', firstDigit);\n                        if (firstDigit === null) {\n                            // console.warn('* return null');\n                            return null;\n                        }\n                        result.unshift(firstDigit);\n                        var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false);\n                        // console.warn('* findPattern=', JSON.stringify(middlePattern));\n                        if (middlePattern === null || !middlePattern.end) {\n                            // console.warn('* return null');\n                            return null;\n                        }\n                        decodedCodes.push(middlePattern);\n                        for(var _i = 0; _i < 6; _i++){\n                            middlePattern = this._decodeCode(middlePattern.end, CODE_G_START);\n                            // console.warn('* decodeCode=', JSON.stringify(middlePattern));\n                            if (!middlePattern) {\n                                // console.warn('* return null');\n                                return null;\n                            }\n                            decodedCodes.push(middlePattern);\n                            result.push(middlePattern.code);\n                        }\n                        // console.warn('* end code=', JSON.stringify(middlePattern));\n                        // console.warn('* end result=', JSON.stringify(result));\n                        // console.warn('* end decodedCodes=', decodedCodes);\n                        return middlePattern;\n                    }\n                },\n                {\n                    key: \"_verifyTrailingWhitespace\",\n                    value: function _verifyTrailingWhitespace(endInfo) {\n                        // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));\n                        var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);\n                        if (trailingWhitespaceEnd < this._row.length) {\n                            if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {\n                                // console.warn('* returning', JSON.stringify(endInfo));\n                                return endInfo;\n                            }\n                        }\n                        // console.warn('* return null');\n                        return null;\n                    }\n                },\n                {\n                    key: \"_findEnd\",\n                    value: function _findEnd(offset, isWhite) {\n                        // console.warn('* findEnd', offset, isWhite);\n                        var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);\n                        return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;\n                    }\n                },\n                {\n                    key: \"_checksum\",\n                    value: function _checksum(result) {\n                        // console.warn('* _checksum', result);\n                        var sum = 0;\n                        for(var i = result.length - 2; i >= 0; i -= 2){\n                            sum += result[i];\n                        }\n                        sum *= 3;\n                        for(var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2){\n                            sum += result[_i2];\n                        }\n                        // console.warn('* end checksum', sum % 10 === 0);\n                        return sum % 10 === 0;\n                    }\n                },\n                {\n                    key: \"_decodeExtensions\",\n                    value: function _decodeExtensions(offset) {\n                        var start = this._nextSet(this._row, offset);\n                        var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);\n                        if (startInfo === null) {\n                            return null;\n                        }\n                        // console.warn('* decodeExtensions', this.supplements);\n                        // console.warn('* there are ', this.supplements.length, ' supplements');\n                        for(var i = 0; i < this.supplements.length; i++){\n                            // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);\n                            try {\n                                var result = this.supplements[i].decode(this._row, startInfo.end);\n                                // console.warn('* decode result=', result);\n                                if (result !== null) {\n                                    return {\n                                        code: result.code,\n                                        start: start,\n                                        startInfo: startInfo,\n                                        end: result.end,\n                                        decodedCodes: result.decodedCodes,\n                                        format: this.supplements[i].FORMAT\n                                    };\n                                }\n                            } catch (err) {\n                                console.error(\"* decodeExtensions error in \", this.supplements[i], \": \", err);\n                            }\n                        }\n                        // console.warn('* end decodeExtensions');\n                        return null;\n                    }\n                },\n                {\n                    key: \"decode\",\n                    value: function decode(row, start) {\n                        // console.warn('* decode', row);\n                        // console.warn('* decode', start);\n                        var result = new Array();\n                        var decodedCodes = new Array();\n                        var resultInfo = {};\n                        var startInfo = this._findStart();\n                        if (!startInfo) {\n                            return null;\n                        }\n                        var code = {\n                            start: startInfo.start,\n                            end: startInfo.end\n                        };\n                        decodedCodes.push(code);\n                        code = this._decodePayload(code, result, decodedCodes);\n                        if (!code) {\n                            return null;\n                        }\n                        code = this._findEnd(code.end, false);\n                        if (!code) {\n                            return null;\n                        }\n                        decodedCodes.push(code);\n                        // Checksum\n                        if (!this._checksum(result)) {\n                            return null;\n                        }\n                        // console.warn('* this.supplements=', this.supplements);\n                        if (this.supplements.length > 0) {\n                            var supplement = this._decodeExtensions(code.end);\n                            // console.warn('* decodeExtensions returns', supplement);\n                            if (!supplement) {\n                                return null;\n                            }\n                            if (!supplement.decodedCodes) {\n                                return null;\n                            }\n                            var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];\n                            var endInfo = {\n                                start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),\n                                end: lastCode.end\n                            };\n                            if (!this._verifyTrailingWhitespace(endInfo)) {\n                                return null;\n                            }\n                            resultInfo = {\n                                supplement: supplement,\n                                code: result.join(\"\") + supplement.code\n                            };\n                        }\n                        return _objectSpread(_objectSpread({\n                            code: result.join(\"\"),\n                            start: startInfo.start,\n                            end: code.end,\n                            startInfo: startInfo,\n                            decodedCodes: decodedCodes\n                        }, resultInfo), {}, {\n                            format: this.FORMAT\n                        });\n                    }\n                }\n            ]);\n            return EANReader;\n        }(barcode_reader);\n        /* harmony default export */ var ean_reader = ean_reader_EANReader;\n        // CONCATENATED MODULE: ./src/reader/ean_2_reader.ts\n        function ean_2_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = ean_2_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function ean_2_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        var ean_2_reader_EAN2Reader = /*#__PURE__*/ function(_EANReader) {\n            inherits_default()(EAN2Reader, _EANReader);\n            var _super = ean_2_reader_createSuper(EAN2Reader);\n            function EAN2Reader() {\n                var _this;\n                classCallCheck_default()(this, EAN2Reader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"ean_2\");\n                return _this;\n            }\n            createClass_default()(EAN2Reader, [\n                {\n                    key: \"decode\",\n                    value: function decode(row, start) {\n                        if (row) {\n                            this._row = row;\n                        }\n                        var codeFrequency = 0;\n                        var offset = start;\n                        var end = this._row.length;\n                        var result = [];\n                        var decodedCodes = [];\n                        var code = null;\n                        if (offset === undefined) {\n                            return null;\n                        }\n                        for(var i = 0; i < 2 && offset < end; i++){\n                            code = this._decodeCode(offset);\n                            if (!code) {\n                                return null;\n                            }\n                            decodedCodes.push(code);\n                            result.push(code.code % 10);\n                            if (code.code >= CODE_G_START) {\n                                codeFrequency |= 1 << 1 - i;\n                            }\n                            if (i !== 1) {\n                                offset = this._nextSet(this._row, code.end);\n                                offset = this._nextUnset(this._row, offset);\n                            }\n                        }\n                        if (result.length !== 2 || parseInt(result.join(\"\")) % 4 !== codeFrequency) {\n                            return null;\n                        }\n                        var startInfo = this._findStart();\n                        return {\n                            code: result.join(\"\"),\n                            decodedCodes: decodedCodes,\n                            end: code.end,\n                            format: this.FORMAT,\n                            startInfo: startInfo,\n                            start: startInfo.start\n                        };\n                    }\n                }\n            ]);\n            return EAN2Reader;\n        }(ean_reader);\n        ;\n        /* harmony default export */ var ean_2_reader = ean_2_reader_EAN2Reader;\n        // CONCATENATED MODULE: ./src/reader/ean_5_reader.ts\n        function ean_5_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = ean_5_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function ean_5_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        var CHECK_DIGIT_ENCODINGS = [\n            24,\n            20,\n            18,\n            17,\n            12,\n            6,\n            3,\n            10,\n            9,\n            5\n        ];\n        function determineCheckDigit(codeFrequency) {\n            for(var i = 0; i < 10; i++){\n                if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {\n                    return i;\n                }\n            }\n            return null;\n        }\n        function extensionChecksum(result) {\n            var length = result.length;\n            var sum = 0;\n            for(var i = length - 2; i >= 0; i -= 2){\n                sum += result[i];\n            }\n            sum *= 3;\n            for(var _i = length - 1; _i >= 0; _i -= 2){\n                sum += result[_i];\n            }\n            sum *= 3;\n            return sum % 10;\n        }\n        var ean_5_reader_EAN5Reader = /*#__PURE__*/ function(_EANReader) {\n            inherits_default()(EAN5Reader, _EANReader);\n            var _super = ean_5_reader_createSuper(EAN5Reader);\n            function EAN5Reader() {\n                var _this;\n                classCallCheck_default()(this, EAN5Reader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"ean_5\");\n                return _this;\n            }\n            createClass_default()(EAN5Reader, [\n                {\n                    key: \"decode\",\n                    value: function decode(row, start) {\n                        if (start === undefined) {\n                            return null;\n                        }\n                        if (row) {\n                            this._row = row;\n                        }\n                        var codeFrequency = 0;\n                        var offset = start;\n                        var end = this._row.length;\n                        var code = null;\n                        var result = [];\n                        var decodedCodes = [];\n                        for(var i = 0; i < 5 && offset < end; i++){\n                            code = this._decodeCode(offset);\n                            if (!code) {\n                                return null;\n                            }\n                            decodedCodes.push(code);\n                            result.push(code.code % 10);\n                            if (code.code >= CODE_G_START) {\n                                codeFrequency |= 1 << 4 - i;\n                            }\n                            if (i !== 4) {\n                                offset = this._nextSet(this._row, code.end);\n                                offset = this._nextUnset(this._row, offset);\n                            }\n                        }\n                        if (result.length !== 5) {\n                            return null;\n                        }\n                        if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {\n                            return null;\n                        }\n                        var startInfo = this._findStart();\n                        return {\n                            code: result.join(\"\"),\n                            decodedCodes: decodedCodes,\n                            end: code.end,\n                            format: this.FORMAT,\n                            startInfo: startInfo,\n                            start: startInfo.start\n                        };\n                    }\n                }\n            ]);\n            return EAN5Reader;\n        }(ean_reader);\n        ;\n        /* harmony default export */ var ean_5_reader = ean_5_reader_EAN5Reader;\n        // CONCATENATED MODULE: ./src/reader/ean_8_reader.ts\n        function ean_8_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = ean_8_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function ean_8_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        var ean_8_reader_EAN8Reader = /*#__PURE__*/ function(_EANReader) {\n            inherits_default()(EAN8Reader, _EANReader);\n            var _super = ean_8_reader_createSuper(EAN8Reader);\n            function EAN8Reader() {\n                var _this;\n                classCallCheck_default()(this, EAN8Reader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"ean_8\");\n                return _this;\n            }\n            createClass_default()(EAN8Reader, [\n                {\n                    key: \"_decodePayload\",\n                    value: function _decodePayload(inCode, result, decodedCodes) {\n                        var code = inCode;\n                        for(var i = 0; i < 4; i++){\n                            code = this._decodeCode(code.end, CODE_G_START);\n                            if (!code) {\n                                return null;\n                            }\n                            result.push(code.code);\n                            decodedCodes.push(code);\n                        }\n                        code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);\n                        if (code === null) {\n                            return null;\n                        }\n                        decodedCodes.push(code);\n                        for(var _i = 0; _i < 4; _i++){\n                            code = this._decodeCode(code.end, CODE_G_START);\n                            if (!code) {\n                                return null;\n                            }\n                            decodedCodes.push(code);\n                            result.push(code.code);\n                        }\n                        return code;\n                    }\n                }\n            ]);\n            return EAN8Reader;\n        }(ean_reader);\n        /* harmony default export */ var ean_8_reader = ean_8_reader_EAN8Reader;\n        // CONCATENATED MODULE: ./src/reader/i2of5_reader.ts\n        function i2of5_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = i2of5_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function i2of5_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        // TODO: i2of5_reader and 2of5_reader share very similar code, make use of that\n        var i2of5_reader_N = 1;\n        var i2of5_reader_W = 3;\n        var i2of5_reader_I2of5Reader = /*#__PURE__*/ function(_BarcodeReader) {\n            inherits_default()(I2of5Reader, _BarcodeReader);\n            var _super = i2of5_reader_createSuper(I2of5Reader);\n            function I2of5Reader(opts) {\n                var _this;\n                classCallCheck_default()(this, I2of5Reader);\n                _this = _super.call(this, merge_default()({\n                    normalizeBarSpaceWidth: false\n                }, opts));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"barSpaceRatio\", [\n                    1,\n                    1\n                ]);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"SINGLE_CODE_ERROR\", 0.78);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"AVG_CODE_ERROR\", 0.38);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"START_PATTERN\", [\n                    i2of5_reader_N,\n                    i2of5_reader_N,\n                    i2of5_reader_N,\n                    i2of5_reader_N\n                ]);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"STOP_PATTERN\", [\n                    i2of5_reader_N,\n                    i2of5_reader_N,\n                    i2of5_reader_W\n                ]);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_PATTERN\", [\n                    [\n                        i2of5_reader_N,\n                        i2of5_reader_N,\n                        i2of5_reader_W,\n                        i2of5_reader_W,\n                        i2of5_reader_N\n                    ],\n                    [\n                        i2of5_reader_W,\n                        i2of5_reader_N,\n                        i2of5_reader_N,\n                        i2of5_reader_N,\n                        i2of5_reader_W\n                    ],\n                    [\n                        i2of5_reader_N,\n                        i2of5_reader_W,\n                        i2of5_reader_N,\n                        i2of5_reader_N,\n                        i2of5_reader_W\n                    ],\n                    [\n                        i2of5_reader_W,\n                        i2of5_reader_W,\n                        i2of5_reader_N,\n                        i2of5_reader_N,\n                        i2of5_reader_N\n                    ],\n                    [\n                        i2of5_reader_N,\n                        i2of5_reader_N,\n                        i2of5_reader_W,\n                        i2of5_reader_N,\n                        i2of5_reader_W\n                    ],\n                    [\n                        i2of5_reader_W,\n                        i2of5_reader_N,\n                        i2of5_reader_W,\n                        i2of5_reader_N,\n                        i2of5_reader_N\n                    ],\n                    [\n                        i2of5_reader_N,\n                        i2of5_reader_W,\n                        i2of5_reader_W,\n                        i2of5_reader_N,\n                        i2of5_reader_N\n                    ],\n                    [\n                        i2of5_reader_N,\n                        i2of5_reader_N,\n                        i2of5_reader_N,\n                        i2of5_reader_W,\n                        i2of5_reader_W\n                    ],\n                    [\n                        i2of5_reader_W,\n                        i2of5_reader_N,\n                        i2of5_reader_N,\n                        i2of5_reader_W,\n                        i2of5_reader_N\n                    ],\n                    [\n                        i2of5_reader_N,\n                        i2of5_reader_W,\n                        i2of5_reader_N,\n                        i2of5_reader_W,\n                        i2of5_reader_N\n                    ]\n                ]);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"MAX_CORRECTION_FACTOR\", 5);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"i2of5\");\n                if (opts.normalizeBarSpaceWidth) {\n                    _this.SINGLE_CODE_ERROR = 0.38;\n                    _this.AVG_CODE_ERROR = 0.09;\n                }\n                _this.config = opts;\n                return possibleConstructorReturn_default()(_this, assertThisInitialized_default()(_this));\n            }\n            createClass_default()(I2of5Reader, [\n                {\n                    key: \"_matchPattern\",\n                    value: function _matchPattern(counter, code) {\n                        if (this.config.normalizeBarSpaceWidth) {\n                            var counterSum = [\n                                0,\n                                0\n                            ];\n                            var codeSum = [\n                                0,\n                                0\n                            ];\n                            var correction = [\n                                0,\n                                0\n                            ];\n                            var correctionRatio = this.MAX_CORRECTION_FACTOR;\n                            var correctionRatioInverse = 1 / correctionRatio;\n                            for(var i = 0; i < counter.length; i++){\n                                counterSum[i % 2] += counter[i];\n                                codeSum[i % 2] += code[i];\n                            }\n                            correction[0] = codeSum[0] / counterSum[0];\n                            correction[1] = codeSum[1] / counterSum[1];\n                            correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);\n                            correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);\n                            this.barSpaceRatio = correction;\n                            for(var _i = 0; _i < counter.length; _i++){\n                                counter[_i] *= this.barSpaceRatio[_i % 2];\n                            }\n                        }\n                        return get_default()(getPrototypeOf_default()(I2of5Reader.prototype), \"_matchPattern\", this).call(this, counter, code);\n                    }\n                },\n                {\n                    key: \"_findPattern\",\n                    value: function _findPattern(pattern, offset) {\n                        var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                        var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n                        var counter = new Array(pattern.length).fill(0);\n                        var counterPos = 0;\n                        var bestMatch = {\n                            error: Number.MAX_VALUE,\n                            start: 0,\n                            end: 0\n                        };\n                        var epsilon = this.AVG_CODE_ERROR;\n                        isWhite = isWhite || false;\n                        tryHarder = tryHarder || false;\n                        if (!offset) {\n                            offset = this._nextSet(this._row);\n                        }\n                        for(var i = offset; i < this._row.length; i++){\n                            if (this._row[i] ^ (isWhite ? 1 : 0)) {\n                                counter[counterPos]++;\n                            } else {\n                                if (counterPos === counter.length - 1) {\n                                    var sum = counter.reduce(function(prev, next) {\n                                        return prev + next;\n                                    }, 0);\n                                    var error = this._matchPattern(counter, pattern);\n                                    if (error < epsilon) {\n                                        bestMatch.error = error;\n                                        bestMatch.start = i - sum;\n                                        bestMatch.end = i;\n                                        return bestMatch;\n                                    }\n                                    if (tryHarder) {\n                                        for(var j = 0; j < counter.length - 2; j++){\n                                            counter[j] = counter[j + 2];\n                                        }\n                                        counter[counter.length - 2] = 0;\n                                        counter[counter.length - 1] = 0;\n                                        counterPos--;\n                                    } else {\n                                        return null;\n                                    }\n                                } else {\n                                    counterPos++;\n                                }\n                                counter[counterPos] = 1;\n                                isWhite = !isWhite;\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_findStart\",\n                    value: function _findStart() {\n                        var leadingWhitespaceStart = 0;\n                        var offset = this._nextSet(this._row);\n                        var startInfo = null;\n                        var narrowBarWidth = 1;\n                        while(!startInfo){\n                            startInfo = this._findPattern(this.START_PATTERN, offset, false, true);\n                            if (!startInfo) {\n                                return null;\n                            }\n                            narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);\n                            leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;\n                            if (leadingWhitespaceStart >= 0) {\n                                if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {\n                                    return startInfo;\n                                }\n                            }\n                            offset = startInfo.end;\n                            startInfo = null;\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_verifyTrailingWhitespace\",\n                    value: function _verifyTrailingWhitespace(endInfo) {\n                        var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;\n                        if (trailingWhitespaceEnd < this._row.length) {\n                            if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {\n                                return endInfo;\n                            }\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_findEnd\",\n                    value: function _findEnd() {\n                        this._row.reverse();\n                        var endInfo = this._findPattern(this.STOP_PATTERN);\n                        this._row.reverse();\n                        if (endInfo === null) {\n                            return null;\n                        }\n                        // reverse numbers\n                        var tmp = endInfo.start;\n                        endInfo.start = this._row.length - endInfo.end;\n                        endInfo.end = this._row.length - tmp;\n                        return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;\n                    }\n                },\n                {\n                    key: \"_decodePair\",\n                    value: function _decodePair(counterPair) {\n                        var codes = [];\n                        for(var i = 0; i < counterPair.length; i++){\n                            var code = this._decodeCode(counterPair[i]);\n                            if (!code) {\n                                return null;\n                            }\n                            codes.push(code);\n                        }\n                        return codes;\n                    }\n                },\n                {\n                    key: \"_decodeCode\",\n                    value: function _decodeCode(counter) {\n                        var epsilon = this.AVG_CODE_ERROR;\n                        var bestMatch = {\n                            error: Number.MAX_VALUE,\n                            code: -1,\n                            start: 0,\n                            end: 0\n                        };\n                        for(var code = 0; code < this.CODE_PATTERN.length; code++){\n                            var error = this._matchPattern(counter, this.CODE_PATTERN[code]);\n                            if (error < bestMatch.error) {\n                                bestMatch.code = code;\n                                bestMatch.error = error;\n                            }\n                        }\n                        if (bestMatch.error < epsilon) {\n                            return bestMatch;\n                        }\n                        return null;\n                    }\n                },\n                {\n                    key: \"_decodePayload\",\n                    value: function _decodePayload(counters, result, decodedCodes) {\n                        var pos = 0;\n                        var counterLength = counters.length;\n                        var counterPair = [\n                            [\n                                0,\n                                0,\n                                0,\n                                0,\n                                0\n                            ],\n                            [\n                                0,\n                                0,\n                                0,\n                                0,\n                                0\n                            ]\n                        ];\n                        var codes = null;\n                        while(pos < counterLength){\n                            for(var i = 0; i < 5; i++){\n                                counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];\n                                counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];\n                                pos += 2;\n                            }\n                            codes = this._decodePair(counterPair);\n                            if (!codes) {\n                                return null;\n                            }\n                            for(var _i2 = 0; _i2 < codes.length; _i2++){\n                                result.push(codes[_i2].code + \"\");\n                                decodedCodes.push(codes[_i2]);\n                            }\n                        }\n                        return codes;\n                    }\n                },\n                {\n                    key: \"_verifyCounterLength\",\n                    value: function _verifyCounterLength(counters) {\n                        return counters.length % 10 === 0;\n                    }\n                },\n                {\n                    key: \"decode\",\n                    value: function decode(row, start) {\n                        var result = new Array();\n                        var decodedCodes = new Array();\n                        var startInfo = this._findStart();\n                        if (!startInfo) {\n                            return null;\n                        }\n                        decodedCodes.push(startInfo);\n                        var endInfo = this._findEnd();\n                        if (!endInfo) {\n                            return null;\n                        }\n                        var counters = this._fillCounters(startInfo.end, endInfo.start, false);\n                        if (!this._verifyCounterLength(counters)) {\n                            return null;\n                        }\n                        var code = this._decodePayload(counters, result, decodedCodes);\n                        if (!code) {\n                            return null;\n                        }\n                        if (result.length % 2 !== 0 || result.length < 6) {\n                            return null;\n                        }\n                        decodedCodes.push(endInfo);\n                        return {\n                            code: result.join(\"\"),\n                            start: startInfo.start,\n                            end: endInfo.end,\n                            startInfo: startInfo,\n                            decodedCodes: decodedCodes,\n                            format: this.FORMAT\n                        };\n                    }\n                }\n            ]);\n            return I2of5Reader;\n        }(barcode_reader);\n        /* harmony default export */ var i2of5_reader = i2of5_reader_I2of5Reader;\n        // CONCATENATED MODULE: ./src/reader/upc_e_reader.ts\n        function upc_e_reader_ownKeys(e, r) {\n            var t = Object.keys(e);\n            if (Object.getOwnPropertySymbols) {\n                var o = Object.getOwnPropertySymbols(e);\n                r && (o = o.filter(function(r) {\n                    return Object.getOwnPropertyDescriptor(e, r).enumerable;\n                })), t.push.apply(t, o);\n            }\n            return t;\n        }\n        function upc_e_reader_objectSpread(e) {\n            for(var r = 1; r < arguments.length; r++){\n                var t = null != arguments[r] ? arguments[r] : {};\n                r % 2 ? upc_e_reader_ownKeys(Object(t), !0).forEach(function(r) {\n                    defineProperty_default()(e, r, t[r]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : upc_e_reader_ownKeys(Object(t)).forEach(function(r) {\n                    Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n                });\n            }\n            return e;\n        }\n        function upc_e_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = upc_e_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function upc_e_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        var upc_e_reader_UPCEReader = /*#__PURE__*/ function(_EANReader) {\n            inherits_default()(UPCEReader, _EANReader);\n            var _super = upc_e_reader_createSuper(UPCEReader);\n            function UPCEReader() {\n                var _this;\n                classCallCheck_default()(this, UPCEReader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_FREQUENCY\", [\n                    [\n                        56,\n                        52,\n                        50,\n                        49,\n                        44,\n                        38,\n                        35,\n                        42,\n                        41,\n                        37\n                    ],\n                    [\n                        7,\n                        11,\n                        13,\n                        14,\n                        19,\n                        25,\n                        28,\n                        21,\n                        22,\n                        26\n                    ]\n                ]);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"STOP_PATTERN\", [\n                    1 / 6 * 7,\n                    1 / 6 * 7,\n                    1 / 6 * 7,\n                    1 / 6 * 7,\n                    1 / 6 * 7,\n                    1 / 6 * 7\n                ]);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"upc_e\");\n                return _this;\n            }\n            createClass_default()(UPCEReader, [\n                {\n                    key: \"_decodePayload\",\n                    value: function _decodePayload(inCode, result, decodedCodes) {\n                        var outCode = upc_e_reader_objectSpread({}, inCode);\n                        var codeFrequency = 0x0;\n                        for(var i = 0; i < 6; i++){\n                            outCode = this._decodeCode(outCode.end);\n                            if (!outCode) {\n                                return null;\n                            }\n                            if (outCode.code >= CODE_G_START) {\n                                outCode.code = outCode.code - CODE_G_START;\n                                codeFrequency |= 1 << 5 - i;\n                            }\n                            result.push(outCode.code);\n                            decodedCodes.push(outCode);\n                        }\n                        if (!this._determineParity(codeFrequency, result)) {\n                            return null;\n                        }\n                        return outCode;\n                    }\n                },\n                {\n                    key: \"_determineParity\",\n                    value: function _determineParity(codeFrequency, result) {\n                        for(var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++){\n                            for(var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++){\n                                if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {\n                                    result.unshift(nrSystem);\n                                    result.push(i);\n                                    return true;\n                                }\n                            }\n                        }\n                        return false;\n                    }\n                },\n                {\n                    key: \"_convertToUPCA\",\n                    value: function _convertToUPCA(result) {\n                        var upca = [\n                            result[0]\n                        ];\n                        var lastDigit = result[result.length - 2];\n                        if (lastDigit <= 2) {\n                            upca = upca.concat(result.slice(1, 3)).concat([\n                                lastDigit,\n                                0,\n                                0,\n                                0,\n                                0\n                            ]).concat(result.slice(3, 6));\n                        } else if (lastDigit === 3) {\n                            upca = upca.concat(result.slice(1, 4)).concat([\n                                0,\n                                0,\n                                0,\n                                0,\n                                0\n                            ]).concat(result.slice(4, 6));\n                        } else if (lastDigit === 4) {\n                            upca = upca.concat(result.slice(1, 5)).concat([\n                                0,\n                                0,\n                                0,\n                                0,\n                                0,\n                                result[5]\n                            ]);\n                        } else {\n                            upca = upca.concat(result.slice(1, 6)).concat([\n                                0,\n                                0,\n                                0,\n                                0,\n                                lastDigit\n                            ]);\n                        }\n                        upca.push(result[result.length - 1]);\n                        return upca;\n                    }\n                },\n                {\n                    key: \"_checksum\",\n                    value: function _checksum(result) {\n                        return get_default()(getPrototypeOf_default()(UPCEReader.prototype), \"_checksum\", this).call(this, this._convertToUPCA(result));\n                    }\n                },\n                {\n                    key: \"_findEnd\",\n                    value: function _findEnd(offset, isWhite) {\n                        return get_default()(getPrototypeOf_default()(UPCEReader.prototype), \"_findEnd\", this).call(this, offset, true);\n                    }\n                },\n                {\n                    key: \"_verifyTrailingWhitespace\",\n                    value: function _verifyTrailingWhitespace(endInfo) {\n                        var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;\n                        if (trailingWhitespaceEnd < this._row.length) {\n                            if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {\n                                return endInfo;\n                            }\n                        }\n                        return null;\n                    }\n                }\n            ]);\n            return UPCEReader;\n        }(ean_reader);\n        /* harmony default export */ var upc_e_reader = upc_e_reader_UPCEReader;\n        // CONCATENATED MODULE: ./src/reader/upc_reader.ts\n        function upc_reader_createSuper(Derived) {\n            var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function upc_reader_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        var upc_reader_UPCReader = /*#__PURE__*/ function(_EANReader) {\n            inherits_default()(UPCReader, _EANReader);\n            var _super = upc_reader_createSuper(UPCReader);\n            function UPCReader() {\n                var _this;\n                classCallCheck_default()(this, UPCReader);\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                _this = _super.call.apply(_super, [\n                    this\n                ].concat(args));\n                defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", \"upc_a\");\n                return _this;\n            }\n            createClass_default()(UPCReader, [\n                {\n                    key: \"decode\",\n                    value: function decode(row, start) {\n                        var result = ean_reader.prototype.decode.call(this);\n                        if (result && result.code && result.code.length === 13 && result.code.charAt(0) === \"0\") {\n                            result.code = result.code.substring(1);\n                            return result;\n                        }\n                        return null;\n                    }\n                }\n            ]);\n            return UPCReader;\n        }(ean_reader);\n        /* harmony default export */ var upc_reader = upc_reader_UPCReader;\n        // CONCATENATED MODULE: ./src/decoder/bresenham.js\n        var Bresenham = {};\n        var Slope = {\n            DIR: {\n                UP: 1,\n                DOWN: -1\n            }\n        };\n        /**\n * Scans a line of the given image from point p1 to p2 and returns a result object containing\n * gray-scale values (0-255) of the underlying pixels in addition to the min\n * and max values.\n * @param {Object} imageWrapper\n * @param {Object} p1 The start point {x,y}\n * @param {Object} p2 The end point {x,y}\n * @returns {line, min, max}\n */ Bresenham.getBarcodeLine = function(imageWrapper, p1, p2) {\n            /* eslint-disable no-bitwise */ var x0 = p1.x | 0;\n            var y0 = p1.y | 0;\n            var x1 = p2.x | 0;\n            var y1 = p2.y | 0;\n            /* eslint-disable no-bitwise */ var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\n            var error;\n            var y;\n            var tmp;\n            var x;\n            var line = [];\n            var imageData = imageWrapper.data;\n            var width = imageWrapper.size.x;\n            var val;\n            var min = 255;\n            var max = 0;\n            function read(a, b) {\n                val = imageData[b * width + a];\n                min = val < min ? val : min;\n                max = val > max ? val : max;\n                line.push(val);\n            }\n            if (steep) {\n                tmp = x0;\n                x0 = y0;\n                y0 = tmp;\n                tmp = x1;\n                x1 = y1;\n                y1 = tmp;\n            }\n            if (x0 > x1) {\n                tmp = x0;\n                x0 = x1;\n                x1 = tmp;\n                tmp = y0;\n                y0 = y1;\n                y1 = tmp;\n            }\n            var deltaX = x1 - x0;\n            var deltaY = Math.abs(y1 - y0);\n            error = deltaX / 2 | 0;\n            y = y0;\n            var yStep = y0 < y1 ? 1 : -1;\n            for(x = x0; x < x1; x++){\n                if (steep) {\n                    read(y, x);\n                } else {\n                    read(x, y);\n                }\n                error -= deltaY;\n                if (error < 0) {\n                    y += yStep;\n                    error += deltaX;\n                }\n            }\n            return {\n                line: line,\n                min: min,\n                max: max\n            };\n        };\n        /**\n * Converts the result from getBarcodeLine into a binary representation\n * also considering the frequency and slope of the signal for more robust results\n * @param {Object} result {line, min, max}\n */ Bresenham.toBinaryLine = function(result) {\n            var min = result.min;\n            var max = result.max;\n            var line = result.line;\n            var slope;\n            var slope2;\n            var center = min + (max - min) / 2;\n            var extrema = [];\n            var currentDir;\n            var dir;\n            var threshold = (max - min) / 12;\n            var rThreshold = -threshold;\n            var i;\n            var j;\n            // 1. find extrema\n            currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;\n            extrema.push({\n                pos: 0,\n                val: line[0]\n            });\n            for(i = 0; i < line.length - 2; i++){\n                slope = line[i + 1] - line[i];\n                slope2 = line[i + 2] - line[i + 1];\n                if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {\n                    dir = Slope.DIR.DOWN;\n                } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {\n                    dir = Slope.DIR.UP;\n                } else {\n                    dir = currentDir;\n                }\n                if (currentDir !== dir) {\n                    extrema.push({\n                        pos: i,\n                        val: line[i]\n                    });\n                    currentDir = dir;\n                }\n            }\n            extrema.push({\n                pos: line.length,\n                val: line[line.length - 1]\n            });\n            for(j = extrema[0].pos; j < extrema[1].pos; j++){\n                line[j] = line[j] > center ? 0 : 1;\n            }\n            // iterate over extrema and convert to binary based on avg between minmax\n            for(i = 1; i < extrema.length - 1; i++){\n                if (extrema[i + 1].val > extrema[i].val) {\n                    threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;\n                } else {\n                    threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;\n                }\n                for(j = extrema[i].pos; j < extrema[i + 1].pos; j++){\n                    line[j] = line[j] > threshold ? 0 : 1;\n                }\n            }\n            return {\n                line: line,\n                threshold: threshold\n            };\n        };\n        /**\n * Used for development only\n */ Bresenham.debug = {\n            printFrequency: function printFrequency(line, canvas) {\n                var i;\n                var ctx = canvas.getContext(\"2d\");\n                // eslint-disable-next-line no-param-reassign\n                canvas.width = line.length;\n                // eslint-disable-next-line no-param-reassign\n                canvas.height = 256;\n                ctx.beginPath();\n                ctx.strokeStyle = \"blue\";\n                for(i = 0; i < line.length; i++){\n                    ctx.moveTo(i, 255);\n                    ctx.lineTo(i, 255 - line[i]);\n                }\n                ctx.stroke();\n                ctx.closePath();\n            },\n            printPattern: function printPattern(line, canvas) {\n                var ctx = canvas.getContext(\"2d\");\n                var i;\n                // eslint-disable-next-line no-param-reassign\n                canvas.width = line.length;\n                ctx.fillColor = \"black\";\n                for(i = 0; i < line.length; i++){\n                    if (line[i] === 1) {\n                        ctx.fillRect(i, 0, 1, 100);\n                    }\n                }\n            }\n        };\n        /* harmony default export */ var bresenham = Bresenham;\n        // CONCATENATED MODULE: ./src/decoder/barcode_decoder.js\n        function _createForOfIteratorHelper(o, allowArrayLike) {\n            var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n            if (!it) {\n                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n                    if (it) o = it;\n                    var i = 0;\n                    var F = function F() {};\n                    return {\n                        s: F,\n                        n: function n() {\n                            if (i >= o.length) return {\n                                done: true\n                            };\n                            return {\n                                done: false,\n                                value: o[i++]\n                            };\n                        },\n                        e: function e(_e) {\n                            throw _e;\n                        },\n                        f: F\n                    };\n                }\n                throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            var normalCompletion = true, didErr = false, err;\n            return {\n                s: function s() {\n                    it = it.call(o);\n                },\n                n: function n() {\n                    var step = it.next();\n                    normalCompletion = step.done;\n                    return step;\n                },\n                e: function e(_e2) {\n                    didErr = true;\n                    err = _e2;\n                },\n                f: function f() {\n                    try {\n                        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n                    } finally{\n                        if (didErr) throw err;\n                    }\n                }\n            };\n        }\n        function _unsupportedIterableToArray(o, minLen) {\n            if (!o) return;\n            if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n            var n = Object.prototype.toString.call(o).slice(8, -1);\n            if (n === \"Object\" && o.constructor) n = o.constructor.name;\n            if (n === \"Map\" || n === \"Set\") return Array.from(o);\n            if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n        }\n        function _arrayLikeToArray(arr, len) {\n            if (len == null || len > arr.length) len = arr.length;\n            for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n            return arr2;\n        }\n        /* eslint-disable import/no-cycle */ var READERS = {\n            code_128_reader: code_128_reader,\n            ean_reader: ean_reader,\n            ean_5_reader: ean_5_reader,\n            ean_2_reader: ean_2_reader,\n            ean_8_reader: ean_8_reader,\n            code_39_reader: code_39_reader,\n            code_39_vin_reader: code_39_vin_reader,\n            codabar_reader: codabar_reader,\n            upc_reader: upc_reader,\n            upc_e_reader: upc_e_reader,\n            i2of5_reader: i2of5_reader,\n            \"2of5_reader\": _2of5_reader,\n            code_93_reader: code_93_reader,\n            code_32_reader: code_32_reader\n        };\n        /* harmony default export */ var barcode_decoder = {\n            registerReader: function registerReader(name, reader) {\n                READERS[name] = reader;\n            },\n            create: function create(config, inputImageWrapper) {\n                var _canvas = {\n                    ctx: {\n                        frequency: null,\n                        pattern: null,\n                        overlay: null\n                    },\n                    dom: {\n                        frequency: null,\n                        pattern: null,\n                        overlay: null\n                    }\n                };\n                var _barcodeReaders = [];\n                initCanvas();\n                initReaders();\n                initConfig();\n                function initCanvas() {\n                    if (false) { var $debug; }\n                }\n                function initReaders() {\n                    config.readers.forEach(function(readerConfig) {\n                        var reader;\n                        var configuration = {};\n                        var supplements = [];\n                        if (typeof_default()(readerConfig) === \"object\") {\n                            reader = readerConfig.format;\n                            configuration = readerConfig.config;\n                        } else if (typeof readerConfig === \"string\") {\n                            reader = readerConfig;\n                        }\n                        if (false) {}\n                        if (configuration.supplements) {\n                            supplements = configuration.supplements.map(function(supplement) {\n                                return new READERS[supplement]();\n                            });\n                        }\n                        try {\n                            var readerObj = new READERS[reader](configuration, supplements);\n                            _barcodeReaders.push(readerObj);\n                        } catch (err) {\n                            console.error(\"* Error constructing reader \", reader, err);\n                            throw err;\n                        }\n                    });\n                    if (false) {}\n                }\n                function initConfig() {\n                    if (false) { var vis, i; }\n                }\n                /**\n     * extend the line on both ends\n     * @param {Array} line\n     * @param {Number} angle\n     */ function getExtendedLine(line, angle, ext) {\n                    function extendLine(amount) {\n                        var extension = {\n                            y: amount * Math.sin(angle),\n                            x: amount * Math.cos(angle)\n                        };\n                        /* eslint-disable no-param-reassign */ line[0].y -= extension.y;\n                        line[0].x -= extension.x;\n                        line[1].y += extension.y;\n                        line[1].x += extension.x;\n                    /* eslint-enable no-param-reassign */ }\n                    // check if inside image\n                    extendLine(ext);\n                    while(ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))){\n                        // eslint-disable-next-line no-param-reassign\n                        ext -= Math.ceil(ext / 2);\n                        extendLine(-ext);\n                    }\n                    return line;\n                }\n                function getLine(box) {\n                    return [\n                        {\n                            x: (box[1][0] - box[0][0]) / 2 + box[0][0],\n                            y: (box[1][1] - box[0][1]) / 2 + box[0][1]\n                        },\n                        {\n                            x: (box[3][0] - box[2][0]) / 2 + box[2][0],\n                            y: (box[3][1] - box[2][1]) / 2 + box[2][1]\n                        }\n                    ];\n                }\n                function tryDecode(line) {\n                    var result = null;\n                    var i;\n                    var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);\n                    if (false) {}\n                    bresenham.toBinaryLine(barcodeLine);\n                    if (false) {}\n                    for(i = 0; i < _barcodeReaders.length && result === null; i++){\n                        result = _barcodeReaders[i].decodePattern(barcodeLine.line);\n                    }\n                    if (result === null) {\n                        return null;\n                    }\n                    return {\n                        codeResult: result,\n                        barcodeLine: barcodeLine\n                    };\n                }\n                /**\n     * This method slices the given area apart and tries to detect a barcode-pattern\n     * for each slice. It returns the decoded barcode, or null if nothing was found\n     * @param {Array} box\n     * @param {Array} line\n     * @param {Number} lineAngle\n     */ function tryDecodeBruteForce(box, line, lineAngle) {\n                    var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));\n                    var i;\n                    var slices = 16;\n                    var result = null;\n                    var dir;\n                    var extension;\n                    var xdir = Math.sin(lineAngle);\n                    var ydir = Math.cos(lineAngle);\n                    for(i = 1; i < slices && result === null; i++){\n                        // move line perpendicular to angle\n                        // eslint-disable-next-line no-mixed-operators\n                        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);\n                        extension = {\n                            y: dir * xdir,\n                            x: dir * ydir\n                        };\n                        /* eslint-disable no-param-reassign */ line[0].y += extension.x;\n                        line[0].x -= extension.y;\n                        line[1].y += extension.x;\n                        line[1].x -= extension.y;\n                        /* eslint-enable no-param-reassign */ result = tryDecode(line);\n                    }\n                    return result;\n                }\n                function getLineLength(line) {\n                    return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));\n                }\n                function _decodeFromImage2(_x) {\n                    return _decodeFromImage.apply(this, arguments);\n                }\n                /**\n     * With the help of the configured readers (Code128 or EAN) this function tries to detect a\n     * valid barcode pattern within the given area.\n     * @param {Object} box The area to search in\n     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}\n     */ function _decodeFromImage() {\n                    _decodeFromImage = asyncToGenerator_default()(/*#__PURE__*/ regenerator_default.a.mark(function _callee2(imageWrapper) {\n                        var result, _iterator, _step, reader;\n                        return regenerator_default.a.wrap(function _callee2$(_context2) {\n                            while(1)switch(_context2.prev = _context2.next){\n                                case 0:\n                                    result = null;\n                                    _iterator = _createForOfIteratorHelper(_barcodeReaders);\n                                    _context2.prev = 2;\n                                    _iterator.s();\n                                case 4:\n                                    if ((_step = _iterator.n()).done) {\n                                        _context2.next = 14;\n                                        break;\n                                    }\n                                    reader = _step.value;\n                                    if (!reader.decodeImage) {\n                                        _context2.next = 12;\n                                        break;\n                                    }\n                                    _context2.next = 9;\n                                    return reader.decodeImage(imageWrapper);\n                                case 9:\n                                    result = _context2.sent;\n                                    if (!result) {\n                                        _context2.next = 12;\n                                        break;\n                                    }\n                                    return _context2.abrupt(\"break\", 14);\n                                case 12:\n                                    _context2.next = 4;\n                                    break;\n                                case 14:\n                                    _context2.next = 19;\n                                    break;\n                                case 16:\n                                    _context2.prev = 16;\n                                    _context2.t0 = _context2[\"catch\"](2);\n                                    _iterator.e(_context2.t0);\n                                case 19:\n                                    _context2.prev = 19;\n                                    _iterator.f();\n                                    return _context2.finish(19);\n                                case 22:\n                                    return _context2.abrupt(\"return\", result);\n                                case 23:\n                                case \"end\":\n                                    return _context2.stop();\n                            }\n                        }, _callee2, null, [\n                            [\n                                2,\n                                16,\n                                19,\n                                22\n                            ]\n                        ]);\n                    }));\n                    return _decodeFromImage.apply(this, arguments);\n                }\n                function _decodeFromBoundingBox(box) {\n                    var line;\n                    var ctx = _canvas.ctx.overlay;\n                    var result;\n                    if (false) {}\n                    line = getLine(box);\n                    var lineLength = getLineLength(line);\n                    var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);\n                    line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));\n                    if (line === null) {\n                        return null;\n                    }\n                    result = tryDecode(line);\n                    if (result === null) {\n                        result = tryDecodeBruteForce(box, line, lineAngle);\n                    }\n                    if (result === null) {\n                        return null;\n                    }\n                    if (false) {}\n                    return {\n                        codeResult: result.codeResult,\n                        line: line,\n                        angle: lineAngle,\n                        pattern: result.barcodeLine.line,\n                        threshold: result.barcodeLine.threshold\n                    };\n                }\n                return {\n                    decodeFromBoundingBox: function decodeFromBoundingBox(box) {\n                        return _decodeFromBoundingBox(box);\n                    },\n                    decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {\n                        var i;\n                        var result;\n                        var barcodes = [];\n                        var multiple = config.multiple;\n                        for(i = 0; i < boxes.length; i++){\n                            var box = boxes[i];\n                            result = _decodeFromBoundingBox(box) || {};\n                            result.box = box;\n                            if (multiple) {\n                                barcodes.push(result);\n                            } else if (result.codeResult) {\n                                return result;\n                            }\n                        }\n                        return {\n                            barcodes: barcodes\n                        };\n                    },\n                    decodeFromImage: function decodeFromImage(imageWrapperIn) {\n                        return asyncToGenerator_default()(/*#__PURE__*/ regenerator_default.a.mark(function _callee() {\n                            var result;\n                            return regenerator_default.a.wrap(function _callee$(_context) {\n                                while(1)switch(_context.prev = _context.next){\n                                    case 0:\n                                        _context.next = 2;\n                                        return _decodeFromImage2(imageWrapperIn);\n                                    case 2:\n                                        result = _context.sent;\n                                        return _context.abrupt(\"return\", result);\n                                    case 4:\n                                    case \"end\":\n                                        return _context.stop();\n                                }\n                            }, _callee);\n                        }))();\n                    },\n                    registerReader: function registerReader(name, reader) {\n                        if (READERS[name]) {\n                            throw new Error(\"cannot register existing reader\", name);\n                        }\n                        READERS[name] = reader;\n                    },\n                    setReaders: function setReaders(readers) {\n                        // eslint-disable-next-line no-param-reassign\n                        config.readers = readers;\n                        _barcodeReaders.length = 0;\n                        initReaders();\n                    }\n                };\n            }\n        };\n        // CONCATENATED MODULE: ./src/reader/index.ts\n        // CONCATENATED MODULE: ./src/common/events.ts\n        /* harmony default export */ var events = function EventInterface() {\n            var events = {};\n            function getEvent(eventName) {\n                if (!events[eventName]) {\n                    events[eventName] = {\n                        subscribers: []\n                    };\n                }\n                return events[eventName];\n            }\n            function clearEvents() {\n                events = {};\n            }\n            function publishSubscription(subscription, data) {\n                if (subscription.async) {\n                    setTimeout(function() {\n                        subscription.callback(data);\n                    }, 4);\n                } else {\n                    subscription.callback(data);\n                }\n            }\n            function _subscribe(event, callback, async) {\n                var subscription;\n                if (typeof callback === \"function\") {\n                    subscription = {\n                        callback: callback,\n                        async: async\n                    };\n                } else {\n                    subscription = callback;\n                    if (!subscription.callback) {\n                        throw new Error(\"Callback was not specified on options\");\n                    }\n                }\n                getEvent(event).subscribers.push(subscription);\n            }\n            return {\n                subscribe: function subscribe(event, callback, async) {\n                    return _subscribe(event, callback, async);\n                },\n                publish: function publish(eventName, data) {\n                    var event = getEvent(eventName);\n                    var subscribers = event.subscribers;\n                    // Publish one-time subscriptions\n                    subscribers.filter(function(subscriber) {\n                        return !!subscriber.once;\n                    }).forEach(function(subscriber) {\n                        publishSubscription(subscriber, data);\n                    });\n                    // remove them from the subscriber\n                    event.subscribers = subscribers.filter(function(subscriber) {\n                        return !subscriber.once;\n                    });\n                    // publish the rest\n                    event.subscribers.forEach(function(subscriber) {\n                        publishSubscription(subscriber, data);\n                    });\n                },\n                once: function once(event, callback) {\n                    var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                    _subscribe(event, {\n                        callback: callback,\n                        async: async,\n                        once: true\n                    });\n                },\n                unsubscribe: function unsubscribe(eventName, callback) {\n                    if (eventName) {\n                        var _event = getEvent(eventName);\n                        if (_event && callback) {\n                            _event.subscribers = _event.subscribers.filter(function(subscriber) {\n                                return subscriber.callback !== callback;\n                            });\n                        } else {\n                            _event.subscribers = [];\n                        }\n                    } else {\n                        clearEvents();\n                    }\n                }\n            };\n        }();\n        // EXTERNAL MODULE: ./node_modules/lodash/pick.js\n        var pick = __nested_webpack_require_254197__(63);\n        var pick_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(pick);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\n        var wrapNativeSuper = __nested_webpack_require_254197__(64);\n        var wrapNativeSuper_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(wrapNativeSuper);\n        // CONCATENATED MODULE: ./src/quagga/Exception.ts\n        function Exception_createSuper(Derived) {\n            var hasNativeReflectConstruct = Exception_isNativeReflectConstruct();\n            return function _createSuperInternal() {\n                var Super = getPrototypeOf_default()(Derived), result;\n                if (hasNativeReflectConstruct) {\n                    var NewTarget = getPrototypeOf_default()(this).constructor;\n                    result = Reflect.construct(Super, arguments, NewTarget);\n                } else {\n                    result = Super.apply(this, arguments);\n                }\n                return possibleConstructorReturn_default()(this, result);\n            };\n        }\n        function Exception_isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n            try {\n                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n        var Exception_Exception = /*#__PURE__*/ function(_Error) {\n            inherits_default()(Exception, _Error);\n            var _super = Exception_createSuper(Exception);\n            function Exception(m, code) {\n                var _this;\n                classCallCheck_default()(this, Exception);\n                _this = _super.call(this, m);\n                defineProperty_default()(assertThisInitialized_default()(_this), \"code\", void 0);\n                _this.code = code;\n                Object.setPrototypeOf(assertThisInitialized_default()(_this), Exception.prototype);\n                return _this;\n            }\n            return createClass_default()(Exception);\n        }(/*#__PURE__*/ wrapNativeSuper_default()(Error));\n        // CONCATENATED MODULE: ./src/common/mediaDevices.ts\n        var ERROR_DESC = \"This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.\";\n        function enumerateDevices() {\n            try {\n                return navigator.mediaDevices.enumerateDevices();\n            } catch (err) {\n                var error = new Exception_Exception(\"enumerateDevices is not defined. \".concat(ERROR_DESC), -1);\n                return Promise.reject(error);\n            }\n        }\n        function getUserMedia(constraints) {\n            try {\n                return navigator.mediaDevices.getUserMedia(constraints);\n            } catch (err) {\n                var error = new Exception_Exception(\"getUserMedia is not defined. \".concat(ERROR_DESC), -1);\n                return Promise.reject(error);\n            }\n        }\n        // CONCATENATED MODULE: ./src/input/camera_access.ts\n        // TODO: when this file was written years ago, HTMLMediaElement.play() did not return a useful value\n        // to let us know when the video started playing.  Now, it does.  So, we shouldn't need to run this\n        // odd waitForVideo() function that polls to see if the video has started.\n        var streamRef;\n        function waitForVideo(video) {\n            return new Promise(function(resolve, reject) {\n                var attempts = 10;\n                function checkVideo() {\n                    if (attempts > 0) {\n                        if (video.videoWidth > 10 && video.videoHeight > 10) {\n                            if (false) {}\n                            resolve();\n                        } else {\n                            window.setTimeout(checkVideo, 500);\n                        }\n                    } else {\n                        reject(new Exception_Exception(\"Unable to play video stream. Is webcam working?\", -1)); // TODO: add error code\n                    }\n                    attempts--;\n                }\n                checkVideo();\n            });\n        }\n        /**\n * Tries to attach the camera-stream to a given video-element\n * and calls the callback function when the content is ready\n * @param {Object} constraints\n * @param {Object} video\n */ function initCamera(_x, _x2) {\n            return _initCamera.apply(this, arguments);\n        }\n        function _initCamera() {\n            _initCamera = asyncToGenerator_default()(/*#__PURE__*/ regenerator_default.a.mark(function _callee4(video, constraints) {\n                var stream;\n                return regenerator_default.a.wrap(function _callee4$(_context4) {\n                    while(1)switch(_context4.prev = _context4.next){\n                        case 0:\n                            _context4.next = 2;\n                            return getUserMedia(constraints);\n                        case 2:\n                            stream = _context4.sent;\n                            streamRef = stream;\n                            if (!video) {\n                                _context4.next = 11;\n                                break;\n                            }\n                            video.setAttribute(\"autoplay\", \"true\");\n                            video.setAttribute(\"muted\", \"true\");\n                            video.setAttribute(\"playsinline\", \"true\"); // not listed on MDN...\n                            // eslint-disable-next-line no-param-reassign\n                            video.srcObject = stream;\n                            video.addEventListener(\"loadedmetadata\", function() {\n                                video.play()[\"catch\"](function(err) {\n                                    console.warn(\"* Error while trying to play video stream:\", err);\n                                });\n                            });\n                            return _context4.abrupt(\"return\", waitForVideo(video));\n                        case 11:\n                            return _context4.abrupt(\"return\", Promise.resolve());\n                        case 12:\n                        case \"end\":\n                            return _context4.stop();\n                    }\n                }, _callee4);\n            }));\n            return _initCamera.apply(this, arguments);\n        }\n        function deprecatedConstraints(videoConstraints) {\n            var normalized = pick_default()(videoConstraints, [\n                \"width\",\n                \"height\",\n                \"facingMode\",\n                \"aspectRatio\",\n                \"deviceId\"\n            ]);\n            if (typeof videoConstraints.minAspectRatio !== \"undefined\" && videoConstraints.minAspectRatio > 0) {\n                normalized.aspectRatio = videoConstraints.minAspectRatio;\n                console.log(\"WARNING: Constraint 'minAspectRatio' is deprecated; Use 'aspectRatio' instead\");\n            }\n            if (typeof videoConstraints.facing !== \"undefined\") {\n                normalized.facingMode = videoConstraints.facing;\n                console.log(\"WARNING: Constraint 'facing' is deprecated. Use 'facingMode' instead'\");\n            }\n            return normalized;\n        }\n        // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,\n        // I think it was just that way so it could be chained to other functions that did return a Promise.\n        // That's not necessary with async functions being a thing, so that should be fixed.\n        function pickConstraints() {\n            var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            var video = deprecatedConstraints(videoConstraints);\n            if (video && video.deviceId && video.facingMode) {\n                delete video.facingMode;\n            }\n            return Promise.resolve({\n                audio: false,\n                video: video\n            });\n        }\n        function enumerateVideoDevices() {\n            return _enumerateVideoDevices.apply(this, arguments);\n        }\n        function _enumerateVideoDevices() {\n            _enumerateVideoDevices = asyncToGenerator_default()(/*#__PURE__*/ regenerator_default.a.mark(function _callee5() {\n                var devices;\n                return regenerator_default.a.wrap(function _callee5$(_context5) {\n                    while(1)switch(_context5.prev = _context5.next){\n                        case 0:\n                            _context5.next = 2;\n                            return enumerateDevices();\n                        case 2:\n                            devices = _context5.sent;\n                            return _context5.abrupt(\"return\", devices.filter(function(device) {\n                                return device.kind === \"videoinput\";\n                            }));\n                        case 4:\n                        case \"end\":\n                            return _context5.stop();\n                    }\n                }, _callee5);\n            }));\n            return _enumerateVideoDevices.apply(this, arguments);\n        }\n        function getActiveTrack() {\n            if (!streamRef) {\n                return null;\n            }\n            var tracks = streamRef.getVideoTracks();\n            return tracks && tracks !== null && tracks !== void 0 && tracks.length ? tracks[0] : null;\n        }\n        /**\n * Used for accessing information about the active stream track and available video devices.\n */ var QuaggaJSCameraAccess = {\n            requestedVideoElement: null,\n            request: function request(video, videoConstraints) {\n                return asyncToGenerator_default()(/*#__PURE__*/ regenerator_default.a.mark(function _callee() {\n                    var newConstraints;\n                    return regenerator_default.a.wrap(function _callee$(_context) {\n                        while(1)switch(_context.prev = _context.next){\n                            case 0:\n                                QuaggaJSCameraAccess.requestedVideoElement = video;\n                                _context.next = 3;\n                                return pickConstraints(videoConstraints);\n                            case 3:\n                                newConstraints = _context.sent;\n                                return _context.abrupt(\"return\", initCamera(video, newConstraints));\n                            case 5:\n                            case \"end\":\n                                return _context.stop();\n                        }\n                    }, _callee);\n                }))();\n            },\n            release: function release() {\n                var tracks = streamRef && streamRef.getVideoTracks();\n                if (QuaggaJSCameraAccess.requestedVideoElement !== null) {\n                    QuaggaJSCameraAccess.requestedVideoElement.pause();\n                }\n                return new Promise(function(resolve) {\n                    setTimeout(function() {\n                        if (tracks && tracks.length) {\n                            tracks.forEach(function(track) {\n                                return track.stop();\n                            });\n                        }\n                        streamRef = null;\n                        QuaggaJSCameraAccess.requestedVideoElement = null;\n                        resolve();\n                    }, 0);\n                });\n            },\n            enumerateVideoDevices: enumerateVideoDevices,\n            getActiveStreamLabel: function getActiveStreamLabel() {\n                var track = getActiveTrack();\n                return track ? track.label : \"\";\n            },\n            getActiveTrack: getActiveTrack,\n            disableTorch: function disableTorch() {\n                return asyncToGenerator_default()(/*#__PURE__*/ regenerator_default.a.mark(function _callee2() {\n                    var track;\n                    return regenerator_default.a.wrap(function _callee2$(_context2) {\n                        while(1)switch(_context2.prev = _context2.next){\n                            case 0:\n                                track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?\n                                // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?\n                                if (!track) {\n                                    _context2.next = 11;\n                                    break;\n                                }\n                                _context2.prev = 2;\n                                _context2.next = 5;\n                                return track.applyConstraints({\n                                    advanced: [\n                                        {\n                                            torch: false\n                                        }\n                                    ]\n                                });\n                            case 5:\n                                _context2.next = 11;\n                                break;\n                            case 7:\n                                _context2.prev = 7;\n                                _context2.t0 = _context2[\"catch\"](2);\n                                if (_context2.t0 instanceof OverconstrainedError) {\n                                    console.warn(\"quagga2/CameraAccess: Torch not supported on this device\");\n                                }\n                                throw _context2.t0;\n                            case 11:\n                            case \"end\":\n                                return _context2.stop();\n                        }\n                    }, _callee2, null, [\n                        [\n                            2,\n                            7\n                        ]\n                    ]);\n                }))();\n            },\n            enableTorch: function enableTorch() {\n                return asyncToGenerator_default()(/*#__PURE__*/ regenerator_default.a.mark(function _callee3() {\n                    var track;\n                    return regenerator_default.a.wrap(function _callee3$(_context3) {\n                        while(1)switch(_context3.prev = _context3.next){\n                            case 0:\n                                track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?\n                                // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?\n                                if (!track) {\n                                    _context3.next = 11;\n                                    break;\n                                }\n                                _context3.prev = 2;\n                                _context3.next = 5;\n                                return track.applyConstraints({\n                                    advanced: [\n                                        {\n                                            torch: true\n                                        }\n                                    ]\n                                });\n                            case 5:\n                                _context3.next = 11;\n                                break;\n                            case 7:\n                                _context3.prev = 7;\n                                _context3.t0 = _context3[\"catch\"](2);\n                                if (_context3.t0 instanceof OverconstrainedError) {\n                                    console.warn(\"quagga2/CameraAccess: Torch not supported on this device\");\n                                }\n                                throw _context3.t0;\n                            case 11:\n                            case \"end\":\n                                return _context3.stop();\n                        }\n                    }, _callee3, null, [\n                        [\n                            2,\n                            7\n                        ]\n                    ]);\n                }))();\n            }\n        };\n        /* harmony default export */ var camera_access = QuaggaJSCameraAccess;\n        // CONCATENATED MODULE: ./src/analytics/result_collector.ts\n        function contains(codeResult, list) {\n            return list && list.some(function(item) {\n                var keys = Object.keys(item);\n                return keys.every(function(key) {\n                    return item[key] === codeResult[key];\n                });\n            });\n        }\n        function passesFilter(codeResult, filter) {\n            return typeof filter === \"function\" ? filter(codeResult) : true;\n        }\n        /* harmony default export */ var result_collector = {\n            create: function create(config) {\n                var _config$capacity;\n                var canvas = document.createElement(\"canvas\");\n                var ctx = canvas.getContext(\"2d\", {\n                    willReadFrequently: !!config.willReadFrequently\n                });\n                var results = [];\n                var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;\n                var capture = config.capture === true;\n                function matchesConstraints(codeResult) {\n                    return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);\n                }\n                return {\n                    addResult: function addResult(data, imageSize, codeResult) {\n                        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|\n                        if (matchesConstraints(codeResult)) {\n                            capacity--;\n                            result.codeResult = codeResult;\n                            if (capture) {\n                                canvas.width = imageSize.x;\n                                canvas.height = imageSize.y;\n                                image_debug[\"a\" /* default */ ].drawImage(data, imageSize, ctx);\n                                result.frame = canvas.toDataURL();\n                            }\n                            results.push(result);\n                        }\n                    },\n                    getResults: function getResults() {\n                        return results;\n                    }\n                };\n            }\n        };\n        // CONCATENATED MODULE: ./src/config/config.dev.ts\n        var DevConfig = {\n            inputStream: {\n                name: \"Live\",\n                type: \"LiveStream\",\n                constraints: {\n                    width: 640,\n                    height: 480,\n                    // aspectRatio: 640/480, // optional\n                    facingMode: \"environment\" // or user\n                },\n                area: {\n                    top: \"0%\",\n                    right: \"0%\",\n                    left: \"0%\",\n                    bottom: \"0%\"\n                },\n                singleChannel: false // true: only the red color-channel is read\n            },\n            locate: true,\n            numOfWorkers: 0,\n            decoder: {\n                readers: [\n                    \"code_128_reader\"\n                ],\n                debug: {\n                    drawBoundingBox: false,\n                    showFrequency: false,\n                    drawScanline: false,\n                    showPattern: false\n                }\n            },\n            locator: {\n                halfSample: true,\n                patchSize: \"medium\",\n                // x-small, small, medium, large, x-large\n                debug: {\n                    showCanvas: false,\n                    showPatches: false,\n                    showFoundPatches: false,\n                    showSkeleton: false,\n                    showLabels: false,\n                    showPatchLabels: false,\n                    showRemainingPatchLabels: false,\n                    boxFromPatches: {\n                        showTransformed: false,\n                        showTransformedBox: false,\n                        showBB: false\n                    }\n                }\n            }\n        };\n        /* harmony default export */ var config_dev = DevConfig;\n        // CONCATENATED MODULE: ./src/config/config.node.ts\n        var NodeConfig = {\n            inputStream: {\n                type: \"ImageStream\",\n                sequence: false,\n                size: 800,\n                area: {\n                    top: \"0%\",\n                    right: \"0%\",\n                    left: \"0%\",\n                    bottom: \"0%\"\n                },\n                singleChannel: false // true: only the red color-channel is read\n            },\n            locate: true,\n            numOfWorkers: 0,\n            decoder: {\n                readers: [\n                    \"code_128_reader\"\n                ]\n            },\n            locator: {\n                halfSample: true,\n                patchSize: \"medium\" // x-small, small, medium, large, x-large\n            }\n        };\n        /* harmony default export */ var config_node = NodeConfig;\n        // CONCATENATED MODULE: ./src/config/config.prod.ts\n        var ProdConfig = {\n            inputStream: {\n                name: \"Live\",\n                type: \"LiveStream\",\n                constraints: {\n                    width: 640,\n                    height: 480,\n                    // aspectRatio: 640/480, // optional\n                    facingMode: \"environment\" // or user\n                },\n                area: {\n                    top: \"0%\",\n                    right: \"0%\",\n                    left: \"0%\",\n                    bottom: \"0%\"\n                },\n                singleChannel: false // true: only the red color-channel is read\n            },\n            locate: true,\n            numOfWorkers: 4,\n            decoder: {\n                readers: [\n                    \"code_128_reader\"\n                ]\n            },\n            locator: {\n                halfSample: true,\n                patchSize: \"medium\" // x-small, small, medium, large, x-large\n            }\n        };\n        /* harmony default export */ var config_prod = ProdConfig;\n        // CONCATENATED MODULE: ./src/config/config.ts\n        var ExportConfig = function() {\n            var QuaggaConfig;\n            if (false) {} else if (true) {\n                QuaggaConfig = config_node;\n            } else {}\n            return QuaggaConfig;\n        }();\n        /* harmony default export */ var config_config = ExportConfig;\n        // EXTERNAL MODULE: external \"gl-matrix\"\n        var external_gl_matrix_ = __nested_webpack_require_254197__(5);\n        // EXTERNAL MODULE: ./src/input/frame_grabber.js\n        var frame_grabber = __nested_webpack_require_254197__(65);\n        var frame_grabber_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(frame_grabber);\n        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js\n        var slicedToArray = __nested_webpack_require_254197__(33);\n        var slicedToArray_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(slicedToArray);\n        // EXTERNAL MODULE: external \"get-pixels\"\n        var external_get_pixels_ = __nested_webpack_require_254197__(66);\n        var external_get_pixels_default = /*#__PURE__*/ __nested_webpack_require_254197__.n(external_get_pixels_);\n        // CONCATENATED MODULE: ./src/input/input_stream/input_stream.ts\n        // TODO: It's pretty likely that this shares code with the browser version, investigate that\n        // FOR ANYONE IN HERE IN THE FUTURE: This is the default input_stream module used for the Node bundle.\n        // webpack.config.js *replaces* this with input_stream_browser.ts when the bundle is being built for browser.\n        var inputStreamFactory = {\n            createVideoStream: function createVideoStream() {\n                throw new Error(\"createVideoStream not available\");\n            },\n            createLiveStream: function createLiveStream() {\n                throw new Error(\"createLiveStream not available\");\n            },\n            createImageStream: function createImageStream() {\n                // console.warn('* InputStreamNode createImageStream');\n                var _config = null;\n                var width = 0;\n                var height = 0;\n                var loaded = false;\n                // TODO: frame should be a type NdArray, but NdArray doesn't have ts definitions\n                // TODO: there is a ts-ndarray that might work, though\n                var frame = null;\n                var baseUrl;\n                var _ended = false;\n                var calculatedWidth;\n                var calculatedHeight;\n                var _eventNames = [\n                    \"canrecord\",\n                    \"ended\"\n                ];\n                var _eventHandlers = {};\n                var _topRight = {\n                    x: 0,\n                    y: 0,\n                    type: \"Point\"\n                };\n                var _canvasSize = {\n                    x: 0,\n                    y: 0,\n                    type: \"XYSize\"\n                };\n                /* eslint-disable no-unused-vars */ // false eslint errors? weird.\n                // @ts-ignore\n                var size = 0;\n                // @ts-ignore\n                var frameIdx = 0;\n                // @ts-ignore\n                var paused = false;\n                /* eslint-enable no-unused-vars */ function loadImages() {\n                    var _config2;\n                    loaded = false;\n                    /* eslint-disable new-cap */ external_get_pixels_default()(baseUrl, (_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.mime, function(err, pixels) {\n                        var _config3, _config4;\n                        if (err) {\n                            console.error(\"**** quagga loadImages error:\", err);\n                            throw new Error(\"error decoding pixels in loadImages\");\n                        }\n                        loaded = true;\n                        if (false) {}\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        frame = pixels;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access\n                        // eslint-disable-next-line no-nested-ternary\n                        var _pixels$shape = slicedToArray_default()(pixels.shape, 2);\n                        width = _pixels$shape[0];\n                        height = _pixels$shape[1];\n                        calculatedWidth = (_config3 = _config) !== null && _config3 !== void 0 && _config3.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;\n                        // eslint-disable-next-line no-nested-ternary\n                        calculatedHeight = (_config4 = _config) !== null && _config4 !== void 0 && _config4.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;\n                        _canvasSize.x = calculatedWidth;\n                        _canvasSize.y = calculatedHeight;\n                        setTimeout(function() {\n                            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                            publishEvent(\"canrecord\", []);\n                        }, 0);\n                    });\n                }\n                function publishEvent(eventName, args) {\n                    var handlers = _eventHandlers[eventName];\n                    if (handlers && handlers.length > 0) {\n                        for(var j = 0; j < handlers.length; j++){\n                            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                            handlers[j].apply(inputStream, args);\n                        }\n                    }\n                }\n                // eslint-disable-next-line no-var,vars-on-top\n                var inputStream = {\n                    trigger: publishEvent,\n                    getWidth: function getWidth() {\n                        return calculatedWidth;\n                    },\n                    getHeight: function getHeight() {\n                        return calculatedHeight;\n                    },\n                    setWidth: function setWidth(w) {\n                        calculatedWidth = w;\n                    },\n                    setHeight: function setHeight(h) {\n                        calculatedHeight = h;\n                    },\n                    getRealWidth: function getRealWidth() {\n                        return width;\n                    },\n                    getRealHeight: function getRealHeight() {\n                        return height;\n                    },\n                    setInputStream: function setInputStream(stream) {\n                        var _config5;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        _config = stream;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access\n                        baseUrl = (_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.src;\n                        size = 1;\n                        loadImages();\n                    },\n                    ended: function ended() {\n                        return _ended;\n                    },\n                    setAttribute: function setAttribute() {},\n                    getConfig: function getConfig() {\n                        return _config;\n                    },\n                    pause: function pause() {\n                        paused = true;\n                    },\n                    play: function play() {\n                        paused = false;\n                    },\n                    setCurrentTime: function setCurrentTime(time) {\n                        frameIdx = time;\n                    },\n                    addEventListener: function addEventListener(event, f) {\n                        if (_eventNames.indexOf(event) !== -1) {\n                            if (!_eventHandlers[event]) {\n                                _eventHandlers[event] = [];\n                            }\n                            _eventHandlers[event].push(f);\n                        }\n                    },\n                    clearEventHandlers: function clearEventHandlers() {\n                        Object.keys(_eventHandlers).forEach(function(ind) {\n                            return delete _eventHandlers[ind];\n                        });\n                    },\n                    setTopRight: function setTopRight(topRight) {\n                        _topRight.x = topRight.x;\n                        _topRight.y = topRight.y;\n                    },\n                    getTopRight: function getTopRight() {\n                        return _topRight;\n                    },\n                    setCanvasSize: function setCanvasSize(sz) {\n                        _canvasSize.x = sz.x;\n                        _canvasSize.y = sz.y;\n                    },\n                    getCanvasSize: function getCanvasSize() {\n                        return _canvasSize;\n                    },\n                    getFrame: function getFrame() {\n                        if (!loaded) {\n                            return null;\n                        }\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                        return frame;\n                    }\n                };\n                return inputStream;\n            }\n        };\n        /* harmony default export */ var input_stream = inputStreamFactory;\n        // EXTERNAL MODULE: ./src/locator/barcode_locator.js\n        var barcode_locator = __nested_webpack_require_254197__(23);\n        // CONCATENATED MODULE: ./src/QuaggaContext.ts\n        var QuaggaContext_QuaggaContext = /*#__PURE__*/ createClass_default()(function QuaggaContext() {\n            classCallCheck_default()(this, QuaggaContext);\n            defineProperty_default()(this, \"config\", void 0);\n            defineProperty_default()(this, \"inputStream\", void 0);\n            defineProperty_default()(this, \"framegrabber\", void 0);\n            defineProperty_default()(this, \"inputImageWrapper\", void 0);\n            defineProperty_default()(this, \"stopped\", false);\n            defineProperty_default()(this, \"boxSize\", void 0);\n            defineProperty_default()(this, \"resultCollector\", void 0);\n            defineProperty_default()(this, \"decoder\", void 0);\n            defineProperty_default()(this, \"workerPool\", []);\n            defineProperty_default()(this, \"onUIThread\", true);\n            defineProperty_default()(this, \"canvasContainer\", new QuaggaContext_CanvasContainer());\n        });\n        var QuaggaContext_CanvasInfo = /*#__PURE__*/ createClass_default()(function CanvasInfo() {\n            classCallCheck_default()(this, CanvasInfo);\n            defineProperty_default()(this, \"image\", void 0);\n            defineProperty_default()(this, \"overlay\", void 0);\n        });\n        var QuaggaContext_CanvasContainer = /*#__PURE__*/ createClass_default()(function CanvasContainer() {\n            classCallCheck_default()(this, CanvasContainer);\n            defineProperty_default()(this, \"ctx\", void 0);\n            defineProperty_default()(this, \"dom\", void 0);\n            this.ctx = new QuaggaContext_CanvasInfo();\n            this.dom = new QuaggaContext_CanvasInfo();\n        });\n        // CONCATENATED MODULE: ./src/quagga/getViewPort.ts\n        function getViewPort_getViewPort(target) {\n            if (typeof document === \"undefined\") {\n                return null;\n            }\n            // Check if target is already a DOM element\n            if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {\n                return target;\n            }\n            // Use '#interactive.viewport' as a fallback selector (backwards compatibility)\n            var selector = typeof target === \"string\" ? target : \"#interactive.viewport\";\n            return document.querySelector(selector);\n        }\n        // CONCATENATED MODULE: ./src/quagga/initBuffers.ts\n        external_gl_matrix_[\"glMatrix\"].setMatrixArrayType(Array);\n        // TODO: need typescript def for BarcodeLocator\n        function initBuffers_initBuffers(inputStream, imageWrapper, locator) {\n            var inputImageWrapper = imageWrapper || new image_wrapper[\"a\" /* default */ ]({\n                x: inputStream.getWidth(),\n                y: inputStream.getHeight(),\n                type: \"XYSize\"\n            });\n            if (false) {}\n            var boxSize = [\n                external_gl_matrix_[\"vec2\"].clone([\n                    0,\n                    0\n                ]),\n                external_gl_matrix_[\"vec2\"].clone([\n                    0,\n                    inputImageWrapper.size.y\n                ]),\n                external_gl_matrix_[\"vec2\"].clone([\n                    inputImageWrapper.size.x,\n                    inputImageWrapper.size.y\n                ]),\n                external_gl_matrix_[\"vec2\"].clone([\n                    inputImageWrapper.size.x,\n                    0\n                ])\n            ];\n            barcode_locator[\"a\" /* default */ ].init(inputImageWrapper, locator);\n            return {\n                inputImageWrapper: inputImageWrapper,\n                boxSize: boxSize\n            };\n        }\n        // CONCATENATED MODULE: ./src/quagga/initCanvas.ts\n        function findOrCreateCanvas(selector, className) {\n            var canvas = document.querySelector(selector);\n            if (!canvas) {\n                canvas = document.createElement(\"canvas\");\n                canvas.className = className;\n            }\n            return canvas;\n        }\n        function getCanvasAndContext(selector, className, options) {\n            var canvas = findOrCreateCanvas(selector, className);\n            console.warn(\"* initCanvas getCanvasAndContext\");\n            var context = canvas.getContext(\"2d\", {\n                willReadFrequently: options.willReadFrequently\n            });\n            return {\n                canvas: canvas,\n                context: context\n            };\n        }\n        function initCanvases(canvasSize, _ref) {\n            var willReadFrequently = _ref.willReadFrequently;\n            if (typeof document !== \"undefined\") {\n                var image = getCanvasAndContext(\"canvas.imgBuffer\", \"imgBuffer\", {\n                    willReadFrequently: willReadFrequently\n                });\n                var overlay = getCanvasAndContext(\"canvas.drawingBuffer\", \"drawingBuffer\", {\n                    willReadFrequently: willReadFrequently\n                });\n                // eslint-disable-next-line no-multi-assign\n                image.canvas.width = overlay.canvas.width = canvasSize.x;\n                // eslint-disable-next-line no-multi-assign\n                image.canvas.height = overlay.canvas.height = canvasSize.y;\n                return {\n                    dom: {\n                        image: image.canvas,\n                        overlay: overlay.canvas\n                    },\n                    ctx: {\n                        image: image.context,\n                        overlay: overlay.context\n                    }\n                };\n            }\n            return null;\n        }\n        function initCanvas_initCanvas(context) {\n            var _context$config, _context$config$input, _context$config2, _context$config2$inpu, _context$config3, _context$config3$inpu;\n            var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);\n            var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;\n            if (!type) return null;\n            var container = initCanvases(context.inputStream.getCanvasSize(), {\n                willReadFrequently: !!(context !== null && context !== void 0 && (_context$config3 = context.config) !== null && _context$config3 !== void 0 && (_context$config3$inpu = _context$config3.inputStream) !== null && _context$config3$inpu !== void 0 && _context$config3$inpu.willReadFrequently)\n            });\n            if (!container) return {\n                dom: {\n                    image: null,\n                    overlay: null\n                },\n                ctx: {\n                    image: null,\n                    overlay: null\n                }\n            };\n            var dom = container.dom;\n            if (typeof document !== \"undefined\") {\n                if (viewport) {\n                    if (type === \"ImageStream\" && !viewport.contains(dom.image)) {\n                        viewport.appendChild(dom.image);\n                    }\n                    if (!viewport.contains(dom.overlay)) {\n                        viewport.appendChild(dom.overlay);\n                    }\n                }\n            }\n            return container;\n        }\n        // CONCATENATED MODULE: ./src/quagga/qworker.ts\n        function qworker_ownKeys(e, r) {\n            var t = Object.keys(e);\n            if (Object.getOwnPropertySymbols) {\n                var o = Object.getOwnPropertySymbols(e);\n                r && (o = o.filter(function(r) {\n                    return Object.getOwnPropertyDescriptor(e, r).enumerable;\n                })), t.push.apply(t, o);\n            }\n            return t;\n        }\n        function qworker_objectSpread(e) {\n            for(var r = 1; r < arguments.length; r++){\n                var t = null != arguments[r] ? arguments[r] : {};\n                r % 2 ? qworker_ownKeys(Object(t), !0).forEach(function(r) {\n                    defineProperty_default()(e, r, t[r]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : qworker_ownKeys(Object(t)).forEach(function(r) {\n                    Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n                });\n            }\n            return e;\n        }\n        /* Worker functions. These are straight from the original quagga.js file.\n * Not presently used, as worker support is non-functional.  Keeping them around temporarily\n * to refer to until it is re-implemented. We may be able to fix/use some of this.\n */ // TODO: need a typescript interface for FrameGrabber\n        var workerPool = [];\n        function updateWorkers(frameGrabber) {\n            var availableWorker;\n            if (workerPool.length) {\n                availableWorker = workerPool.filter(function(workerThread) {\n                    return !workerThread.busy;\n                })[0];\n                if (availableWorker) {\n                    frameGrabber.attachData(availableWorker.imageData);\n                    if (frameGrabber.grab()) {\n                        availableWorker.busy = true;\n                        availableWorker.worker.postMessage({\n                            cmd: \"process\",\n                            imageData: availableWorker.imageData\n                        }, [\n                            availableWorker.imageData.buffer\n                        ]);\n                    }\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            return null;\n        }\n        function configForWorker(config) {\n            return qworker_objectSpread(qworker_objectSpread({}, config), {}, {\n                inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {\n                    target: null\n                })\n            });\n        }\n        // @ts-ignore\n        function workerInterface(factory) {\n            if (factory) {\n                var Quagga = factory()[\"default\"];\n                if (!Quagga) {\n                    // @ts-ignore\n                    self.postMessage({\n                        \"event\": \"error\",\n                        message: \"Quagga could not be created\"\n                    });\n                    return;\n                }\n            }\n            // @ts-ignore\n            var imageWrapper;\n            // @ts-ignore\n            function onProcessed(result) {\n                self.postMessage({\n                    \"event\": \"processed\",\n                    // @ts-ignore\n                    imageData: imageWrapper.data,\n                    result: result\n                }, [\n                    imageWrapper.data.buffer\n                ]);\n            }\n            function workerInterfaceReady() {\n                self.postMessage({\n                    \"event\": \"initialized\",\n                    // @ts-ignore\n                    imageData: imageWrapper.data\n                }, [\n                    imageWrapper.data.buffer\n                ]);\n            }\n            // @ts-ignore\n            self.onmessage = function(e) {\n                if (e.data.cmd === \"init\") {\n                    var config = e.data.config;\n                    config.numOfWorkers = 0;\n                    imageWrapper = new Quagga.ImageWrapper({\n                        x: e.data.size.x,\n                        y: e.data.size.y\n                    }, new Uint8Array(e.data.imageData));\n                    Quagga.init(config, workerInterfaceReady, imageWrapper);\n                    Quagga.onProcessed(onProcessed);\n                } else if (e.data.cmd === \"process\") {\n                    // @ts-ignore\n                    imageWrapper.data = new Uint8Array(e.data.imageData);\n                    Quagga.start();\n                } else if (e.data.cmd === \"setReaders\") {\n                    Quagga.setReaders(e.data.readers);\n                } else if (e.data.cmd === \"registerReader\") {\n                    Quagga.registerReader(e.data.name, e.data.reader);\n                }\n            };\n        }\n        function generateWorkerBlob() {\n            var blob, factorySource;\n            /* jshint ignore:start */ // @ts-ignore\n            if (typeof __factorySource__ !== \"undefined\") {\n                // @ts-ignore\n                factorySource = __factorySource__; // eslint-disable-line no-undef\n            }\n            /* jshint ignore:end */ blob = new Blob([\n                \"(\" + workerInterface.toString() + \")(\" + factorySource + \");\"\n            ], {\n                type: \"text/javascript\"\n            });\n            return window.URL.createObjectURL(blob);\n        }\n        function initWorker(config, inputStream, cb) {\n            var blobURL = generateWorkerBlob();\n            var worker = new Worker(blobURL);\n            var workerThread = {\n                worker: worker,\n                imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),\n                busy: true\n            };\n            workerThread.worker.onmessage = function(e) {\n                if (e.data.event === \"initialized\") {\n                    URL.revokeObjectURL(blobURL);\n                    workerThread.busy = false;\n                    workerThread.imageData = new Uint8Array(e.data.imageData);\n                    if (false) {}\n                    cb(workerThread);\n                } else if (e.data.event === \"processed\") {\n                    workerThread.imageData = new Uint8Array(e.data.imageData);\n                    workerThread.busy = false;\n                    // TODO: how to thread publishResult into here? TypeScript says it's not here. https://github.com/ericblade/quagga2/issues/466#issuecomment-1724248080 says it's necessary?\n                    // @ts-ignore\n                    if (typeof publishResult !== \"undefined\") {\n                        // @ts-ignore\n                        publishResult(e.data.result, workerThread.imageData);\n                    }\n                } else if (e.data.event === \"error\") {\n                    if (false) {}\n                }\n            };\n            workerThread.worker.postMessage({\n                cmd: \"init\",\n                size: {\n                    x: inputStream.getWidth(),\n                    y: inputStream.getHeight()\n                },\n                imageData: workerThread.imageData,\n                config: configForWorker(config)\n            }, [\n                workerThread.imageData.buffer\n            ]);\n        }\n        function adjustWorkerPool(capacity, config, inputStream, cb) {\n            var increaseBy = capacity - workerPool.length;\n            if (increaseBy === 0 && cb) {\n                cb();\n            } else if (increaseBy < 0) {\n                var workersToTerminate = workerPool.slice(increaseBy);\n                workersToTerminate.forEach(function(workerThread) {\n                    workerThread.worker.terminate();\n                    if (false) {}\n                });\n                workerPool = workerPool.slice(0, increaseBy);\n                if (cb) {\n                    cb();\n                }\n            } else {\n                var workerInitialized = function workerInitialized(workerThread) {\n                    workerPool.push(workerThread);\n                    if (workerPool.length >= capacity && cb) {\n                        cb();\n                    }\n                };\n                if (config) {\n                    for(var i = 0; i < increaseBy; i++){\n                        initWorker(config, inputStream, workerInitialized);\n                    }\n                }\n            }\n        }\n        function qworker_setReaders(readers) {\n            workerPool.forEach(function(workerThread) {\n                return workerThread.worker.postMessage({\n                    cmd: \"setReaders\",\n                    readers: readers\n                });\n            });\n        }\n        function qworker_registerReader(name, reader) {\n            workerPool.forEach(function(workerThread) {\n                return workerThread.worker.postMessage({\n                    cmd: \"registerReader\",\n                    name: name,\n                    reader: reader\n                });\n            });\n        }\n        // CONCATENATED MODULE: ./src/quagga/setupInputStream.ts\n        // TODO: need to create an InputStream typescript interface, so we don't have an \"any\" in the next line\n        function setupInputStream() {\n            var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"LiveStream\";\n            var viewport = arguments.length > 1 ? arguments[1] : undefined;\n            var inputStreamFactory = arguments.length > 2 ? arguments[2] : undefined;\n            switch(type){\n                case \"VideoStream\":\n                    {\n                        var video = document.createElement(\"video\");\n                        return {\n                            video: video,\n                            inputStream: inputStreamFactory.createVideoStream(video)\n                        };\n                    }\n                case \"ImageStream\":\n                    return {\n                        inputStream: inputStreamFactory.createImageStream()\n                    };\n                case \"LiveStream\":\n                    {\n                        var _video = null;\n                        if (viewport) {\n                            _video = viewport.querySelector(\"video\");\n                            if (!_video) {\n                                _video = document.createElement(\"video\");\n                                viewport.appendChild(_video);\n                            }\n                        }\n                        return {\n                            video: _video,\n                            inputStream: inputStreamFactory.createLiveStream(_video)\n                        };\n                    }\n                default:\n                    console.error(\"* setupInputStream invalid type \".concat(type));\n                    return {\n                        video: null,\n                        inputStream: null\n                    };\n            }\n        }\n        // CONCATENATED MODULE: ./src/quagga/transform.ts\n        /* eslint-disable no-param-reassign */ function moveBox(box, xOffset, yOffset) {\n            var corner = box.length;\n            while(corner--){\n                box[corner][0] += xOffset;\n                box[corner][1] += yOffset;\n            }\n        }\n        function moveLine(line, xOffset, yOffset) {\n            line[0].x += xOffset;\n            line[0].y += yOffset;\n            line[1].x += xOffset;\n            line[1].y += yOffset;\n        }\n        // CONCATENATED MODULE: ./src/quagga/quagga.ts\n        external_gl_matrix_[\"glMatrix\"].setMatrixArrayType(Array);\n        var quagga_Quagga = /*#__PURE__*/ function() {\n            function Quagga() {\n                var _this = this;\n                classCallCheck_default()(this, Quagga);\n                defineProperty_default()(this, \"context\", new QuaggaContext_QuaggaContext());\n                defineProperty_default()(this, \"canRecord\", function(callback) {\n                    var _this$context$config;\n                    if (!_this.context.config) {\n                        return;\n                    }\n                    barcode_locator[\"a\" /* default */ ].checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);\n                    _this.initCanvas();\n                    _this.context.framegrabber = frame_grabber_default.a.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);\n                    if (_this.context.config.numOfWorkers === undefined) {\n                        _this.context.config.numOfWorkers = 0;\n                    }\n                    adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function() {\n                        var _this$context$config2;\n                        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {\n                            _this.initializeData();\n                        }\n                        _this.ready(callback);\n                    });\n                });\n                defineProperty_default()(this, \"update\", function() {\n                    if (_this.context.onUIThread) {\n                        var workersUpdated = updateWorkers(_this.context.framegrabber);\n                        if (!workersUpdated) {\n                            var _this$context$inputIm;\n                            _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);\n                            if (_this.context.framegrabber.grab()) {\n                                if (!workersUpdated) {\n                                    _this.locateAndDecode();\n                                }\n                            }\n                        }\n                    } else {\n                        var _this$context$inputIm2;\n                        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);\n                        _this.context.framegrabber.grab();\n                        _this.locateAndDecode();\n                    }\n                });\n            }\n            createClass_default()(Quagga, [\n                {\n                    key: \"initBuffers\",\n                    value: function initBuffers(imageWrapper) {\n                        if (!this.context.config) {\n                            return;\n                        }\n                        var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator), inputImageWrapper = _initBuffers2.inputImageWrapper, boxSize = _initBuffers2.boxSize;\n                        this.context.inputImageWrapper = inputImageWrapper;\n                        this.context.boxSize = boxSize;\n                    }\n                },\n                {\n                    key: \"initializeData\",\n                    value: function initializeData(imageWrapper) {\n                        if (!this.context.config) {\n                            return;\n                        }\n                        this.initBuffers(imageWrapper);\n                        this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);\n                    }\n                },\n                {\n                    key: \"getViewPort\",\n                    value: function getViewPort() {\n                        if (!this.context.config || !this.context.config.inputStream) {\n                            return null;\n                        }\n                        var target = this.context.config.inputStream.target;\n                        return getViewPort_getViewPort(target);\n                    }\n                },\n                {\n                    key: \"ready\",\n                    value: function ready(callback) {\n                        this.context.inputStream.play();\n                        callback();\n                    }\n                },\n                {\n                    key: \"initCanvas\",\n                    value: function initCanvas() {\n                        var container = initCanvas_initCanvas(this.context);\n                        if (!container) {\n                            return;\n                        }\n                        var ctx = container.ctx, dom = container.dom;\n                        this.context.canvasContainer.dom.image = dom.image;\n                        this.context.canvasContainer.dom.overlay = dom.overlay;\n                        this.context.canvasContainer.ctx.image = ctx.image;\n                        this.context.canvasContainer.ctx.overlay = ctx.overlay;\n                    }\n                },\n                {\n                    key: \"initInputStream\",\n                    value: function initInputStream(callback) {\n                        if (!this.context.config || !this.context.config.inputStream) {\n                            return;\n                        }\n                        var _this$context$config$ = this.context.config.inputStream, inputType = _this$context$config$.type, constraints = _this$context$config$.constraints;\n                        var _setupInputStream = setupInputStream(inputType, this.getViewPort(), input_stream), video = _setupInputStream.video, inputStream = _setupInputStream.inputStream;\n                        if (inputType === \"LiveStream\" && video) {\n                            camera_access.request(video, constraints).then(function() {\n                                return inputStream.trigger(\"canrecord\");\n                            })[\"catch\"](function(err) {\n                                return callback(err);\n                            });\n                        }\n                        if (inputStream) {\n                            inputStream.setAttribute(\"preload\", \"auto\");\n                            inputStream.setInputStream(this.context.config.inputStream);\n                            inputStream.addEventListener(\"canrecord\", this.canRecord.bind(undefined, callback));\n                        }\n                        this.context.inputStream = inputStream;\n                    }\n                },\n                {\n                    key: \"getBoundingBoxes\",\n                    value: function getBoundingBoxes() {\n                        var _this$context$config3;\n                        return (_this$context$config3 = this.context.config) !== null && _this$context$config3 !== void 0 && _this$context$config3.locate ? barcode_locator[\"a\" /* default */ ].locate() : [\n                            [\n                                external_gl_matrix_[\"vec2\"].clone(this.context.boxSize[0]),\n                                external_gl_matrix_[\"vec2\"].clone(this.context.boxSize[1]),\n                                external_gl_matrix_[\"vec2\"].clone(this.context.boxSize[2]),\n                                external_gl_matrix_[\"vec2\"].clone(this.context.boxSize[3])\n                            ]\n                        ];\n                    }\n                },\n                {\n                    key: \"transformResult\",\n                    value: function transformResult(result) {\n                        var _this2 = this;\n                        var topRight = this.context.inputStream.getTopRight();\n                        var xOffset = topRight.x;\n                        var yOffset = topRight.y;\n                        if (xOffset === 0 && yOffset === 0) {\n                            return;\n                        }\n                        if (result.barcodes) {\n                            // TODO: BarcodeInfo may not be the right type here.\n                            result.barcodes.forEach(function(barcode) {\n                                return _this2.transformResult(barcode);\n                            });\n                        }\n                        if (result.line && result.line.length === 2) {\n                            moveLine(result.line, xOffset, yOffset);\n                        }\n                        if (result.box) {\n                            moveBox(result.box, xOffset, yOffset);\n                        }\n                        if (result.boxes && result.boxes.length > 0) {\n                            for(var i = 0; i < result.boxes.length; i++){\n                                moveBox(result.boxes[i], xOffset, yOffset);\n                            }\n                        }\n                    }\n                },\n                {\n                    key: \"addResult\",\n                    value: function addResult(result, imageData) {\n                        var _this3 = this;\n                        if (!imageData || !this.context.resultCollector) {\n                            return;\n                        }\n                        // TODO: Figure out what data structure holds a \"barcodes\" result, if any...\n                        if (result.barcodes) {\n                            result.barcodes.filter(function(barcode) {\n                                return barcode.codeResult;\n                            }).forEach(function(barcode) {\n                                return _this3.addResult(barcode, imageData);\n                            });\n                        } else if (result.codeResult) {\n                            this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);\n                        }\n                    }\n                },\n                {\n                    key: \"hasCodeResult\",\n                    value: function hasCodeResult(result) {\n                        return !!(result && (result.barcodes ? result.barcodes.some(function(barcode) {\n                            return barcode.codeResult;\n                        }) : result.codeResult));\n                    }\n                },\n                {\n                    key: \"publishResult\",\n                    value: function publishResult1() {\n                        var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n                        var imageData = arguments.length > 1 ? arguments[1] : undefined;\n                        var resultToPublish = result;\n                        if (result && this.context.onUIThread) {\n                            var _result$barcodes;\n                            this.transformResult(result);\n                            this.addResult(result, imageData);\n                            // @ts-ignore\n                            resultToPublish = (result === null || result === void 0 ? void 0 : (_result$barcodes = result.barcodes) === null || _result$barcodes === void 0 ? void 0 : _result$barcodes.length) > 0 ? result.barcodes : result;\n                        }\n                        events.publish(\"processed\", resultToPublish);\n                        if (this.hasCodeResult(result)) {\n                            events.publish(\"detected\", resultToPublish);\n                        }\n                    }\n                },\n                {\n                    key: \"locateAndDecode\",\n                    value: function() {\n                        var _locateAndDecode = asyncToGenerator_default()(/*#__PURE__*/ regenerator_default.a.mark(function _callee() {\n                            var boxes, _this$context$inputIm3, decodeResult, imageResult, _this$context$inputIm4;\n                            return regenerator_default.a.wrap(function _callee$(_context) {\n                                while(1)switch(_context.prev = _context.next){\n                                    case 0:\n                                        boxes = this.getBoundingBoxes();\n                                        if (!boxes) {\n                                            _context.next = 12;\n                                            break;\n                                        }\n                                        _context.next = 4;\n                                        return this.context.decoder.decodeFromBoundingBoxes(boxes);\n                                    case 4:\n                                        _context.t0 = _context.sent;\n                                        if (_context.t0) {\n                                            _context.next = 7;\n                                            break;\n                                        }\n                                        _context.t0 = {};\n                                    case 7:\n                                        decodeResult = _context.t0;\n                                        decodeResult.boxes = boxes;\n                                        this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);\n                                        _context.next = 16;\n                                        break;\n                                    case 12:\n                                        _context.next = 14;\n                                        return this.context.decoder.decodeFromImage(this.context.inputImageWrapper);\n                                    case 14:\n                                        imageResult = _context.sent;\n                                        if (imageResult) {\n                                            this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);\n                                        } else {\n                                            this.publishResult();\n                                        }\n                                    case 16:\n                                    case \"end\":\n                                        return _context.stop();\n                                }\n                            }, _callee, this);\n                        }));\n                        function locateAndDecode() {\n                            return _locateAndDecode.apply(this, arguments);\n                        }\n                        return locateAndDecode;\n                    }()\n                },\n                {\n                    key: \"startContinuousUpdate\",\n                    value: function startContinuousUpdate() {\n                        var _this$context$config4, _this4 = this;\n                        var next = null;\n                        var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);\n                        this.context.stopped = false;\n                        var context = this.context;\n                        var newFrame = function newFrame(timestamp) {\n                            next = next || timestamp;\n                            if (!context.stopped) {\n                                if (timestamp >= next) {\n                                    next += delay;\n                                    _this4.update();\n                                }\n                                window.requestAnimationFrame(newFrame);\n                            }\n                        };\n                        newFrame(performance.now());\n                    }\n                },\n                {\n                    key: \"start\",\n                    value: function start() {\n                        var _this$context$config5, _this$context$config6;\n                        if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === \"LiveStream\") {\n                            this.startContinuousUpdate();\n                        } else {\n                            this.update();\n                        }\n                    }\n                },\n                {\n                    key: \"stop\",\n                    value: function() {\n                        var _stop = asyncToGenerator_default()(/*#__PURE__*/ regenerator_default.a.mark(function _callee2() {\n                            var _this$context$config7;\n                            return regenerator_default.a.wrap(function _callee2$(_context2) {\n                                while(1)switch(_context2.prev = _context2.next){\n                                    case 0:\n                                        this.context.stopped = true;\n                                        adjustWorkerPool(0);\n                                        if (!((_this$context$config7 = this.context.config) !== null && _this$context$config7 !== void 0 && _this$context$config7.inputStream && this.context.config.inputStream.type === \"LiveStream\")) {\n                                            _context2.next = 6;\n                                            break;\n                                        }\n                                        _context2.next = 5;\n                                        return camera_access.release();\n                                    case 5:\n                                        this.context.inputStream.clearEventHandlers();\n                                    case 6:\n                                    case \"end\":\n                                        return _context2.stop();\n                                }\n                            }, _callee2, this);\n                        }));\n                        function stop() {\n                            return _stop.apply(this, arguments);\n                        }\n                        return stop;\n                    }()\n                },\n                {\n                    key: \"setReaders\",\n                    value: function setReaders(readers) {\n                        if (this.context.decoder) {\n                            this.context.decoder.setReaders(readers);\n                        }\n                        qworker_setReaders(readers);\n                    }\n                },\n                {\n                    key: \"registerReader\",\n                    value: function registerReader(name, reader) {\n                        barcode_decoder.registerReader(name, reader);\n                        if (this.context.decoder) {\n                            this.context.decoder.registerReader(name, reader);\n                        }\n                        qworker_registerReader(name, reader);\n                    }\n                }\n            ]);\n            return Quagga;\n        }();\n        // CONCATENATED MODULE: ./src/quagga.js\n        // eslint-disable-line no-unused-vars\n        var instance = new quagga_Quagga();\n        var _context = instance.context;\n        var QuaggaJSStaticInterface = {\n            init: function init(config, cb, imageWrapper) {\n                var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;\n                var promise;\n                if (!cb) {\n                    promise = new Promise(function(resolve, reject) {\n                        cb = function cb(err) {\n                            err ? reject(err) : resolve();\n                        };\n                    });\n                }\n                quaggaInstance.context.config = merge_default()({}, config_config, config);\n                // TODO #179: pending restructure in Issue #179, we are temp disabling workers\n                if (quaggaInstance.context.config.numOfWorkers > 0) {\n                    quaggaInstance.context.config.numOfWorkers = 0;\n                }\n                if (imageWrapper) {\n                    quaggaInstance.context.onUIThread = false;\n                    quaggaInstance.initializeData(imageWrapper);\n                    if (cb) {\n                        cb();\n                    }\n                } else {\n                    quaggaInstance.initInputStream(cb);\n                }\n                return promise;\n            },\n            start: function start() {\n                return instance.start();\n            },\n            stop: function stop() {\n                return instance.stop();\n            },\n            pause: function pause() {\n                _context.stopped = true;\n            },\n            onDetected: function onDetected(callback) {\n                if (!callback || typeof callback !== \"function\" && (typeof_default()(callback) !== \"object\" || !callback.callback)) {\n                    console.trace(\"* warning: Quagga.onDetected called with invalid callback, ignoring\");\n                    return;\n                }\n                events.subscribe(\"detected\", callback);\n            },\n            offDetected: function offDetected(callback) {\n                events.unsubscribe(\"detected\", callback);\n            },\n            onProcessed: function onProcessed(callback) {\n                if (!callback || typeof callback !== \"function\" && (typeof_default()(callback) !== \"object\" || !callback.callback)) {\n                    console.trace(\"* warning: Quagga.onProcessed called with invalid callback, ignoring\");\n                    return;\n                }\n                events.subscribe(\"processed\", callback);\n            },\n            offProcessed: function offProcessed(callback) {\n                events.unsubscribe(\"processed\", callback);\n            },\n            setReaders: function setReaders(readers) {\n                if (!readers) {\n                    console.trace(\"* warning: Quagga.setReaders called with no readers, ignoring\");\n                    return;\n                }\n                instance.setReaders(readers);\n            },\n            registerReader: function registerReader(name, reader) {\n                if (!name) {\n                    console.trace(\"* warning: Quagga.registerReader called with no name, ignoring\");\n                    return;\n                }\n                if (!reader) {\n                    console.trace(\"* warning: Quagga.registerReader called with no reader, ignoring\");\n                    return;\n                }\n                instance.registerReader(name, reader);\n            },\n            registerResultCollector: function registerResultCollector(resultCollector) {\n                if (resultCollector && typeof resultCollector.addResult === \"function\") {\n                    _context.resultCollector = resultCollector;\n                }\n            },\n            get canvas () {\n                return _context.canvasContainer;\n            },\n            decodeSingle: function decodeSingle(config, resultCallback) {\n                var _this = this;\n                var quaggaInstance = new quagga_Quagga();\n                config = merge_default()({\n                    inputStream: {\n                        type: \"ImageStream\",\n                        sequence: false,\n                        size: 800,\n                        src: config.src\n                    },\n                    numOfWorkers:  false ? 0 : 1,\n                    locator: {\n                        halfSample: false\n                    }\n                }, config);\n                // TODO #175: restructure worker support so that it will work with typescript using worker-loader\n                // https://webpack.js.org/loaders/worker-loader/\n                if (config.numOfWorkers > 0) {\n                    config.numOfWorkers = 0;\n                }\n                // workers require Worker and Blob support presently, so if no Blob or Worker then set\n                // workers to 0.\n                if (config.numOfWorkers > 0 && (typeof Blob === \"undefined\" || typeof Worker === \"undefined\")) {\n                    console.warn(\"* no Worker and/or Blob support - forcing numOfWorkers to 0\");\n                    config.numOfWorkers = 0;\n                }\n                return new Promise(function(resolve, reject) {\n                    try {\n                        _this.init(config, function() {\n                            events.once(\"processed\", function(result) {\n                                quaggaInstance.stop();\n                                if (resultCallback) {\n                                    resultCallback.call(null, result);\n                                }\n                                resolve(result);\n                            }, true);\n                            quaggaInstance.start();\n                        }, null, quaggaInstance);\n                    } catch (err) {\n                        reject(err);\n                    }\n                });\n            },\n            // add the usually expected \"default\" for use with require, build step won't allow us to\n            // write to module.exports so do it here.\n            get default () {\n                return QuaggaJSStaticInterface;\n            },\n            Readers: reader_namespaceObject,\n            CameraAccess: camera_access,\n            ImageDebug: image_debug[\"a\" /* default */ ],\n            ImageWrapper: image_wrapper[\"a\" /* default */ ],\n            ResultCollector: result_collector\n        };\n        /* harmony default export */ var quagga = __nested_webpack_exports__[\"default\"] = QuaggaJSStaticInterface;\n    // export BarcodeReader and other utilities for external plugins\n    /***/ }\n])[\"default\"]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVyaWNibGFkZS9xdWFnZ2EyL2xpYi9xdWFnZ2EuanMiLCJtYXBwaW5ncyI6IkFBQUMsVUFBU0EsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSSxJQUFJQyxLQUFLRCxFQUFHRCxDQUFDLENBQUNFLEVBQUUsR0FBR0QsQ0FBQyxDQUFDQyxFQUFFO0FBQUUsR0FBRUMsU0FBa0IsTUFBSCxHQUFJLFNBQVNDLE9BQU87SUFDcEYsTUFBTSxHQUFJLG1CQUFtQjtJQUM3QixNQUFNLEdBQUksSUFBSUMsbUJBQW1CLENBQUM7SUFDbEMsTUFBTSxHQUNOLE1BQU0sR0FBSSx1QkFBdUI7SUFDakMsTUFBTSxHQUFJLFNBQVNDLDhCQUFtQkEsQ0FBQ0MsUUFBUTtRQUMvQyxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtRQUN6QyxNQUFNLEdBQUssSUFBR0YsZ0JBQWdCLENBQUNFLFNBQVMsRUFBRTtZQUMxQyxNQUFNLEdBQU0sT0FBT0YsZ0JBQWdCLENBQUNFLFNBQVMsQ0FBQ0osT0FBTztRQUNyRCxNQUFNLEdBQUs7UUFDWCxNQUFNLEdBQUssa0RBQWtEO1FBQzdELE1BQU0sR0FBSyxJQUFJSyxTQUFTSCxnQkFBZ0IsQ0FBQ0UsU0FBUyxHQUFHO1lBQ3JELE1BQU0sR0FBTUwsR0FBR0s7WUFDZixNQUFNLEdBQU1FLEdBQUc7WUFDZixNQUFNLEdBQU1OLFNBQVMsQ0FBQztRQUNYO1FBQ1gsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7UUFDekMsTUFBTSxHQUFLQyxPQUFPLENBQUNHLFNBQVMsQ0FBQ0csSUFBSSxDQUFDRixPQUFPTCxPQUFPLEVBQUVLLFFBQVFBLE9BQU9MLE9BQU8sRUFBRUcsOEJBQW1CQTtRQUM3RixNQUFNLEdBQ04sTUFBTSxHQUFLLDRCQUE0QjtRQUN2QyxNQUFNLEdBQUtFLE9BQU9DLENBQUMsR0FBRztRQUN0QixNQUFNLEdBQ04sTUFBTSxHQUFLLG1DQUFtQztRQUM5QyxNQUFNLEdBQUssT0FBT0QsT0FBT0ws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QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFBRTt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztx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TUFBTTtvQkFDMUMsSUFBSTt3QkFDRmc1QixNQUFNamhDLElBQUksQ0FBQ2tTLFFBQVE7NEJBQ2pCeWlDLE9BQU9hLElBQUksQ0FBQyxhQUFhLFNBQVV0d0MsTUFBTTtnQ0FDdkN5aEQsZUFBZWp2QixJQUFJO2dDQUNuQixJQUFJd3ZCLGdCQUFnQjtvQ0FDbEJBLGVBQWV2ckQsSUFBSSxDQUFDLE1BQU11SjtnQ0FDNUI7Z0NBQ0E4QyxRQUFROUM7NEJBQ1YsR0FBRzs0QkFDSHloRCxlQUFleGhDLEtBQUs7d0JBQ3RCLEdBQUcsTUFBTXdoQztvQkFDWCxFQUFFLE9BQU85OUMsS0FBSzt3QkFDWlosT0FBT1k7b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUNBLHdGQUF3RjtZQUN4Rix5Q0FBeUM7WUFDekMsSUFBSXMrQyxXQUFVO2dCQUNaLE9BQU9UO1lBQ1Q7WUFDQVUsU0FBUy9yQjtZQUNUZ3NCLGNBQWMvckI7WUFDZGdzQixZQUFZL3JCLFdBQVcsQ0FBQyxJQUFJLFdBQVcsSUFBRztZQUMxQzU0QixjQUFjNjRCLGFBQWEsQ0FBQyxJQUFJLFdBQVcsSUFBRztZQUM5QytyQixpQkFBaUI5ckI7UUFDbkI7UUFDQSwwQkFBMEIsR0FBRyxJQUFJK3JCLFNBQVN6bkQsMEJBQW1CLENBQUMsVUFBVSxHQUFJMm1EO0lBQzVFLGdFQUFnRTtJQUdoRSxHQUFHLEdBQUc7Q0FDSSxDQUFDLENBQUMsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL3FyLWNvZGUvLi9ub2RlX21vZHVsZXMvQGVyaWNibGFkZS9xdWFnZ2EyL2xpYi9xdWFnZ2EuanM/YjMxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oZSwgYSkgeyBmb3IodmFyIGkgaW4gYSkgZVtpXSA9IGFbaV07IH0oZXhwb3J0cywgLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNjkpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHRvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIik7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX3R5cGVvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpW1wiZGVmYXVsdFwiXTtcbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gVE9ETyhCYWJlbCA4KTogUmVtb3ZlIHRoaXMgZmlsZS5cblxudmFyIHJ1bnRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNykoKTtcbm1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcblxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9wYWNrYWdlcy9ydW50aW1lL3J1bnRpbWUuanMjTDczNj1cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdChhcnIsIHZhbCkge1xuICAgIGFyci5maWxsKHZhbCk7XG4gIH0sXG4gIC8qKlxuICAgKiBJTi1QTEFDRSBTaHVmZmxlcyB0aGUgY29udGVudCBvZiBhbiBhcnJheVxuICAgKi9cbiAgc2h1ZmZsZTogZnVuY3Rpb24gc2h1ZmZsZShhcnIpIHtcbiAgICAvLyBEdXJzdGVuZmVsZCBzaHVmZmxlIGFsZ29yaXRobVxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0NTA5NTQvaG93LXRvLXJhbmRvbWl6ZS1zaHVmZmxlLWEtamF2YXNjcmlwdC1hcnJheVxuICAgIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgdmFyIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgIHZhciBfcmVmID0gW2FycltqXSwgYXJyW2ldXTtcbiAgICAgIGFycltpXSA9IF9yZWZbMF07XG4gICAgICBhcnJbal0gPSBfcmVmWzFdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9LFxuICB0b1BvaW50TGlzdDogZnVuY3Rpb24gdG9Qb2ludExpc3QoYXJyKSB7XG4gICAgdmFyIHJvd3MgPSBhcnIucmVkdWNlKGZ1bmN0aW9uIChwLCBuKSB7XG4gICAgICB2YXIgcm93ID0gXCJbXCIuY29uY2F0KG4uam9pbignLCcpLCBcIl1cIik7XG4gICAgICBwLnB1c2gocm93KTtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gXCJbXCIuY29uY2F0KHJvd3Muam9pbignLFxcclxcbicpLCBcIl1cIik7XG4gIH0sXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBlbGVtZW50cyB3aGljaCdzIHNjb3JlIGlzIGJpZ2dlciB0aGFuIHRoZSB0aHJlc2hvbGRcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICB0aHJlc2hvbGQ6IGZ1bmN0aW9uIHRocmVzaG9sZChhcnIsIF90aHJlc2hvbGQsIHNjb3JlRnVuYykge1xuICAgIHZhciBxdWV1ZSA9IGFyci5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICAgIGlmIChzY29yZUZ1bmMuYXBwbHkoYXJyLCBbbmV4dF0pID49IF90aHJlc2hvbGQpIHtcbiAgICAgICAgcHJldi5wdXNoKG5leHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBxdWV1ZTtcbiAgfSxcbiAgbWF4SW5kZXg6IGZ1bmN0aW9uIG1heEluZGV4KGFycikge1xuICAgIHZhciBtYXggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2ldID4gYXJyW21heF0pIHtcbiAgICAgICAgbWF4ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfSxcbiAgbWF4OiBmdW5jdGlvbiBtYXgoYXJyKSB7XG4gICAgdmFyIG1heCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbaV0gPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gYXJyW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9LFxuICBzdW06IGZ1bmN0aW9uIHN1bShhcnIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHN1bSArPSBhcnJbbGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19zbGljZWRUb0FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX3NsaWNlZFRvQXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfYmFiZWxfcnVudGltZV9oZWxwZXJzX3NsaWNlZFRvQXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jbGFzc0NhbGxDaGVja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NsYXNzQ2FsbENoZWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jbGFzc0NhbGxDaGVja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NyZWF0ZUNsYXNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY3JlYXRlQ2xhc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NyZWF0ZUNsYXNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZ2xfbWF0cml4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGdsX21hdHJpeF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGdsX21hdHJpeF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXJyYXlfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jdl91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cblxuXG5cblxuXG5cbmdsX21hdHJpeF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZ2xNYXRyaXhcIl0uc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtcbmZ1bmN0aW9uIGFzc2VydE51bWJlclBvc2l0aXZlKHZhbCkge1xuICBpZiAodmFsIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHBvc2l0aXZlIG51bWJlciwgcmVjZWl2ZWQgXCIuY29uY2F0KHZhbCkpO1xuICB9XG59XG52YXIgSW1hZ2VXcmFwcGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gUmVwcmVzZW50cyBhIGJhc2ljIGltYWdlIGNvbWJpbmluZyB0aGUgZGF0YSBhbmQgc2l6ZS4gSW4gYWRkaXRpb24sIHNvbWUgbWV0aG9kcyBmb3JcbiAgLy8gbWFuaXB1bGF0aW9uIGFyZSBjb250YWluZWQgd2l0aGluLlxuICBmdW5jdGlvbiBJbWFnZVdyYXBwZXIoc2l6ZSwgZGF0YSkge1xuICAgIHZhciBBcnJheVR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFVpbnQ4QXJyYXk7XG4gICAgdmFyIGluaXRpYWxpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NsYXNzQ2FsbENoZWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKHRoaXMsIEltYWdlV3JhcHBlcik7XG4gICAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQoKSh0aGlzLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCgpKHRoaXMsIFwic2l6ZVwiLCB2b2lkIDApO1xuICAgIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0KCkodGhpcywgXCJpbmRleE1hcHBpbmdcIiwgdm9pZCAwKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBBcnJheVR5cGUoc2l6ZS54ICogc2l6ZS55KTtcbiAgICAgIGlmIChpbml0aWFsaXplKSB7XG4gICAgICAgIF9hcnJheV9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbml0KHRoaXMuZGF0YSwgMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gIH1cblxuICAvLyB0ZXN0cyBpZiBhIHBvc2l0aW9uIGlzIHdpdGhpbiB0aGUgaW1hZ2UsIGV4dGVuZGVkIG91dCBieSBhIGJvcmRlciBvbiBlYWNoIHNpZGVcbiAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19jcmVhdGVDbGFzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQoKShJbWFnZVdyYXBwZXIsIFt7XG4gICAga2V5OiBcImluSW1hZ2VXaXRoQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluSW1hZ2VXaXRoQm9yZGVyKGltZ1JlZikge1xuICAgICAgdmFyIGJvcmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGJvcmRlcik7XG4gICAgICByZXR1cm4gaW1nUmVmLnggPj0gMCAmJiBpbWdSZWYueSA+PSAwICYmIGltZ1JlZi54IDwgdGhpcy5zaXplLnggKyBib3JkZXIgKiAyICYmIGltZ1JlZi55IDwgdGhpcy5zaXplLnkgKyBib3JkZXIgKiAyO1xuICAgIH1cblxuICAgIC8vIENvcHkgZnJvbSBUSElTIEltYWdlV3JhcHBlciB0byB0aGUgbmV3IGltYWdlV3JhcHBlciBwYXJhbWV0ZXIsIHN0YXJ0aW5nIGF0IGZyb20sIHN0b3BwaW5nIGF0XG4gICAgLy8gZW5kIG9mIG5ldyBpbWFnZVdyYXBwZXIgc2l6ZS5cbiAgfSwge1xuICAgIGtleTogXCJzdWJJbWFnZUFzQ29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJJbWFnZUFzQ29weShpbWFnZVdyYXBwZXIsIGZyb20pIHtcbiAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGZyb20ueCk7XG4gICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLnkpO1xuICAgICAgdmFyIF9pbWFnZVdyYXBwZXIkc2l6ZSA9IGltYWdlV3JhcHBlci5zaXplLFxuICAgICAgICBzaXplWCA9IF9pbWFnZVdyYXBwZXIkc2l6ZS54LFxuICAgICAgICBzaXplWSA9IF9pbWFnZVdyYXBwZXIkc2l6ZS55O1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzaXplWDsgeCsrKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2l6ZVk7IHkrKykge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgIGltYWdlV3JhcHBlci5kYXRhW3kgKiBzaXplWCArIHhdID0gdGhpcy5kYXRhWyhmcm9tLnkgKyB5KSAqIHRoaXMuc2l6ZS54ICsgZnJvbS54ICsgeF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbWFnZVdyYXBwZXI7XG4gICAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIHJlYWxseSBwcm9iYWJseSBzaG91bGQgY2FsbCBpbnRvIEltYWdlV3JhcHBlciBzb21ld2hlcmUgdG8gbWFrZVxuICAgICAgLy8gc3VyZSB0aGF0IGFsbCBvZiBpdCdzIHBhcmFtZXRlcnMgYXJlIHNldCBwcm9wZXJseSwgc29tZXRoaW5nIGxpa2VcbiAgICAgIC8vIEltYWdlV3JhcHBlci5VcGRhdGVGcm9tKClcbiAgICAgIC8vIHRoYXQgbWlnaHQgdGFrZSBhIHByb3ZpZGVkIGRhdGEgYW5kIHNpemUsIGFuZCBtYWtlIHN1cmUgdGhlcmUncyBubyBpbnZhbGlkIGluZGV4TWFwcGluZ1xuICAgICAgLy8gaGFuZ2luZyBhcm91bmQsIGFuZCBzdWNoLlxuICAgIH1cblxuICAgIC8vIFJldHJpZXZlIGEgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2VcbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF07XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZSAoc2FmZSwgd2hhdGV2ZXIgdGhhdFxuICAgIC8vIG1lYW5zKVxuICB9LCB7XG4gICAga2V5OiBcImdldFNhZmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2FmZSh4LCB5KSB7XG4gICAgICAvLyBjYWNoZSBpbmRleE1hcHBpbmcgYmVjYXVzZSBpZiB3ZSdyZSB1c2luZyBpdCBvbmNlLCB3ZSdsbCBwcm9iYWJseSBuZWVkIGl0IGEgYnVuY2ggbW9yZVxuICAgICAgLy8gdG9vXG4gICAgICBpZiAoIXRoaXMuaW5kZXhNYXBwaW5nKSB7XG4gICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nID0ge1xuICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgIHk6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaXplLng7IGkrKykge1xuICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaV0gPSBpO1xuICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaSArIHRoaXMuc2l6ZS54XSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuc2l6ZS55OyBfaSsrKSB7XG4gICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueVtfaV0gPSBfaTtcbiAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W19pICsgdGhpcy5zaXplLnldID0gX2k7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5pbmRleE1hcHBpbmcueVt5ICsgdGhpcy5zaXplLnldICogdGhpcy5zaXplLnggKyB0aGlzLmluZGV4TWFwcGluZy54W3ggKyB0aGlzLnNpemUueF1dO1xuICAgIH1cblxuICAgIC8vIFNldHMgYSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBpbiB0aGUgaW1hZ2UgdG8gdGhlIGdpdmVuIGdyYXlzY2FsZSB2YWx1ZVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoeCwgeSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gU2V0cyB0aGUgYm9yZGVyIG9mIHRoZSBpbWFnZSAoMSBwaXhlbCkgdG8gemVyb1xuICB9LCB7XG4gICAga2V5OiBcInplcm9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gemVyb0JvcmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRzaXplID0gdGhpcy5zaXplLFxuICAgICAgICB3aWR0aCA9IF90aGlzJHNpemUueCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkc2l6ZS55O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgdGhpcy5kYXRhW2ldID0gdGhpcy5kYXRhWyhoZWlnaHQgLSAxKSAqIHdpZHRoICsgaV0gPSAwO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kyID0gMTsgX2kyIDwgaGVpZ2h0IC0gMTsgX2kyKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgICAgICB0aGlzLmRhdGFbX2kyICogd2lkdGhdID0gdGhpcy5kYXRhW19pMiAqIHdpZHRoICsgKHdpZHRoIC0gMSldID0gMDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLmluZGV4TWFwcGluZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gaXMgZW50aXJlbHkgdG9vIGxhcmdlIGZvciBtZSB0byByZWFzb24gb3V0IHJpZ2h0IGF0IHRoaXMgbW9tZW50IHRoYXQgaSdtIGhhbmRsaW5nXG4gICAgLy8gYWxsIHRoZSByZXN0IG9mIGl0LCBzbyB0aGlzIGlzIGEgdmVyYmF0aW0gY29weSBvZiB0aGUgamF2YXNjcmlwdCBzb3VyY2UsIHdpdGggb25seSB0d2Vha3NcbiAgICAvLyBuZWNlc3NhcnkgdG8gZ2V0IGl0IHRvIHJ1biwgbm8gdGhvdWdodCBwdXQgaW50byBpdCB5ZXQuXG4gIH0sIHtcbiAgICBrZXk6IFwibW9tZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb21lbnRzKGxhYmVsQ291bnQpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgdmFyIHg7XG4gICAgICB2YXIgeTtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnNpemUueTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgICAgdmFyIHZhbDtcbiAgICAgIHZhciB5c3E7XG4gICAgICB2YXIgbGFiZWxTdW0gPSBbXTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxhYmVsO1xuICAgICAgdmFyIG11MTE7XG4gICAgICB2YXIgbXUwMjtcbiAgICAgIHZhciBtdTIwO1xuICAgICAgdmFyIHhfO1xuICAgICAgdmFyIHlfO1xuICAgICAgdmFyIHRtcDtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBQSSA9IE1hdGguUEk7XG4gICAgICB2YXIgUElfNCA9IFBJIC8gNDtcbiAgICAgIGlmIChsYWJlbENvdW50IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgICAgbGFiZWxTdW1baV0gPSB7XG4gICAgICAgICAgbTAwOiAwLFxuICAgICAgICAgIG0wMTogMCxcbiAgICAgICAgICBtMTA6IDAsXG4gICAgICAgICAgbTExOiAwLFxuICAgICAgICAgIG0wMjogMCxcbiAgICAgICAgICBtMjA6IDAsXG4gICAgICAgICAgdGhldGE6IDAsXG4gICAgICAgICAgcmFkOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgeXNxID0geSAqIHk7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgdmFsID0gZGF0YVt5ICogd2lkdGggKyB4XTtcbiAgICAgICAgICBpZiAodmFsID4gMCkge1xuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbFN1bVt2YWwgLSAxXTtcbiAgICAgICAgICAgIGxhYmVsLm0wMCArPSAxO1xuICAgICAgICAgICAgbGFiZWwubTAxICs9IHk7XG4gICAgICAgICAgICBsYWJlbC5tMTAgKz0geDtcbiAgICAgICAgICAgIGxhYmVsLm0xMSArPSB4ICogeTtcbiAgICAgICAgICAgIGxhYmVsLm0wMiArPSB5c3E7XG4gICAgICAgICAgICBsYWJlbC5tMjAgKz0geCAqIHg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICAgIGxhYmVsID0gbGFiZWxTdW1baV07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAgICAgaWYgKCFpc05hTihsYWJlbC5tMDApICYmIGxhYmVsLm0wMCAhPT0gMCkge1xuICAgICAgICAgIHhfID0gbGFiZWwubTEwIC8gbGFiZWwubTAwO1xuICAgICAgICAgIHlfID0gbGFiZWwubTAxIC8gbGFiZWwubTAwO1xuICAgICAgICAgIG11MTEgPSBsYWJlbC5tMTEgLyBsYWJlbC5tMDAgLSB4XyAqIHlfO1xuICAgICAgICAgIG11MDIgPSBsYWJlbC5tMDIgLyBsYWJlbC5tMDAgLSB5XyAqIHlfO1xuICAgICAgICAgIG11MjAgPSBsYWJlbC5tMjAgLyBsYWJlbC5tMDAgLSB4XyAqIHhfO1xuICAgICAgICAgIHRtcCA9IChtdTAyIC0gbXUyMCkgLyAoMiAqIG11MTEpO1xuICAgICAgICAgIHRtcCA9IDAuNSAqIE1hdGguYXRhbih0bXApICsgKG11MTEgPj0gMCA/IFBJXzQgOiAtUElfNCkgKyBQSTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgICAgICAgbGFiZWwudGhldGEgPSAodG1wICogMTgwIC8gUEkgKyA5MCkgJSAxODAgLSA5MDtcbiAgICAgICAgICBpZiAobGFiZWwudGhldGEgPCAwKSB7XG4gICAgICAgICAgICBsYWJlbC50aGV0YSArPSAxODA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhYmVsLnJhZCA9IHRtcCA+IFBJID8gdG1wIC0gUEkgOiB0bXA7XG4gICAgICAgICAgbGFiZWwudmVjID0gZ2xfbWF0cml4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJ2ZWMyXCJdLmNsb25lKFtNYXRoLmNvcyh0bXApLCBNYXRoLnNpbih0bXApXSk7XG4gICAgICAgICAgcmVzdWx0LnB1c2gobGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIHJldHVybiBhIFVpbnQ4Q2xhbXBlZEFycmF5IGNvbnRhaW5pbmcgdGhpcyBncmF5c2NhbGUgaW1hZ2UgY29udmVydGVkIHRvIFJHQkEgZm9ybVxuICB9LCB7XG4gICAga2V5OiBcImdldEFzUkdCQVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBc1JHQkEoKSB7XG4gICAgICB2YXIgc2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDEuMDtcbiAgICAgIHZhciByZXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoNCAqIHRoaXMuc2l6ZS54ICogdGhpcy5zaXplLnkpO1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCB0aGlzLnNpemUueTsgeSsrKSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5zaXplLng7IHgrKykge1xuICAgICAgICAgIHZhciBwaXhlbCA9IHkgKiB0aGlzLnNpemUueCArIHg7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldCh4LCB5KSAqIHNjYWxlO1xuICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAwXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgcmV0W3BpeGVsICogNCArIDFdID0gY3VycmVudDtcbiAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMl0gPSBjdXJyZW50O1xuICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAzXSA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBEaXNwbGF5IHRoaXMgSW1hZ2VXcmFwcGVyIGluIGEgZ2l2ZW4gQ2FudmFzIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBzY2FsZVxuICB9LCB7XG4gICAga2V5OiBcInNob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdyhjYW52YXMpIHtcbiAgICAgIHZhciBzY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMS4wO1xuICAgICAgY29uc29sZS53YXJuKCcqIGltYWdld3JhcHBlciBzaG93IGdldGNvbnRleHQgMmQnKTtcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgICAgfVxuICAgICAgdmFyIGZyYW1lID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldEFzUkdCQShzY2FsZSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5zaXplLnk7XG4gICAgICB2YXIgbmV3RnJhbWUgPSBuZXcgSW1hZ2VEYXRhKGRhdGEsIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShuZXdGcmFtZSwgMCwgMCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGxheXMgYSBzcGVjaWZpZWQgU3ViSW1hZ2UgYXJlYSBpbiBhIGdpdmVuIGNhbnZhcy4gVGhpcyBkaWZmZXJzIGRyYXN0aWNhbGx5IGZyb21cbiAgICAvLyBjcmVhdGluZyBhIG5ldyBTdWJJbWFnZSBhbmQgdXNpbmcgaXQncyBzaG93KCkgbWV0aG9kLiBXaHk/IEkgZG9uJ3QgaGF2ZSB0aGUgYW5zd2VyIHRvIHRoYXRcbiAgICAvLyB5ZXQuICBJIHN1c3BlY3QgdGhlIEhTVi9SR0Igb3BlcmF0aW9ucyBpbnZvbHZlZCBoZXJlIGFyZSBtYWtpbmcgaXQgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQsXG4gICAgLy8gYnV0IHVudGlsIEkgY2FuIHZpc3VhbGl6ZSB0aGVzZSBmdW5jdGlvbnMgc2lkZSBieSBzaWRlLCBJJ20ganVzdCBnb2luZyB0byBjb3B5IHRoZSBleGlzdGluZ1xuICAgIC8vIGltcGxlbWVudGF0aW9uLlxuICB9LCB7XG4gICAga2V5OiBcIm92ZXJsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcmxheShjYW52YXMsIGluU2NhbGUsIGZyb20pIHtcbiAgICAgIHZhciBhZGp1c3RlZFNjYWxlID0gaW5TY2FsZSA8IDAgfHwgaW5TY2FsZSA+IDM2MCA/IDM2MCA6IGluU2NhbGU7XG4gICAgICB2YXIgaHN2ID0gWzAsIDEsIDFdO1xuICAgICAgdmFyIHJnYiA9IFswLCAwLCAwXTtcbiAgICAgIHZhciB3aGl0ZVJnYiA9IFsyNTUsIDI1NSwgMjU1XTtcbiAgICAgIHZhciBibGFja1JnYiA9IFswLCAwLCAwXTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGNvbnNvbGUud2FybignKiBpbWFnZXdyYXBwZXIgb3ZlcmxheSBnZXRjb250ZXh0IDJkJyk7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoZnJvbS54LCBmcm9tLnksIHRoaXMuc2l6ZS54LCB0aGlzLnNpemUueSk7XG4gICAgICB2YXIgZGF0YSA9IGZyYW1lLmRhdGE7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBoc3ZbMF0gPSB0aGlzLmRhdGFbbGVuZ3RoXSAqIGFkanVzdGVkU2NhbGU7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICByZXN1bHQgPSBoc3ZbMF0gPD0gMCA/IHdoaXRlUmdiIDogaHN2WzBdID49IDM2MCA/IGJsYWNrUmdiIDogT2JqZWN0KF9jdl91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiaHN2MnJnYlwiXSkoaHN2LCByZ2IpO1xuICAgICAgICB2YXIgcG9zID0gbGVuZ3RoICogNDtcbiAgICAgICAgdmFyIF9yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHZhciBfcmVzdWx0MiA9IF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfc2xpY2VkVG9BcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShfcmVzdWx0LCAzKTtcbiAgICAgICAgZGF0YVtwb3NdID0gX3Jlc3VsdDJbMF07XG4gICAgICAgIGRhdGFbcG9zICsgMV0gPSBfcmVzdWx0MlsxXTtcbiAgICAgICAgZGF0YVtwb3MgKyAyXSA9IF9yZXN1bHQyWzJdO1xuICAgICAgICBkYXRhW3BvcyArIDNdID0gMjU1O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShmcmFtZSwgZnJvbS54LCBmcm9tLnkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW1hZ2VXcmFwcGVyO1xufSgpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChJbWFnZVdyYXBwZXIpO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImltYWdlUmVmXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBpbWFnZVJlZjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjb21wdXRlSW50ZWdyYWxJbWFnZTJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNvbXB1dGVJbnRlZ3JhbEltYWdlMjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjb21wdXRlSW50ZWdyYWxJbWFnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gY29tcHV0ZUludGVncmFsSW1hZ2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidGhyZXNob2xkSW1hZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIHRocmVzaG9sZEltYWdlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNvbXB1dGVIaXN0b2dyYW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNvbXB1dGVIaXN0b2dyYW07IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2hhcnBlbkxpbmVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIHNoYXJwZW5MaW5lOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRldGVybWluZU90c3VUaHJlc2hvbGRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGRldGVybWluZU90c3VUaHJlc2hvbGQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib3RzdVRocmVzaG9sZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gb3RzdVRocmVzaG9sZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjb21wdXRlQmluYXJ5SW1hZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNvbXB1dGVCaW5hcnlJbWFnZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjbHVzdGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjdl91dGlsc19jbHVzdGVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlRyYWNlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gVHJhY2VyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkRJTEFURVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gRElMQVRFOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkVST0RFXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBFUk9ERTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkaWxhdGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGRpbGF0ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlcm9kZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gZXJvZGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic3VidHJhY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIHN1YnRyYWN0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJpdHdpc2VPclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gYml0d2lzZU9yOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNvdW50Tm9uWmVyb1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gY291bnROb25aZXJvOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRvcEdlbmVyaWNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIHRvcEdlbmVyaWM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ3JheUFycmF5RnJvbUltYWdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBncmF5QXJyYXlGcm9tSW1hZ2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ3JheUFycmF5RnJvbUNvbnRleHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGdyYXlBcnJheUZyb21Db250ZXh0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY29tcHV0ZUdyYXlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNvbXB1dGVHcmF5OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImxvYWRJbWFnZUFycmF5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBsb2FkSW1hZ2VBcnJheTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoYWxmU2FtcGxlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBoYWxmU2FtcGxlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImhzdjJyZ2JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGhzdjJyZ2I7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX2NvbXB1dGVEaXZpc29yc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gX2NvbXB1dGVEaXZpc29yczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjYWxjdWxhdGVQYXRjaFNpemVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNhbGN1bGF0ZVBhdGNoU2l6ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIF9wYXJzZUNTU0RpbWVuc2lvblZhbHVlczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfZGltZW5zaW9uc0NvbnZlcnRlcnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIF9kaW1lbnNpb25zQ29udmVydGVyczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjb21wdXRlSW1hZ2VBcmVhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjb21wdXRlSW1hZ2VBcmVhOyB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImdsLW1hdHJpeFwiXG52YXIgZXh0ZXJuYWxfZ2xfbWF0cml4XyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tbW9uL2FycmF5X2hlbHBlci50c1xudmFyIGFycmF5X2hlbHBlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbW1vbi9jbHVzdGVyLmpzXG4vLyBUT0RPOiBjbHVzdGVyLmpzIGFuZCBjdl91dGlscy5qcyBhcmUgcHJldHR5IHRpZ2h0bHkgaW50ZXJ0d2luZWQsIG1ha2luZyBmb3IgYSBjb21wbGV4IGNvbnZlcnNpb25cbi8vIGludG8gdHlwZXNjcmlwdC4gYmUgd2FybmVkLiA6LSlcblxuXG5leHRlcm5hbF9nbF9tYXRyaXhfW1wiZ2xNYXRyaXhcIl0uc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtcbi8qKlxuICogQ3JlYXRlcyBhIGNsdXN0ZXIgZm9yIGdyb3VwaW5nIHNpbWlsYXIgb3JpZW50YXRpb25zIG9mIGRhdGFwb2ludHNcbiAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2x1c3RlciA9ICh7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpIHtcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgdmFyIGNlbnRlciA9IHtcbiAgICAgIHJhZDogMCxcbiAgICAgIHZlYzogZXh0ZXJuYWxfZ2xfbWF0cml4X1tcInZlYzJcIl0uY2xvbmUoWzAsIDBdKVxuICAgIH07XG4gICAgdmFyIHBvaW50TWFwID0ge307XG4gICAgZnVuY3Rpb24gX2FkZChwb2ludFRvQWRkKSB7XG4gICAgICBwb2ludE1hcFtwb2ludFRvQWRkLmlkXSA9IHBvaW50VG9BZGQ7XG4gICAgICBwb2ludHMucHVzaChwb2ludFRvQWRkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ2VudGVyKCkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IHBvaW50c1tpXS5yYWQ7XG4gICAgICB9XG4gICAgICBjZW50ZXIucmFkID0gc3VtIC8gcG9pbnRzLmxlbmd0aDtcbiAgICAgIGNlbnRlci52ZWMgPSBleHRlcm5hbF9nbF9tYXRyaXhfW1widmVjMlwiXS5jbG9uZShbTWF0aC5jb3MoY2VudGVyLnJhZCksIE1hdGguc2luKGNlbnRlci5yYWQpXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBfYWRkKHBvaW50KTtcbiAgICAgIHVwZGF0ZUNlbnRlcigpO1xuICAgIH1cbiAgICBpbml0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgaWYgKCFwb2ludE1hcFtwb2ludFRvQWRkLmlkXSkge1xuICAgICAgICAgIF9hZGQocG9pbnRUb0FkZCk7XG4gICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmaXRzOiBmdW5jdGlvbiBmaXRzKG90aGVyUG9pbnQpIHtcbiAgICAgICAgLy8gY2hlY2sgY29zaW5lIHNpbWlsYXJpdHkgdG8gY2VudGVyLWFuZ2xlXG4gICAgICAgIHZhciBzaW1pbGFyaXR5ID0gTWF0aC5hYnMoZXh0ZXJuYWxfZ2xfbWF0cml4X1tcInZlYzJcIl0uZG90KG90aGVyUG9pbnQucG9pbnQudmVjLCBjZW50ZXIudmVjKSk7XG4gICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGdldFBvaW50czogZnVuY3Rpb24gZ2V0UG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgfSxcbiAgICAgIGdldENlbnRlcjogZnVuY3Rpb24gZ2V0Q2VudGVyKCkge1xuICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVBvaW50OiBmdW5jdGlvbiBjcmVhdGVQb2ludChuZXdQb2ludCwgaWQsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhZDogbmV3UG9pbnRbcHJvcGVydHldLFxuICAgICAgcG9pbnQ6IG5ld1BvaW50LFxuICAgICAgaWQ6IGlkXG4gICAgfTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21tb24vY3ZfdXRpbHMuanNcbi8qIGVzbGludC1kaXNhYmxlIG5vLW1peGVkLW9wZXJhdG9ycyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG5cblxuZXh0ZXJuYWxfZ2xfbWF0cml4X1tcImdsTWF0cml4XCJdLnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7XG5cbi8qKlxuICogQHBhcmFtIHggeC1jb29yZGluYXRlXG4gKiBAcGFyYW0geSB5LWNvb3JkaW5hdGVcbiAqIEByZXR1cm4gSW1hZ2VSZWZlcmVuY2Uge3gseX0gQ29vcmRpbmF0ZVxuICovXG5mdW5jdGlvbiBpbWFnZVJlZih4LCB5KSB7XG4gIHZhciB0aGF0ID0ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB0b1ZlYzI6IGZ1bmN0aW9uIHRvVmVjMigpIHtcbiAgICAgIHJldHVybiBleHRlcm5hbF9nbF9tYXRyaXhfW1widmVjMlwiXS5jbG9uZShbdGhpcy54LCB0aGlzLnldKTtcbiAgICB9LFxuICAgIHRvVmVjMzogZnVuY3Rpb24gdG9WZWMzKCkge1xuICAgICAgcmV0dXJuIGV4dGVybmFsX2dsX21hdHJpeF9bXCJ2ZWMzXCJdLmNsb25lKFt0aGlzLngsIHRoaXMueSwgMV0pO1xuICAgIH0sXG4gICAgcm91bmQ6IGZ1bmN0aW9uIHJvdW5kKCkge1xuICAgICAgdGhpcy54ID0gdGhpcy54ID4gMC4wID8gTWF0aC5mbG9vcih0aGlzLnggKyAwLjUpIDogTWF0aC5mbG9vcih0aGlzLnggLSAwLjUpO1xuICAgICAgdGhpcy55ID0gdGhpcy55ID4gMC4wID8gTWF0aC5mbG9vcih0aGlzLnkgKyAwLjUpIDogTWF0aC5mbG9vcih0aGlzLnkgLSAwLjUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdGhhdDtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBpbnRlZ3JhbCBpbWFnZSBvZiBhIGdpdmVuIGdyYXlzY2FsZSBpbWFnZS5cbiAqIEBwYXJhbSBpbWFnZURhdGFDb250YWluZXIge0ltYWdlRGF0YUNvbnRhaW5lcn0gdGhlIGltYWdlIHRvIGJlIGludGVncmF0ZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UyKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XG4gIHZhciBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgdmFyIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgdmFyIGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gIHZhciBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIHBvc0EgPSAwO1xuICB2YXIgcG9zQiA9IDA7XG4gIHZhciBwb3NDID0gMDtcbiAgdmFyIHBvc0QgPSAwO1xuICB2YXIgeDtcbiAgdmFyIHk7XG5cbiAgLy8gc3VtIHVwIGZpcnN0IGNvbHVtblxuICBwb3NCID0gd2lkdGg7XG4gIHN1bSA9IDA7XG4gIGZvciAoeSA9IDE7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgIHN1bSArPSBpbWFnZURhdGFbcG9zQV07XG4gICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgIHBvc0EgKz0gd2lkdGg7XG4gICAgcG9zQiArPSB3aWR0aDtcbiAgfVxuICBwb3NBID0gMDtcbiAgcG9zQiA9IDE7XG4gIHN1bSA9IDA7XG4gIGZvciAoeCA9IDE7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArPSBzdW07XG4gICAgcG9zQSsrO1xuICAgIHBvc0IrKztcbiAgfVxuICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICBwb3NBID0geSAqIHdpZHRoICsgMTtcbiAgICBwb3NCID0gKHkgLSAxKSAqIHdpZHRoICsgMTtcbiAgICBwb3NDID0geSAqIHdpZHRoO1xuICAgIHBvc0QgPSAoeSAtIDEpICogd2lkdGg7XG4gICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0FdICs9IGltYWdlRGF0YVtwb3NBXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICsgaW50ZWdyYWxJbWFnZURhdGFbcG9zQ10gLSBpbnRlZ3JhbEltYWdlRGF0YVtwb3NEXTtcbiAgICAgIHBvc0ErKztcbiAgICAgIHBvc0IrKztcbiAgICAgIHBvc0MrKztcbiAgICAgIHBvc0QrKztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XG4gIHZhciBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgdmFyIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgdmFyIGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gIHZhciBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICB2YXIgc3VtID0gMDtcblxuICAvLyBzdW0gdXAgZmlyc3Qgcm93XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIHN1bSArPSBpbWFnZURhdGFbaV07XG4gICAgaW50ZWdyYWxJbWFnZURhdGFbaV0gPSBzdW07XG4gIH1cbiAgZm9yICh2YXIgdiA9IDE7IHYgPCBoZWlnaHQ7IHYrKykge1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgdSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICBzdW0gKz0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdO1xuICAgICAgaW50ZWdyYWxJbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPSBzdW0gKyBpbnRlZ3JhbEltYWdlRGF0YVsodiAtIDEpICogd2lkdGggKyB1XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRocmVzaG9sZEltYWdlKGltYWdlV3JhcHBlciwgdGhyZXNob2xkLCB0YXJnZXRXcmFwcGVyKSB7XG4gIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gIH1cbiAgdmFyIGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICB2YXIgbGVuZ3RoID0gaW1hZ2VEYXRhLmxlbmd0aDtcbiAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXRXcmFwcGVyLmRhdGE7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHRhcmdldERhdGFbbGVuZ3RoXSA9IGltYWdlRGF0YVtsZW5ndGhdIDwgdGhyZXNob2xkID8gMSA6IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpIHtcbiAgaWYgKCFiaXRzUGVyUGl4ZWwpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBiaXRzUGVyUGl4ZWwgPSA4O1xuICB9XG4gIHZhciBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgdmFyIGxlbmd0aCA9IGltYWdlRGF0YS5sZW5ndGg7XG4gIHZhciBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XG4gIHZhciBidWNrZXRDbnQgPSAxIDw8IGJpdHNQZXJQaXhlbDtcbiAgdmFyIGhpc3QgPSBuZXcgSW50MzJBcnJheShidWNrZXRDbnQpO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBoaXN0W2ltYWdlRGF0YVtsZW5ndGhdID4+IGJpdFNoaWZ0XSsrO1xuICB9XG4gIHJldHVybiBoaXN0O1xufVxuZnVuY3Rpb24gc2hhcnBlbkxpbmUobGluZSkge1xuICB2YXIgaTtcbiAgdmFyIGxlbmd0aCA9IGxpbmUubGVuZ3RoO1xuICB2YXIgbGVmdCA9IGxpbmVbMF07XG4gIHZhciBjZW50ZXIgPSBsaW5lWzFdO1xuICB2YXIgcmlnaHQ7XG4gIGZvciAoaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICByaWdodCA9IGxpbmVbaSArIDFdO1xuICAgIC8vICAtMSA0IC0xIGtlcm5lbFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGxpbmVbaSAtIDFdID0gY2VudGVyICogMiAtIGxlZnQgLSByaWdodCAmIDI1NTtcbiAgICBsZWZ0ID0gY2VudGVyO1xuICAgIGNlbnRlciA9IHJpZ2h0O1xuICB9XG4gIHJldHVybiBsaW5lO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lT3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIpIHtcbiAgdmFyIGJpdHNQZXJQaXhlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogODtcbiAgdmFyIGhpc3Q7XG4gIHZhciBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XG4gIGZ1bmN0aW9uIHB4KGluaXQsIGVuZCkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSBpbml0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICBzdW0gKz0gaGlzdFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbiAgfVxuICBmdW5jdGlvbiBteChpbml0LCBlbmQpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgc3VtICs9IGkgKiBoaXN0W2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9XG4gIGZ1bmN0aW9uIGRldGVybWluZVRocmVzaG9sZCgpIHtcbiAgICB2YXIgdmV0ID0gWzBdO1xuICAgIHZhciBwMTtcbiAgICB2YXIgcDI7XG4gICAgdmFyIHAxMjtcbiAgICB2YXIgbTE7XG4gICAgdmFyIG0yO1xuICAgIHZhciBtMTI7XG4gICAgdmFyIG1heCA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgIGhpc3QgPSBjb21wdXRlSGlzdG9ncmFtKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsKTtcbiAgICBmb3IgKHZhciBrID0gMTsgayA8IG1heDsgaysrKSB7XG4gICAgICBwMSA9IHB4KDAsIGspO1xuICAgICAgcDIgPSBweChrICsgMSwgbWF4KTtcbiAgICAgIHAxMiA9IHAxICogcDI7XG4gICAgICBpZiAocDEyID09PSAwKSB7XG4gICAgICAgIHAxMiA9IDE7XG4gICAgICB9XG4gICAgICBtMSA9IG14KDAsIGspICogcDI7XG4gICAgICBtMiA9IG14KGsgKyAxLCBtYXgpICogcDE7XG4gICAgICBtMTIgPSBtMSAtIG0yO1xuICAgICAgdmV0W2tdID0gbTEyICogbTEyIC8gcDEyO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlfaGVscGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1heEluZGV4KHZldCk7XG4gIH1cbiAgdmFyIHRocmVzaG9sZCA9IGRldGVybWluZVRocmVzaG9sZCgpO1xuICByZXR1cm4gdGhyZXNob2xkIDw8IGJpdFNoaWZ0O1xufVxuZnVuY3Rpb24gb3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIsIHRhcmdldFdyYXBwZXIpIHtcbiAgdmFyIHRocmVzaG9sZCA9IGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyKTtcbiAgdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpO1xuICByZXR1cm4gdGhyZXNob2xkO1xufVxuXG4vLyBsb2NhbCB0aHJlc2hvbGRpbmdcbmZ1bmN0aW9uIGNvbXB1dGVCaW5hcnlJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcik7XG4gIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gIH1cbiAgdmFyIGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcbiAgdmFyIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgdmFyIGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gIHZhciBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIHY7XG4gIHZhciB1O1xuICB2YXIga2VybmVsID0gMztcbiAgdmFyIEE7XG4gIHZhciBCO1xuICB2YXIgQztcbiAgdmFyIEQ7XG4gIHZhciBhdmc7XG4gIHZhciBzaXplID0gKGtlcm5lbCAqIDIgKyAxKSAqIChrZXJuZWwgKiAyICsgMSk7XG5cbiAgLy8gY2xlYXIgb3V0IHRvcCAmIGJvdHRvbS1ib3JkZXJcbiAgZm9yICh2ID0gMDsgdiA8PSBrZXJuZWw7IHYrKykge1xuICAgIGZvciAodSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArIHVdID0gMDtcbiAgICAgIHRhcmdldERhdGFbKGhlaWdodCAtIDEgLSB2KSAqIHdpZHRoICsgdV0gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNsZWFyIG91dCBsZWZ0ICYgcmlnaHQgYm9yZGVyXG4gIGZvciAodiA9IGtlcm5lbDsgdiA8IGhlaWdodCAtIGtlcm5lbDsgdisrKSB7XG4gICAgZm9yICh1ID0gMDsgdSA8PSBrZXJuZWw7IHUrKykge1xuICAgICAgdGFyZ2V0RGF0YVt2ICogd2lkdGggKyB1XSA9IDA7XG4gICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArICh3aWR0aCAtIDEgLSB1KV0gPSAwO1xuICAgIH1cbiAgfVxuICBmb3IgKHYgPSBrZXJuZWwgKyAxOyB2IDwgaGVpZ2h0IC0ga2VybmVsIC0gMTsgdisrKSB7XG4gICAgZm9yICh1ID0ga2VybmVsICsgMTsgdSA8IHdpZHRoIC0ga2VybmVsOyB1KyspIHtcbiAgICAgIEEgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiAtIGtlcm5lbCAtIDEpICogd2lkdGggKyAodSAtIGtlcm5lbCAtIDEpXTtcbiAgICAgIEIgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiAtIGtlcm5lbCAtIDEpICogd2lkdGggKyAodSArIGtlcm5lbCldO1xuICAgICAgQyA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XG4gICAgICBEID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgKyBrZXJuZWwpICogd2lkdGggKyAodSArIGtlcm5lbCldO1xuICAgICAgc3VtID0gRCAtIEMgLSBCICsgQTtcbiAgICAgIGF2ZyA9IHN1bSAvIHNpemU7XG4gICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArIHVdID0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID4gYXZnICsgNSA/IDAgOiAxO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3ZfdXRpbHNfY2x1c3Rlcihwb2ludHMsIHRocmVzaG9sZCwgcHJvcGVydHkpIHtcbiAgdmFyIGk7XG4gIHZhciBrO1xuICB2YXIgdGhpc0NsdXN0ZXI7XG4gIHZhciBwb2ludDtcbiAgdmFyIGNsdXN0ZXJzID0gW107XG4gIGlmICghcHJvcGVydHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBwcm9wZXJ0eSA9ICdyYWQnO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFRvQ2x1c3RlcihuZXdQb2ludCkge1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIGZvciAoayA9IDA7IGsgPCBjbHVzdGVycy5sZW5ndGg7IGsrKykge1xuICAgICAgdGhpc0NsdXN0ZXIgPSBjbHVzdGVyc1trXTtcbiAgICAgIGlmICh0aGlzQ2x1c3Rlci5maXRzKG5ld1BvaW50KSkge1xuICAgICAgICB0aGlzQ2x1c3Rlci5hZGQobmV3UG9pbnQpO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8vIGl0ZXJhdGUgb3ZlciBlYWNoIGNsb3VkXG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBwb2ludCA9IGNsdXN0ZXIuY3JlYXRlUG9pbnQocG9pbnRzW2ldLCBpLCBwcm9wZXJ0eSk7XG4gICAgaWYgKCFhZGRUb0NsdXN0ZXIocG9pbnQpKSB7XG4gICAgICBjbHVzdGVycy5wdXNoKGNsdXN0ZXIuY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufVxudmFyIFRyYWNlciA9IHtcbiAgdHJhY2U6IGZ1bmN0aW9uIHRyYWNlKHBvaW50cywgdmVjKSB7XG4gICAgdmFyIGl0ZXJhdGlvbjtcbiAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgIHZhciB0b3AgPSBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGNlbnRlclBvcyA9IDA7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSAwO1xuICAgIGZ1bmN0aW9uIHRyYWNlKGlkeCwgZm9yd2FyZCkge1xuICAgICAgdmFyIHRvO1xuICAgICAgdmFyIHRvSWR4O1xuICAgICAgdmFyIHByZWRpY3RlZFBvcztcbiAgICAgIHZhciB0aHJlc2hvbGRYID0gMTtcbiAgICAgIHZhciB0aHJlc2hvbGRZID0gTWF0aC5hYnModmVjWzFdIC8gMTApO1xuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICBmdW5jdGlvbiBtYXRjaChwb3MsIHByZWRpY3RlZCkge1xuICAgICAgICBpZiAocG9zLnggPiBwcmVkaWN0ZWQueCAtIHRocmVzaG9sZFggJiYgcG9zLnggPCBwcmVkaWN0ZWQueCArIHRocmVzaG9sZFggJiYgcG9zLnkgPiBwcmVkaWN0ZWQueSAtIHRocmVzaG9sZFkgJiYgcG9zLnkgPCBwcmVkaWN0ZWQueSArIHRocmVzaG9sZFkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBuZXh0IGluZGV4IGlzIHdpdGhpbiB0aGUgdmVjIHNwZWNpZmljYXRpb25zXG4gICAgICAvLyBpZiBub3QsIGNoZWNrIGFzIGxvbmcgYXMgdGhlIHRocmVzaG9sZCBpcyBtZXRcblxuICAgICAgdmFyIGZyb20gPSBwb2ludHNbaWR4XTtcbiAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgIHByZWRpY3RlZFBvcyA9IHtcbiAgICAgICAgICB4OiBmcm9tLnggKyB2ZWNbMF0sXG4gICAgICAgICAgeTogZnJvbS55ICsgdmVjWzFdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XG4gICAgICAgICAgeDogZnJvbS54IC0gdmVjWzBdLFxuICAgICAgICAgIHk6IGZyb20ueSAtIHZlY1sxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdG9JZHggPSBmb3J3YXJkID8gaWR4ICsgMSA6IGlkeCAtIDE7XG4gICAgICB0byA9IHBvaW50c1t0b0lkeF07XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgIHdoaWxlICh0byAmJiAoZm91bmQgPSBtYXRjaCh0bywgcHJlZGljdGVkUG9zKSkgIT09IHRydWUgJiYgTWF0aC5hYnModG8ueSAtIGZyb20ueSkgPCB2ZWNbMV0pIHtcbiAgICAgICAgdG9JZHggPSBmb3J3YXJkID8gdG9JZHggKyAxIDogdG9JZHggLSAxO1xuICAgICAgICB0byA9IHBvaW50c1t0b0lkeF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZm91bmQgPyB0b0lkeCA6IG51bGw7XG4gICAgfVxuICAgIGZvciAoaXRlcmF0aW9uID0gMDsgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9uczsgaXRlcmF0aW9uKyspIHtcbiAgICAgIC8vIHJhbmRvbWx5IHNlbGVjdCBwb2ludCB0byBzdGFydCB3aXRoXG4gICAgICBjZW50ZXJQb3MgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb2ludHMubGVuZ3RoKTtcblxuICAgICAgLy8gdHJhY2UgZm9yd2FyZFxuICAgICAgdG9wID0gW107XG4gICAgICBjdXJyZW50UG9zID0gY2VudGVyUG9zO1xuICAgICAgdG9wLnB1c2gocG9pbnRzW2N1cnJlbnRQb3NdKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgd2hpbGUgKChjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgdHJ1ZSkpICE9PSBudWxsKSB7XG4gICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICB9XG4gICAgICBpZiAoY2VudGVyUG9zID4gMCkge1xuICAgICAgICBjdXJyZW50UG9zID0gY2VudGVyUG9zO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgd2hpbGUgKChjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgZmFsc2UpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b3AubGVuZ3RoID4gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSB0b3A7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgRElMQVRFID0gMTtcbnZhciBFUk9ERSA9IDI7XG5mdW5jdGlvbiBkaWxhdGUoaW5JbWFnZVdyYXBwZXIsIG91dEltYWdlV3JhcHBlcikge1xuICB2YXIgdjtcbiAgdmFyIHU7XG4gIHZhciBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XG4gIHZhciBvdXRJbWFnZURhdGEgPSBvdXRJbWFnZVdyYXBwZXIuZGF0YTtcbiAgdmFyIGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgdmFyIHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xuICB2YXIgc3VtO1xuICB2YXIgeVN0YXJ0MTtcbiAgdmFyIHlTdGFydDI7XG4gIHZhciB4U3RhcnQxO1xuICB2YXIgeFN0YXJ0MjtcbiAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgIGZvciAodSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xuICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xuICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xuICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xuICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xuICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXSArIGluSW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA+IDAgPyAxIDogMDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcbiAgdmFyIHY7XG4gIHZhciB1O1xuICB2YXIgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xuICB2YXIgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGE7XG4gIHZhciBoZWlnaHQgPSBpbkltYWdlV3JhcHBlci5zaXplLnk7XG4gIHZhciB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgdmFyIHN1bTtcbiAgdmFyIHlTdGFydDE7XG4gIHZhciB5U3RhcnQyO1xuICB2YXIgeFN0YXJ0MTtcbiAgdmFyIHhTdGFydDI7XG4gIGZvciAodiA9IDE7IHYgPCBoZWlnaHQgLSAxOyB2KyspIHtcbiAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml0gKyBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0Ml07XG4gICAgICBvdXRJbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPSBzdW0gPT09IDUgPyAxIDogMDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YnRyYWN0KGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xuICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJlc3VsdEltYWdlV3JhcHBlciA9IGFJbWFnZVdyYXBwZXI7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGFJbWFnZVdyYXBwZXIuZGF0YS5sZW5ndGg7XG4gIHZhciBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICB2YXIgYkltYWdlRGF0YSA9IGJJbWFnZVdyYXBwZXIuZGF0YTtcbiAgdmFyIGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgY0ltYWdlRGF0YVtsZW5ndGhdID0gYUltYWdlRGF0YVtsZW5ndGhdIC0gYkltYWdlRGF0YVtsZW5ndGhdO1xuICB9XG59XG5mdW5jdGlvbiBiaXR3aXNlT3IoYUltYWdlV3JhcHBlciwgYkltYWdlV3JhcHBlciwgcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYUltYWdlV3JhcHBlci5kYXRhLmxlbmd0aDtcbiAgdmFyIGFJbWFnZURhdGEgPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gIHZhciBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xuICB2YXIgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gfHwgYkltYWdlRGF0YVtsZW5ndGhdO1xuICB9XG59XG5mdW5jdGlvbiBjb3VudE5vblplcm8oaW1hZ2VXcmFwcGVyKSB7XG4gIHZhciBsZW5ndGggPSBpbWFnZVdyYXBwZXIuZGF0YS5sZW5ndGg7XG4gIHZhciBkYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gIHZhciBzdW0gPSAwO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBzdW0gKz0gZGF0YVtsZW5ndGhdO1xuICB9XG4gIHJldHVybiBzdW07XG59XG5mdW5jdGlvbiB0b3BHZW5lcmljKGxpc3QsIHRvcCwgc2NvcmVGdW5jKSB7XG4gIHZhciBpO1xuICB2YXIgbWluSWR4ID0gMDtcbiAgdmFyIG1pbiA9IDA7XG4gIHZhciBxdWV1ZSA9IFtdO1xuICB2YXIgc2NvcmU7XG4gIHZhciBoaXQ7XG4gIHZhciBwb3M7XG4gIGZvciAoaSA9IDA7IGkgPCB0b3A7IGkrKykge1xuICAgIHF1ZXVlW2ldID0ge1xuICAgICAgc2NvcmU6IDAsXG4gICAgICBpdGVtOiBudWxsXG4gICAgfTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHNjb3JlID0gc2NvcmVGdW5jLmFwcGx5KHRoaXMsIFtsaXN0W2ldXSk7XG4gICAgaWYgKHNjb3JlID4gbWluKSB7XG4gICAgICBoaXQgPSBxdWV1ZVttaW5JZHhdO1xuICAgICAgaGl0LnNjb3JlID0gc2NvcmU7XG4gICAgICBoaXQuaXRlbSA9IGxpc3RbaV07XG4gICAgICBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZm9yIChwb3MgPSAwOyBwb3MgPCB0b3A7IHBvcysrKSB7XG4gICAgICAgIGlmIChxdWV1ZVtwb3NdLnNjb3JlIDwgbWluKSB7XG4gICAgICAgICAgbWluID0gcXVldWVbcG9zXS5zY29yZTtcbiAgICAgICAgICBtaW5JZHggPSBwb3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuZnVuY3Rpb24gZ3JheUFycmF5RnJvbUltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgY3R4LCBhcnJheSkge1xuICBjdHguZHJhd0ltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KTtcbiAgdmFyIGN0eERhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKG9mZnNldFgsIDAsIGh0bWxJbWFnZS53aWR0aCwgaHRtbEltYWdlLmhlaWdodCkuZGF0YTtcbiAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufVxuZnVuY3Rpb24gZ3JheUFycmF5RnJvbUNvbnRleHQoY3R4LCBzaXplLCBvZmZzZXQsIGFycmF5KSB7XG4gIHZhciBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXQueCwgb2Zmc2V0LnksIHNpemUueCwgc2l6ZS55KS5kYXRhO1xuICBjb21wdXRlR3JheShjdHhEYXRhLCBhcnJheSk7XG59XG5mdW5jdGlvbiBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGNhbnZhc0RhdGEsIHNpemUsIG91dEFycmF5KSB7XG4gIHZhciB0b3BSb3dJZHggPSAwO1xuICB2YXIgYm90dG9tUm93SWR4ID0gc2l6ZS54O1xuICB2YXIgZW5kSWR4ID0gTWF0aC5mbG9vcihjYW52YXNEYXRhLmxlbmd0aCAvIDQpO1xuICB2YXIgb3V0V2lkdGggPSBzaXplLnggLyAyO1xuICB2YXIgb3V0SW1nSWR4ID0gMDtcbiAgdmFyIGluV2lkdGggPSBzaXplLng7XG4gIHZhciBpO1xuICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG91dFdpZHRoOyBpKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgb3V0QXJyYXlbb3V0SW1nSWR4XSA9ICgwLjI5OSAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDBdICsgMC41ODcgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAxXSArIDAuMTE0ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMl0gKyAoMC4yOTkgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAwXSArIDAuNTg3ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMV0gKyAwLjExNCAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDJdKSArICgwLjI5OSAqIGNhbnZhc0RhdGFbYm90dG9tUm93SWR4ICogNCArIDBdICsgMC41ODcgKiBjYW52YXNEYXRhW2JvdHRvbVJvd0lkeCAqIDQgKyAxXSArIDAuMTE0ICogY2FudmFzRGF0YVtib3R0b21Sb3dJZHggKiA0ICsgMl0pICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMF0gKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDFdICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAyXSkpIC8gNDtcbiAgICAgIG91dEltZ0lkeCsrO1xuICAgICAgdG9wUm93SWR4ICs9IDI7XG4gICAgICBib3R0b21Sb3dJZHggKz0gMjtcbiAgICB9XG4gICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XG4gICAgYm90dG9tUm93SWR4ICs9IGluV2lkdGg7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVHcmF5KGltYWdlRGF0YSwgb3V0QXJyYXksIGNvbmZpZykge1xuICB2YXIgbCA9IGltYWdlRGF0YS5sZW5ndGggLyA0IHwgMDtcbiAgdmFyIHNpbmdsZUNoYW5uZWwgPSBjb25maWcgJiYgY29uZmlnLnNpbmdsZUNoYW5uZWwgPT09IHRydWU7XG4gIGlmIChzaW5nbGVDaGFubmVsKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgb3V0QXJyYXlbaV0gPSBpbWFnZURhdGFbaSAqIDQgKyAwXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGw7IF9pKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgb3V0QXJyYXlbX2ldID0gMC4yOTkgKiBpbWFnZURhdGFbX2kgKiA0ICsgMF0gKyAwLjU4NyAqIGltYWdlRGF0YVtfaSAqIDQgKyAxXSArIDAuMTE0ICogaW1hZ2VEYXRhW19pICogNCArIDJdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbG9hZEltYWdlQXJyYXkoc3JjLCBjYWxsYmFjaykge1xuICB2YXIgY2FudmFzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICBpbWcuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBjb25zb2xlLndhcm4oJyogbG9hZEltYWdlQXJyYXkgZ2V0Q29udGV4dCAyZCcpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xuICAgIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCk7XG4gICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICB2YXIgX2N0eCRnZXRJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSxcbiAgICAgIGRhdGEgPSBfY3R4JGdldEltYWdlRGF0YS5kYXRhO1xuICAgIGNvbXB1dGVHcmF5KGRhdGEsIGFycmF5KTtcbiAgICB0aGlzLmNhbGxiYWNrKGFycmF5LCB7XG4gICAgICB4OiB0aGlzLndpZHRoLFxuICAgICAgeTogdGhpcy5oZWlnaHRcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgaW1nLnNyYyA9IHNyYztcbn1cblxuLyoqXG4gKiBAcGFyYW0gaW5JbWcge0ltYWdlV3JhcHBlcn0gaW5wdXQgaW1hZ2UgdG8gYmUgc2FtcGxlZFxuICogQHBhcmFtIG91dEltZyB7SW1hZ2VXcmFwcGVyfSB0byBiZSBzdG9yZWQgaW5cbiAqL1xuZnVuY3Rpb24gaGFsZlNhbXBsZShpbkltZ1dyYXBwZXIsIG91dEltZ1dyYXBwZXIpIHtcbiAgdmFyIGluSW1nID0gaW5JbWdXcmFwcGVyLmRhdGE7XG4gIHZhciBpbldpZHRoID0gaW5JbWdXcmFwcGVyLnNpemUueDtcbiAgdmFyIG91dEltZyA9IG91dEltZ1dyYXBwZXIuZGF0YTtcbiAgdmFyIHRvcFJvd0lkeCA9IDA7XG4gIHZhciBib3R0b21Sb3dJZHggPSBpbldpZHRoO1xuICB2YXIgZW5kSWR4ID0gaW5JbWcubGVuZ3RoO1xuICB2YXIgb3V0V2lkdGggPSBpbldpZHRoIC8gMjtcbiAgdmFyIG91dEltZ0lkeCA9IDA7XG4gIHdoaWxlIChib3R0b21Sb3dJZHggPCBlbmRJZHgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dFdpZHRoOyBpKyspIHtcbiAgICAgIG91dEltZ1tvdXRJbWdJZHhdID0gTWF0aC5mbG9vcigoaW5JbWdbdG9wUm93SWR4XSArIGluSW1nW3RvcFJvd0lkeCArIDFdICsgaW5JbWdbYm90dG9tUm93SWR4XSArIGluSW1nW2JvdHRvbVJvd0lkeCArIDFdKSAvIDQpO1xuICAgICAgb3V0SW1nSWR4Kys7XG4gICAgICB0b3BSb3dJZHggKz0gMjtcbiAgICAgIGJvdHRvbVJvd0lkeCArPSAyO1xuICAgIH1cbiAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcbiAgICBib3R0b21Sb3dJZHggKz0gaW5XaWR0aDtcbiAgfVxufVxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIHJnYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogWzAsIDAsIDBdO1xuICB2YXIgaCA9IGhzdlswXTtcbiAgdmFyIHMgPSBoc3ZbMV07XG4gIHZhciB2ID0gaHN2WzJdO1xuICB2YXIgYyA9IHYgKiBzO1xuICB2YXIgeCA9IGMgKiAoMSAtIE1hdGguYWJzKGggLyA2MCAlIDIgLSAxKSk7XG4gIHZhciBtID0gdiAtIGM7XG4gIHZhciByID0gMDtcbiAgdmFyIGcgPSAwO1xuICB2YXIgYiA9IDA7XG4gIGlmIChoIDwgNjApIHtcbiAgICByID0gYztcbiAgICBnID0geDtcbiAgfSBlbHNlIGlmIChoIDwgMTIwKSB7XG4gICAgciA9IHg7XG4gICAgZyA9IGM7XG4gIH0gZWxzZSBpZiAoaCA8IDE4MCkge1xuICAgIGcgPSBjO1xuICAgIGIgPSB4O1xuICB9IGVsc2UgaWYgKGggPCAyNDApIHtcbiAgICBnID0geDtcbiAgICBiID0gYztcbiAgfSBlbHNlIGlmIChoIDwgMzAwKSB7XG4gICAgciA9IHg7XG4gICAgYiA9IGM7XG4gIH0gZWxzZSBpZiAoaCA8IDM2MCkge1xuICAgIHIgPSBjO1xuICAgIGIgPSB4O1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICByZ2JbMF0gPSAociArIG0pICogMjU1IHwgMDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIHJnYlsxXSA9IChnICsgbSkgKiAyNTUgfCAwO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgcmdiWzJdID0gKGIgKyBtKSAqIDI1NSB8IDA7XG4gIHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiBfY29tcHV0ZURpdmlzb3JzKG4pIHtcbiAgdmFyIGxhcmdlRGl2aXNvcnMgPSBbXTtcbiAgdmFyIGRpdmlzb3JzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgTWF0aC5zcXJ0KG4pICsgMTsgaSsrKSB7XG4gICAgaWYgKG4gJSBpID09PSAwKSB7XG4gICAgICBkaXZpc29ycy5wdXNoKGkpO1xuICAgICAgaWYgKGkgIT09IG4gLyBpKSB7XG4gICAgICAgIGxhcmdlRGl2aXNvcnMudW5zaGlmdChNYXRoLmZsb29yKG4gLyBpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkaXZpc29ycy5jb25jYXQobGFyZ2VEaXZpc29ycyk7XG59XG5mdW5jdGlvbiBfY29tcHV0ZUludGVyc2VjdGlvbihhcnIxLCBhcnIyKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGogPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChpIDwgYXJyMS5sZW5ndGggJiYgaiA8IGFycjIubGVuZ3RoKSB7XG4gICAgaWYgKGFycjFbaV0gPT09IGFycjJbal0pIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycjFbaV0pO1xuICAgICAgaSsrO1xuICAgICAgaisrO1xuICAgIH0gZWxzZSBpZiAoYXJyMVtpXSA+IGFycjJbal0pIHtcbiAgICAgIGorKztcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUGF0Y2hTaXplKHBhdGNoU2l6ZSwgaW1nU2l6ZSkge1xuICB2YXIgZGl2aXNvcnNYID0gX2NvbXB1dGVEaXZpc29ycyhpbWdTaXplLngpO1xuICB2YXIgZGl2aXNvcnNZID0gX2NvbXB1dGVEaXZpc29ycyhpbWdTaXplLnkpO1xuICB2YXIgd2lkZVNpZGUgPSBNYXRoLm1heChpbWdTaXplLngsIGltZ1NpemUueSk7XG4gIHZhciBjb21tb24gPSBfY29tcHV0ZUludGVyc2VjdGlvbihkaXZpc29yc1gsIGRpdmlzb3JzWSk7XG4gIHZhciBuck9mUGF0Y2hlc0xpc3QgPSBbOCwgMTAsIDE1LCAyMCwgMzIsIDYwLCA4MF07XG4gIHZhciBuck9mUGF0Y2hlc01hcCA9IHtcbiAgICAneC1zbWFsbCc6IDUsXG4gICAgc21hbGw6IDQsXG4gICAgbWVkaXVtOiAzLFxuICAgIGxhcmdlOiAyLFxuICAgICd4LWxhcmdlJzogMVxuICB9O1xuICB2YXIgbnJPZlBhdGNoZXNJZHggPSBuck9mUGF0Y2hlc01hcFtwYXRjaFNpemVdIHx8IG5yT2ZQYXRjaGVzTWFwLm1lZGl1bTtcbiAgdmFyIG5yT2ZQYXRjaGVzID0gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XTtcbiAgdmFyIGRlc2lyZWRQYXRjaFNpemUgPSBNYXRoLmZsb29yKHdpZGVTaWRlIC8gbnJPZlBhdGNoZXMpO1xuICB2YXIgb3B0aW1hbFBhdGNoU2l6ZTtcbiAgZnVuY3Rpb24gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKGRpdmlzb3JzKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBmb3VuZCA9IGRpdmlzb3JzW01hdGguZmxvb3IoZGl2aXNvcnMubGVuZ3RoIC8gMildO1xuICAgIHdoaWxlIChpIDwgZGl2aXNvcnMubGVuZ3RoIC0gMSAmJiBkaXZpc29yc1tpXSA8IGRlc2lyZWRQYXRjaFNpemUpIHtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoZGl2aXNvcnNbaV0gLSBkZXNpcmVkUGF0Y2hTaXplKSA+IE1hdGguYWJzKGRpdmlzb3JzW2kgLSAxXSAtIGRlc2lyZWRQYXRjaFNpemUpKSB7XG4gICAgICAgIGZvdW5kID0gZGl2aXNvcnNbaSAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlc2lyZWRQYXRjaFNpemUgLyBmb3VuZCA8IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeCArIDFdIC8gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XSAmJiBkZXNpcmVkUGF0Y2hTaXplIC8gZm91bmQgPiBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHggLSAxXSAvIG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGZvdW5kLFxuICAgICAgICB5OiBmb3VuZFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhjb21tb24pO1xuICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICBvcHRpbWFsUGF0Y2hTaXplID0gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKF9jb21wdXRlRGl2aXNvcnMod2lkZVNpZGUpKTtcbiAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoX2NvbXB1dGVEaXZpc29ycyhkZXNpcmVkUGF0Y2hTaXplICogbnJPZlBhdGNoZXMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGltYWxQYXRjaFNpemU7XG59XG5mdW5jdGlvbiBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IHtcbiAgICB2YWx1ZTogcGFyc2VGbG9hdCh2YWx1ZSksXG4gICAgdW5pdDogdmFsdWUuaW5kZXhPZignJScpID09PSB2YWx1ZS5sZW5ndGggLSAxID8gJyUnIDogJyUnXG4gIH07XG4gIHJldHVybiBkaW1lbnNpb247XG59XG52YXIgX2RpbWVuc2lvbnNDb252ZXJ0ZXJzID0ge1xuICB0b3A6IGZ1bmN0aW9uIHRvcChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC5oZWlnaHQgKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xuICB9LFxuICByaWdodDogZnVuY3Rpb24gcmlnaHQoZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggLSBjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgfSxcbiAgYm90dG9tOiBmdW5jdGlvbiBib3R0b20oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0IC0gY29udGV4dC5oZWlnaHQgKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xuICB9LFxuICBsZWZ0OiBmdW5jdGlvbiBsZWZ0KGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgfVxufTtcbmZ1bmN0aW9uIGNvbXB1dGVJbWFnZUFyZWEoaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHQsIGFyZWEpIHtcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgd2lkdGg6IGlucHV0V2lkdGgsXG4gICAgaGVpZ2h0OiBpbnB1dEhlaWdodFxuICB9O1xuICB2YXIgcGFyc2VkQXJlYSA9IE9iamVjdC5rZXlzKGFyZWEpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmVhW2tleV07XG4gICAgdmFyIHBhcnNlZCA9IF9wYXJzZUNTU0RpbWVuc2lvblZhbHVlcyh2YWx1ZSk7XG4gICAgdmFyIGNhbGN1bGF0ZWQgPSBfZGltZW5zaW9uc0NvbnZlcnRlcnNba2V5XShwYXJzZWQsIGNvbnRleHQpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmVzdWx0W2tleV0gPSBjYWxjdWxhdGVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIHtcbiAgICBzeDogcGFyc2VkQXJlYS5sZWZ0LFxuICAgIHN5OiBwYXJzZWRBcmVhLnRvcCxcbiAgICBzdzogcGFyc2VkQXJlYS5yaWdodCAtIHBhcnNlZEFyZWEubGVmdCxcbiAgICBzaDogcGFyc2VkQXJlYS5ib3R0b20gLSBwYXJzZWRBcmVhLnRvcFxuICB9O1xufVxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cyksIF90eXBlb2Yobyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc3VwZXJQcm9wQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTM4KTtcbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgfVxuICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gVE9ETzogWFlQb3NpdGlvbiBzaG91bGQgYmUgYW4gWFlPYmplY3QsIGJ1dCB0aGF0IGJyZWFrcyBYWURlZmluaXRpb24sIHdoaWNoIGJyZWFrcyBkcmF3UGF0aCgpIGJlbG93LlxuXG4vLyBYWURlZmluaXRpb24gdGVsbHMgdXMgd2hpY2ggY29tcG9uZW50IG9mIGEgZ2l2ZW4gYXJyYXkgb3Igb2JqZWN0IGlzIHRoZSBcIlhcIiBhbmQgd2hpY2ggaXMgdGhlIFwiWVwiLlxuLy8gVXN1YWxseSB0aGlzIGlzIDAgZm9yIFggYW5kIDEgZm9yIFksIGJ1dCBtaWdodCBiZSB1c2VkIGFzICd4JyBmb3IgeCBhbmQgJ3knIGZvciBZLlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9ICh7XG4gIGRyYXdSZWN0OiBmdW5jdGlvbiBkcmF3UmVjdChwb3MsIHNpemUsIGN0eCwgc3R5bGUpIHtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aCB8fCAxO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguc3Ryb2tlUmVjdChwb3MueCwgcG9zLnksIHNpemUueCwgc2l6ZS55KTtcbiAgfSxcbiAgZHJhd1BhdGg6IGZ1bmN0aW9uIGRyYXdQYXRoKHBhdGgsIGRlZiwgY3R4LCBzdHlsZSkge1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHBhdGhbMF1bZGVmLnhdLCBwYXRoWzBdW2RlZi55XSk7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICBjdHgubGluZVRvKHBhdGhbal1bZGVmLnhdLCBwYXRoW2pdW2RlZi55XSk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH0sXG4gIGRyYXdJbWFnZTogZnVuY3Rpb24gZHJhd0ltYWdlKGltYWdlRGF0YSwgc2l6ZSwgY3R4KSB7XG4gICAgdmFyIGNhbnZhc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUueCwgc2l6ZS55KTtcbiAgICB2YXIgZGF0YSA9IGNhbnZhc0RhdGEuZGF0YTtcbiAgICB2YXIgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoO1xuICAgIHZhciBpbWFnZURhdGFQb3MgPSBpbWFnZURhdGEubGVuZ3RoO1xuICAgIGlmIChjYW52YXNEYXRhUG9zIC8gaW1hZ2VEYXRhUG9zICE9PSA0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlIChpbWFnZURhdGFQb3MtLSkge1xuICAgICAgdmFyIHZhbHVlID0gaW1hZ2VEYXRhW2ltYWdlRGF0YVBvc107XG4gICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSAyNTU7XG4gICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgfVxuICAgIGN0eC5wdXRJbWFnZURhdGEoY2FudmFzRGF0YSwgMCwgMCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlTWVyZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKSxcbiAgY3JlYXRlQXNzaWduZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNSk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uIChvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZyZWVHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xubW9kdWxlLmV4cG9ydHMgPSByb290O1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xudmFyIFRyYWNlciA9IHtcbiAgc2VhcmNoRGlyZWN0aW9uczogW1swLCAxXSwgWzEsIDFdLCBbMSwgMF0sIFsxLCAtMV0sIFswLCAtMV0sIFstMSwgLTFdLCBbLTEsIDBdLCBbLTEsIDFdXSxcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcbiAgICB2YXIgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgdmFyIGxhYmVsRGF0YSA9IGxhYmVsV3JhcHBlci5kYXRhO1xuICAgIHZhciBzZWFyY2hEaXJlY3Rpb25zID0gdGhpcy5zZWFyY2hEaXJlY3Rpb25zO1xuICAgIHZhciB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgdmFyIHBvcztcbiAgICBmdW5jdGlvbiBfdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHk7XG4gICAgICB2YXIgeDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWFyY2hEaXJlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHkgPSBjdXJyZW50LmN5ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMF07XG4gICAgICAgIHggPSBjdXJyZW50LmN4ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMV07XG4gICAgICAgIHBvcyA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgIGlmIChpbWFnZURhdGFbcG9zXSA9PT0gY29sb3IgJiYgKGxhYmVsRGF0YVtwb3NdID09PSAwIHx8IGxhYmVsRGF0YVtwb3NdID09PSBsYWJlbCkpIHtcbiAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGxhYmVsO1xuICAgICAgICAgIGN1cnJlbnQuY3kgPSB5O1xuICAgICAgICAgIGN1cnJlbnQuY3ggPSB4O1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xuICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gZWRnZWxhYmVsO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgMSkgJSA4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2ZXJ0ZXgyRCh4LCB5LCBkaXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpcjogZGlyLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCkge1xuICAgICAgdmFyIEZ2ID0gbnVsbDtcbiAgICAgIHZhciBDdjtcbiAgICAgIHZhciBQO1xuICAgICAgdmFyIGxkaXI7XG4gICAgICB2YXIgY3VycmVudCA9IHtcbiAgICAgICAgY3g6IHN4LFxuICAgICAgICBjeTogc3ksXG4gICAgICAgIGRpcjogMFxuICAgICAgfTtcbiAgICAgIGlmIChfdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpKSB7XG4gICAgICAgIEZ2ID0gdmVydGV4MkQoc3gsIHN5LCBjdXJyZW50LmRpcik7XG4gICAgICAgIEN2ID0gRnY7XG4gICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICBQLnByZXYgPSBDdjtcbiAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgIEN2ID0gUDtcbiAgICAgICAgdmFyIHRvdGFsUGl4ZWxDb3VudCA9IGltYWdlV3JhcHBlci5zaXplLnggKiBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgICAgICB2YXIgcGl4ZWxDb3VudGVyID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgNikgJSA4O1xuICAgICAgICAgIF90cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCk7XG4gICAgICAgICAgaWYgKGxkaXIgIT09IGN1cnJlbnQuZGlyKSB7XG4gICAgICAgICAgICBDdi5kaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcbiAgICAgICAgICAgIFAucHJldiA9IEN2O1xuICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICBQLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgQ3YgPSBQO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBDdi5kaXIgPSBsZGlyO1xuICAgICAgICAgICAgQ3YueCA9IGN1cnJlbnQuY3g7XG4gICAgICAgICAgICBDdi55ID0gY3VycmVudC5jeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICB9IHdoaWxlICgoY3VycmVudC5jeCAhPT0gc3ggfHwgY3VycmVudC5jeSAhPT0gc3kpICYmICsrcGl4ZWxDb3VudGVyIDwgdG90YWxQaXhlbENvdW50KTtcbiAgICAgICAgRnYucHJldiA9IEN2LnByZXY7XG4gICAgICAgIEN2LnByZXYubmV4dCA9IEZ2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIEZ2O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2U6IGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgIHJldHVybiBfdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xuICAgICAgfSxcbiAgICAgIGNvbnRvdXJUcmFjaW5nOiBmdW5jdGlvbiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgIHJldHVybiBfY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoVHJhY2VyKTtcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyksXG4gIGdldFJhd1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oODMpLFxuICBvYmplY3RUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSA/IGdldFJhd1RhZyh2YWx1ZSkgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGdsX21hdHJpeF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBnbF9tYXRyaXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihnbF9tYXRyaXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9pbWFnZV93cmFwcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2N2X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2FycmF5X2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2ltYWdlX2RlYnVnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmFzdGVyaXplcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYWNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NrZWxldG9uaXplcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XG5cblxuXG5cblxuXG5cblxuZ2xfbWF0cml4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnbE1hdHJpeFwiXS5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO1xudmFyIF9jb25maWc7XG52YXIgX2N1cnJlbnRJbWFnZVdyYXBwZXI7XG52YXIgX3NrZWxJbWFnZVdyYXBwZXI7XG52YXIgX3N1YkltYWdlV3JhcHBlcjtcbnZhciBfbGFiZWxJbWFnZVdyYXBwZXI7XG52YXIgX3BhdGNoR3JpZDtcbnZhciBfcGF0Y2hMYWJlbEdyaWQ7XG52YXIgX2ltYWdlVG9QYXRjaEdyaWQ7XG52YXIgX2JpbmFyeUltYWdlV3JhcHBlcjtcbnZhciBfcGF0Y2hTaXplO1xudmFyIF9jYW52YXNDb250YWluZXIgPSB7XG4gIGN0eDoge1xuICAgIGJpbmFyeTogbnVsbFxuICB9LFxuICBkb206IHtcbiAgICBiaW5hcnk6IG51bGxcbiAgfVxufTtcbnZhciBfbnVtUGF0Y2hlcyA9IHtcbiAgeDogMCxcbiAgeTogMFxufTtcbnZhciBfaW5wdXRJbWFnZVdyYXBwZXI7XG52YXIgX3NrZWxldG9uaXplcjtcbmZ1bmN0aW9uIGluaXRCdWZmZXJzKCkge1xuICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgX2N1cnJlbnRJbWFnZVdyYXBwZXIgPSBuZXcgX2NvbW1vbl9pbWFnZV93cmFwcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0oe1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgIHg6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnggLyAyIHwgMCxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICB5OiBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gMiB8IDBcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IF9pbnB1dEltYWdlV3JhcHBlcjtcbiAgfVxuICBfcGF0Y2hTaXplID0gT2JqZWN0KF9jb21tb25fY3ZfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImNhbGN1bGF0ZVBhdGNoU2l6ZVwiXSkoX2NvbmZpZy5wYXRjaFNpemUsIF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIF9udW1QYXRjaGVzLnggPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfcGF0Y2hTaXplLnggfCAwO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICBfbnVtUGF0Y2hlcy55ID0gX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3BhdGNoU2l6ZS55IHwgMDtcbiAgX2JpbmFyeUltYWdlV3JhcHBlciA9IG5ldyBfY29tbW9uX2ltYWdlX3dyYXBwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXShfY3VycmVudEltYWdlV3JhcHBlci5zaXplLCB1bmRlZmluZWQsIFVpbnQ4QXJyYXksIGZhbHNlKTtcbiAgX2xhYmVsSW1hZ2VXcmFwcGVyID0gbmV3IF9jb21tb25faW1hZ2Vfd3JhcHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKF9wYXRjaFNpemUsIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xuICB2YXIgc2tlbGV0b25JbWFnZURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoNjQgKiAxMDI0KTtcbiAgX3N1YkltYWdlV3JhcHBlciA9IG5ldyBfY29tbW9uX2ltYWdlX3dyYXBwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXShfcGF0Y2hTaXplLCBuZXcgVWludDhBcnJheShza2VsZXRvbkltYWdlRGF0YSwgMCwgX3BhdGNoU2l6ZS54ICogX3BhdGNoU2l6ZS55KSk7XG4gIF9za2VsSW1hZ2VXcmFwcGVyID0gbmV3IF9jb21tb25faW1hZ2Vfd3JhcHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKF9wYXRjaFNpemUsIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkgKiAzLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpLCB1bmRlZmluZWQsIHRydWUpO1xuICBfc2tlbGV0b25pemVyID0gT2JqZWN0KF9za2VsZXRvbml6ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogZ2xvYmFsLCB7XG4gICAgc2l6ZTogX3BhdGNoU2l6ZS54XG4gIH0sIHNrZWxldG9uSW1hZ2VEYXRhKTtcbiAgX2ltYWdlVG9QYXRjaEdyaWQgPSBuZXcgX2NvbW1vbl9pbWFnZV93cmFwcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0oe1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgeDogX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLnggfCAwLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgeTogX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLnkgfCAwXG4gIH0sIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xuICBfcGF0Y2hHcmlkID0gbmV3IF9jb21tb25faW1hZ2Vfd3JhcHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKF9pbWFnZVRvUGF0Y2hHcmlkLnNpemUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgX3BhdGNoTGFiZWxHcmlkID0gbmV3IF9jb21tb25faW1hZ2Vfd3JhcHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKF9pbWFnZVRvUGF0Y2hHcmlkLnNpemUsIHVuZGVmaW5lZCwgSW50MzJBcnJheSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICBpZiAoX2NvbmZpZy51c2VXb3JrZXIgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmNsYXNzTmFtZSA9ICdiaW5hcnlCdWZmZXInO1xuICBpZiAoZmFsc2UpIHt9XG4gIHZhciB3aWxsUmVhZEZyZXF1ZW50bHkgPSAhIV9jb25maWcud2lsbFJlYWRGcmVxdWVudGx5O1xuICBjb25zb2xlLndhcm4oJyogaW5pdENhbnZhcyB3aWxsUmVhZEZyZXF1ZW50bHknLCB3aWxsUmVhZEZyZXF1ZW50bHksIF9jb25maWcpO1xuICBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnkgPSBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgd2lsbFJlYWRGcmVxdWVudGx5OiB3aWxsUmVhZEZyZXF1ZW50bHlcbiAgfSk7XG4gIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS53aWR0aCA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuaGVpZ2h0ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJvdW5kaW5nIGJveCB3aGljaCBlbmNsb3NlcyBhbGwgdGhlIGdpdmVuIHBhdGNoZXNcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG1pbmltYWwgYm91bmRpbmcgYm94XG4gKi9cbmZ1bmN0aW9uIGJveEZyb21QYXRjaGVzKHBhdGNoZXMpIHtcbiAgdmFyIG92ZXJBdmc7XG4gIHZhciBpO1xuICB2YXIgajtcbiAgdmFyIHBhdGNoO1xuICB2YXIgdHJhbnNNYXQ7XG4gIHZhciBtaW54ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XG4gIHZhciBtaW55ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XG4gIHZhciBtYXh4ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICB2YXIgbWF4eSA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgdmFyIGJveDtcbiAgdmFyIHNjYWxlO1xuXG4gIC8vIGRyYXcgYWxsIHBhdGNoZXMgd2hpY2ggYXJlIHRvIGJlIHRha2VuIGludG8gY29uc2lkZXJhdGlvblxuICBvdmVyQXZnID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgb3ZlckF2ZyArPSBwYXRjaC5yYWQ7XG4gICAgaWYgKGZhbHNlKSB7fVxuICB9XG4gIG92ZXJBdmcgLz0gcGF0Y2hlcy5sZW5ndGg7XG4gIG92ZXJBdmcgPSAob3ZlckF2ZyAqIDE4MCAvIE1hdGguUEkgKyA5MCkgJSAxODAgLSA5MDtcbiAgaWYgKG92ZXJBdmcgPCAwKSB7XG4gICAgb3ZlckF2ZyArPSAxODA7XG4gIH1cbiAgb3ZlckF2ZyA9ICgxODAgLSBvdmVyQXZnKSAqIE1hdGguUEkgLyAxODA7XG4gIHRyYW5zTWF0ID0gZ2xfbWF0cml4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJtYXQyXCJdLmNvcHkoZ2xfbWF0cml4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJtYXQyXCJdLmNyZWF0ZSgpLCBbTWF0aC5jb3Mob3ZlckF2ZyksIE1hdGguc2luKG92ZXJBdmcpLCAtTWF0aC5zaW4ob3ZlckF2ZyksIE1hdGguY29zKG92ZXJBdmcpXSk7XG5cbiAgLy8gaXRlcmF0ZSBvdmVyIHBhdGNoZXMgYW5kIHJvdGF0ZSBieSBhbmdsZVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICBnbF9tYXRyaXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInZlYzJcIl0udHJhbnNmb3JtTWF0MihwYXRjaC5ib3hbal0sIHBhdGNoLmJveFtqXSwgdHJhbnNNYXQpO1xuICAgIH1cbiAgICBpZiAoZmFsc2UpIHt9XG4gIH1cblxuICAvLyBmaW5kIGJvdW5kaW5nIGJveFxuICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICBpZiAocGF0Y2guYm94W2pdWzBdIDwgbWlueCkge1xuICAgICAgICBtaW54ID0gcGF0Y2guYm94W2pdWzBdO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGNoLmJveFtqXVswXSA+IG1heHgpIHtcbiAgICAgICAgbWF4eCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPCBtaW55KSB7XG4gICAgICAgIG1pbnkgPSBwYXRjaC5ib3hbal1bMV07XG4gICAgICB9XG4gICAgICBpZiAocGF0Y2guYm94W2pdWzFdID4gbWF4eSkge1xuICAgICAgICBtYXh5ID0gcGF0Y2guYm94W2pdWzFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBib3ggPSBbW21pbngsIG1pbnldLCBbbWF4eCwgbWlueV0sIFttYXh4LCBtYXh5XSwgW21pbngsIG1heHldXTtcbiAgaWYgKGZhbHNlKSB7fVxuICBzY2FsZSA9IF9jb25maWcuaGFsZlNhbXBsZSA/IDIgOiAxO1xuICAvLyByZXZlcnNlIHJvdGF0aW9uO1xuICB0cmFuc01hdCA9IGdsX21hdHJpeF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wibWF0MlwiXS5pbnZlcnQodHJhbnNNYXQsIHRyYW5zTWF0KTtcbiAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xuICAgIGdsX21hdHJpeF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1widmVjMlwiXS50cmFuc2Zvcm1NYXQyKGJveFtqXSwgYm94W2pdLCB0cmFuc01hdCk7XG4gIH1cbiAgaWYgKGZhbHNlKSB7fVxuICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgZ2xfbWF0cml4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJ2ZWMyXCJdLnNjYWxlKGJveFtqXSwgYm94W2pdLCBzY2FsZSk7XG4gIH1cbiAgcmV0dXJuIGJveDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYmluYXJ5IGltYWdlIG9mIHRoZSBjdXJyZW50IGltYWdlXG4gKi9cbmZ1bmN0aW9uIGJpbmFyaXplSW1hZ2UoKSB7XG4gIE9iamVjdChfY29tbW9uX2N2X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJvdHN1VGhyZXNob2xkXCJdKShfY3VycmVudEltYWdlV3JhcHBlciwgX2JpbmFyeUltYWdlV3JhcHBlcik7XG4gIF9iaW5hcnlJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICBpZiAoZmFsc2UpIHt9XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgaW1hZ2VcbiAqIGV4dHJhY3QgcGF0Y2hlc1xuICovXG5mdW5jdGlvbiBmaW5kUGF0Y2hlcygpIHtcbiAgdmFyIGk7XG4gIHZhciBqO1xuICB2YXIgeDtcbiAgdmFyIHk7XG4gIHZhciBtb21lbnRzO1xuICB2YXIgcGF0Y2hlc0ZvdW5kID0gW107XG4gIHZhciByYXN0ZXJpemVyO1xuICB2YXIgcmFzdGVyUmVzdWx0O1xuICB2YXIgcGF0Y2g7XG4gIGZvciAoaSA9IDA7IGkgPCBfbnVtUGF0Y2hlcy54OyBpKyspIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgX251bVBhdGNoZXMueTsgaisrKSB7XG4gICAgICB4ID0gX3N1YkltYWdlV3JhcHBlci5zaXplLnggKiBpO1xuICAgICAgeSA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55ICogajtcblxuICAgICAgLy8gc2VwZXJhdGUgcGFydHNcbiAgICAgIHNrZWxldG9uaXplKHgsIHkpO1xuXG4gICAgICAvLyBSYXN0ZXJpemUsIGZpbmQgaW5kaXZpZHVhbCBiYXJzXG4gICAgICBfc2tlbEltYWdlV3JhcHBlci56ZXJvQm9yZGVyKCk7XG4gICAgICBfY29tbW9uX2FycmF5X2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaXQoX2xhYmVsSW1hZ2VXcmFwcGVyLmRhdGEsIDApO1xuICAgICAgcmFzdGVyaXplciA9IF9yYXN0ZXJpemVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uY3JlYXRlKF9za2VsSW1hZ2VXcmFwcGVyLCBfbGFiZWxJbWFnZVdyYXBwZXIpO1xuICAgICAgcmFzdGVyUmVzdWx0ID0gcmFzdGVyaXplci5yYXN0ZXJpemUoMCk7XG4gICAgICBpZiAoZmFsc2UpIHt9XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBtb21lbnRzIGZyb20gdGhlIHNrZWxldG9uaXplZCBwYXRjaFxuICAgICAgbW9tZW50cyA9IF9sYWJlbEltYWdlV3JhcHBlci5tb21lbnRzKHJhc3RlclJlc3VsdC5jb3VudCk7XG5cbiAgICAgIC8vIGV4dHJhY3QgZWxpZ2libGUgcGF0Y2hlc1xuICAgICAgcGF0Y2hlc0ZvdW5kID0gcGF0Y2hlc0ZvdW5kLmNvbmNhdChkZXNjcmliZVBhdGNoKG1vbWVudHMsIFtpLCBqXSwgeCwgeSkpO1xuICAgIH1cbiAgfVxuICBpZiAoZmFsc2UpIHt9XG4gIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhvc2UgY29ubmVjdGVkIGFyZWFzIHdoaWNoIGNvbnRhaW4gYXQgbGVhc3QgNiBwYXRjaGVzXG4gKiBhbmQgcmV0dXJucyB0aGVtIG9yZGVyZWQgREVTQyBieSB0aGUgbnVtYmVyIG9mIGNvbnRhaW5lZCBwYXRjaGVzXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4TGFiZWxcbiAqL1xuZnVuY3Rpb24gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCkge1xuICB2YXIgaTtcbiAgdmFyIHN1bTtcbiAgdmFyIGxhYmVsSGlzdCA9IFtdO1xuICB2YXIgdG9wTGFiZWxzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBtYXhMYWJlbDsgaSsrKSB7XG4gICAgbGFiZWxIaXN0LnB1c2goMCk7XG4gIH1cbiAgc3VtID0gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAoc3VtLS0pIHtcbiAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSA+IDApIHtcbiAgICAgIGxhYmVsSGlzdFtfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dIC0gMV0rKztcbiAgICB9XG4gIH1cbiAgbGFiZWxIaXN0ID0gbGFiZWxIaXN0Lm1hcChmdW5jdGlvbiAodmFsLCBpZHgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsOiB2YWwsXG4gICAgICBsYWJlbDogaWR4ICsgMVxuICAgIH07XG4gIH0pO1xuICBsYWJlbEhpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnZhbCAtIGEudmFsO1xuICB9KTtcblxuICAvLyBleHRyYWN0IHRvcCBhcmVhcyB3aXRoIGF0IGxlYXN0IDYgcGF0Y2hlcyBwcmVzZW50XG4gIHRvcExhYmVscyA9IGxhYmVsSGlzdC5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIGVsLnZhbCA+PSA1O1xuICB9KTtcbiAgcmV0dXJuIHRvcExhYmVscztcbn1cblxuLyoqXG4gKlxuICovXG5mdW5jdGlvbiBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCkge1xuICB2YXIgaTtcbiAgdmFyIGo7XG4gIHZhciBzdW07XG4gIHZhciBwYXRjaGVzID0gW107XG4gIHZhciBwYXRjaDtcbiAgdmFyIGJveDtcbiAgdmFyIGJveGVzID0gW107XG4gIHZhciBoc3YgPSBbMCwgMSwgMV07XG4gIHZhciByZ2IgPSBbMCwgMCwgMF07XG4gIGZvciAoaSA9IDA7IGkgPCB0b3BMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgcGF0Y2hlcy5sZW5ndGggPSAwO1xuICAgIHdoaWxlIChzdW0tLSkge1xuICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPT09IHRvcExhYmVsc1tpXS5sYWJlbCkge1xuICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbc3VtXTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYm94ID0gYm94RnJvbVBhdGNoZXMocGF0Y2hlcyk7XG4gICAgaWYgKGJveCkge1xuICAgICAgYm94ZXMucHVzaChib3gpO1xuXG4gICAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgICAgIGlmIChmYWxzZSkge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJveGVzO1xufVxuXG4vKipcbiAqIEZpbmQgc2ltaWxhciBtb21lbnRzICh2aWEgY2x1c3RlcilcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb21lbnRzXG4gKi9cbmZ1bmN0aW9uIHNpbWlsYXJNb21lbnRzKG1vbWVudHMpIHtcbiAgdmFyIGNsdXN0ZXJzID0gT2JqZWN0KF9jb21tb25fY3ZfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImNsdXN0ZXJcIl0pKG1vbWVudHMsIDAuOTApO1xuICB2YXIgdG9wQ2x1c3RlciA9IE9iamVjdChfY29tbW9uX2N2X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJ0b3BHZW5lcmljXCJdKShjbHVzdGVycywgMSwgZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS5nZXRQb2ludHMoKS5sZW5ndGg7XG4gIH0pO1xuICB2YXIgcG9pbnRzID0gW107XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHRvcENsdXN0ZXIubGVuZ3RoID09PSAxKSB7XG4gICAgcG9pbnRzID0gdG9wQ2x1c3RlclswXS5pdGVtLmdldFBvaW50cygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChwb2ludHNbaV0ucG9pbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2tlbGV0b25pemUoeCwgeSkge1xuICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnN1YkltYWdlQXNDb3B5KF9zdWJJbWFnZVdyYXBwZXIsIE9iamVjdChfY29tbW9uX2N2X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJpbWFnZVJlZlwiXSkoeCwgeSkpO1xuICBfc2tlbGV0b25pemVyLnNrZWxldG9uaXplKCk7XG5cbiAgLy8gU2hvdyBza2VsZXRvbiBpZiByZXF1ZXN0ZWRcbiAgaWYgKGZhbHNlKSB7fVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIGFuZCBkZXNjcmliZXMgdGhvc2UgcGF0Y2hlcyB3aGljaCBzZWVtIHRvIGNvbnRhaW4gYSBiYXJjb2RlIHBhdHRlcm5cbiAqIEBwYXJhbSB7QXJyYXl9IG1vbWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaFBvcyxcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVQYXRjaChtb21lbnRzLCBwYXRjaFBvcywgeCwgeSkge1xuICB2YXIgaztcbiAgdmFyIGF2ZztcbiAgdmFyIGVsaWdpYmxlTW9tZW50cyA9IFtdO1xuICB2YXIgbWF0Y2hpbmdNb21lbnRzO1xuICB2YXIgcGF0Y2g7XG4gIHZhciBwYXRjaGVzRm91bmQgPSBbXTtcbiAgdmFyIG1pbkNvbXBvbmVudFdlaWdodCA9IE1hdGguY2VpbChfcGF0Y2hTaXplLnggLyAzKTtcbiAgaWYgKG1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAvLyBvbmx5IGNvbGxlY3QgbW9tZW50cyB3aGljaCdzIGFyZWEgY292ZXJzIGF0IGxlYXN0IG1pbkNvbXBvbmVudFdlaWdodCBwaXhlbHMuXG4gICAgZm9yIChrID0gMDsgayA8IG1vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGlmIChtb21lbnRzW2tdLm0wMCA+IG1pbkNvbXBvbmVudFdlaWdodCkge1xuICAgICAgICBlbGlnaWJsZU1vbWVudHMucHVzaChtb21lbnRzW2tdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBhdCBsZWFzdCAyIG1vbWVudHMgYXJlIGZvdW5kIHdoaWNoIGhhdmUgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0cyBjb3ZlcmVkXG4gICAgaWYgKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgbWF0Y2hpbmdNb21lbnRzID0gc2ltaWxhck1vbWVudHMoZWxpZ2libGVNb21lbnRzKTtcbiAgICAgIGF2ZyA9IDA7XG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIHNpbWlsYXJpdHkgb2YgdGhlIG1vbWVudHNcbiAgICAgIGZvciAoayA9IDA7IGsgPCBtYXRjaGluZ01vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIF9tYXRjaGluZ01vbWVudHMkayRyYSwgX21hdGNoaW5nTW9tZW50cyRrO1xuICAgICAgICBhdmcgKz0gKF9tYXRjaGluZ01vbWVudHMkayRyYSA9IChfbWF0Y2hpbmdNb21lbnRzJGsgPSBtYXRjaGluZ01vbWVudHNba10pID09PSBudWxsIHx8IF9tYXRjaGluZ01vbWVudHMkayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hdGNoaW5nTW9tZW50cyRrLnJhZCkgIT09IG51bGwgJiYgX21hdGNoaW5nTW9tZW50cyRrJHJhICE9PSB2b2lkIDAgPyBfbWF0Y2hpbmdNb21lbnRzJGskcmEgOiAwO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IHR3byBvZiB0aGUgbW9tZW50cyBhcmUgYWxsb3dlZCBub3QgdG8gZml0IGludG8gdGhlIGVxdWF0aW9uXG4gICAgICAvLyBhZGQgdGhlIHBhdGNoIHRvIHRoZSBzZXRcbiAgICAgIGlmIChtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gMSAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID49IGVsaWdpYmxlTW9tZW50cy5sZW5ndGggLyA0ICogMyAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gbW9tZW50cy5sZW5ndGggLyA0KSB7XG4gICAgICAgIGF2ZyAvPSBtYXRjaGluZ01vbWVudHMubGVuZ3RoO1xuICAgICAgICBwYXRjaCA9IHtcbiAgICAgICAgICBpbmRleDogcGF0Y2hQb3NbMV0gKiBfbnVtUGF0Y2hlcy54ICsgcGF0Y2hQb3NbMF0sXG4gICAgICAgICAgcG9zOiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm94OiBbZ2xfbWF0cml4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJ2ZWMyXCJdLmNsb25lKFt4LCB5XSksIGdsX21hdHJpeF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1widmVjMlwiXS5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5XSksIGdsX21hdHJpeF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1widmVjMlwiXS5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSwgZ2xfbWF0cml4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJ2ZWMyXCJdLmNsb25lKFt4LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKV0sXG4gICAgICAgICAgbW9tZW50czogbWF0Y2hpbmdNb21lbnRzLFxuICAgICAgICAgIHJhZDogYXZnLFxuICAgICAgICAgIHZlYzogZ2xfbWF0cml4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJ2ZWMyXCJdLmNsb25lKFtNYXRoLmNvcyhhdmcpLCBNYXRoLnNpbihhdmcpXSlcbiAgICAgICAgfTtcbiAgICAgICAgcGF0Y2hlc0ZvdW5kLnB1c2gocGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0Y2hlc0ZvdW5kO1xufVxuXG4vKipcbiAqIGZpbmRzIHBhdGNoZXMgd2hpY2ggYXJlIGNvbm5lY3RlZCBhbmQgc2hhcmUgdGhlIHNhbWUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaGVzRm91bmRcbiAqL1xuZnVuY3Rpb24gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKSB7XG4gIHZhciBsYWJlbCA9IDA7XG4gIHZhciB0aHJlc2hvbGQgPSAwLjk1O1xuICB2YXIgY3VycklkeCA9IDA7XG4gIHZhciBqO1xuICB2YXIgcGF0Y2g7XG4gIHZhciBoc3YgPSBbMCwgMSwgMV07XG4gIHZhciByZ2IgPSBbMCwgMCwgMF07XG4gIGZ1bmN0aW9uIG5vdFlldFByb2Nlc3NlZCgpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpXSA9PT0gMCAmJiBfcGF0Y2hHcmlkLmRhdGFbaV0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gdHJhY2UoY3VycmVudElkeCkge1xuICAgIHZhciB4O1xuICAgIHZhciB5O1xuICAgIHZhciBjdXJyZW50UGF0Y2g7XG4gICAgdmFyIGlkeDtcbiAgICB2YXIgZGlyO1xuICAgIHZhciBjdXJyZW50ID0ge1xuICAgICAgeDogY3VycmVudElkeCAlIF9wYXRjaExhYmVsR3JpZC5zaXplLngsXG4gICAgICB5OiBjdXJyZW50SWR4IC8gX3BhdGNoTGFiZWxHcmlkLnNpemUueCB8IDBcbiAgICB9O1xuICAgIHZhciBzaW1pbGFyaXR5O1xuICAgIGlmIChjdXJyZW50SWR4IDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoKSB7XG4gICAgICBjdXJyZW50UGF0Y2ggPSBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2N1cnJlbnRJZHhdO1xuICAgICAgLy8gYXNzaWduIGxhYmVsXG4gICAgICBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtjdXJyZW50SWR4XSA9IGxhYmVsO1xuICAgICAgZm9yIChkaXIgPSAwOyBkaXIgPCBfdHJhY2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2VhcmNoRGlyZWN0aW9ucy5sZW5ndGg7IGRpcisrKSB7XG4gICAgICAgIHkgPSBjdXJyZW50LnkgKyBfdHJhY2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzBdO1xuICAgICAgICB4ID0gY3VycmVudC54ICsgX3RyYWNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNlYXJjaERpcmVjdGlvbnNbZGlyXVsxXTtcbiAgICAgICAgaWR4ID0geSAqIF9wYXRjaExhYmVsR3JpZC5zaXplLnggKyB4O1xuXG4gICAgICAgIC8vIGNvbnRpbnVlIGlmIHBhdGNoIGVtcHR5XG4gICAgICAgIGlmIChfcGF0Y2hHcmlkLmRhdGFbaWR4XSA9PT0gMCkge1xuICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgc2ltaWxhcml0eSA9IE1hdGguYWJzKGdsX21hdHJpeF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1widmVjMlwiXS5kb3QoX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtpZHhdLnZlYywgY3VycmVudFBhdGNoLnZlYykpO1xuICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICB0cmFjZShpZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHByZXBhcmUgZm9yIGZpbmRpbmcgdGhlIHJpZ2h0IHBhdGNoZXNcbiAgX2NvbW1vbl9hcnJheV9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbml0KF9wYXRjaEdyaWQuZGF0YSwgMCk7XG4gIF9jb21tb25fYXJyYXlfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5pdChfcGF0Y2hMYWJlbEdyaWQuZGF0YSwgMCk7XG4gIF9jb21tb25fYXJyYXlfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5pdChfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhLCBudWxsKTtcbiAgZm9yIChqID0gMDsgaiA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGorKykge1xuICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2pdO1xuICAgIF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbcGF0Y2guaW5kZXhdID0gcGF0Y2g7XG4gICAgX3BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IDE7XG4gIH1cblxuICAvLyByYXN0ZXJpemUgdGhlIHBhdGNoZXMgZm91bmQgdG8gZGV0ZXJtaW5lIGFyZWFcbiAgX3BhdGNoR3JpZC56ZXJvQm9yZGVyKCk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gIHdoaWxlICgoY3VycklkeCA9IG5vdFlldFByb2Nlc3NlZCgpKSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgIGxhYmVsKys7XG4gICAgdHJhY2UoY3VycklkeCk7XG4gIH1cblxuICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgaWYgKGZhbHNlKSB7fVxuICByZXR1cm4gbGFiZWw7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdChpbnB1dEltYWdlV3JhcHBlciwgY29uZmlnKSB7XG4gICAgX2NvbmZpZyA9IGNvbmZpZztcbiAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcbiAgICBpbml0QnVmZmVycygpO1xuICAgIGluaXRDYW52YXMoKTtcbiAgfSxcbiAgbG9jYXRlOiBmdW5jdGlvbiBsb2NhdGUoKSB7XG4gICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgT2JqZWN0KF9jb21tb25fY3ZfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImhhbGZTYW1wbGVcIl0pKF9pbnB1dEltYWdlV3JhcHBlciwgX2N1cnJlbnRJbWFnZVdyYXBwZXIpO1xuICAgIH1cbiAgICBiaW5hcml6ZUltYWdlKCk7XG4gICAgdmFyIHBhdGNoZXNGb3VuZCA9IGZpbmRQYXRjaGVzKCk7XG4gICAgLy8gcmV0dXJuIHVubGVzcyA1JSBvciBtb3JlIHBhdGNoZXMgYXJlIGZvdW5kXG4gICAgaWYgKHBhdGNoZXNGb3VuZC5sZW5ndGggPCBfbnVtUGF0Y2hlcy54ICogX251bVBhdGNoZXMueSAqIDAuMDUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHJhc3RlcnJpemUgYXJlYSBieSBjb21wYXJpbmcgYW5ndWxhciBzaW1pbGFyaXR5O1xuICAgIHZhciBtYXhMYWJlbCA9IHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCk7XG4gICAgaWYgKG1heExhYmVsIDwgMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2VhcmNoIGZvciBhcmVhIHdpdGggdGhlIG1vc3QgcGF0Y2hlcyAoYmlnZ2VzdCBjb25uZWN0ZWQgYXJlYSlcbiAgICB2YXIgdG9wTGFiZWxzID0gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCk7XG4gICAgaWYgKHRvcExhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgYm94ZXMgPSBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCk7XG4gICAgcmV0dXJuIGJveGVzO1xuICB9LFxuICBjaGVja0ltYWdlQ29uc3RyYWludHM6IGZ1bmN0aW9uIGNoZWNrSW1hZ2VDb25zdHJhaW50cyhpbnB1dFN0cmVhbSwgY29uZmlnKSB7XG4gICAgdmFyIHBhdGNoU2l6ZTtcbiAgICB2YXIgd2lkdGggPSBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKTtcbiAgICB2YXIgdGhpc0hhbGZTYW1wbGUgPSBjb25maWcuaGFsZlNhbXBsZSA/IDAuNSA6IDE7XG4gICAgdmFyIGFyZWE7XG5cbiAgICAvLyBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodCBiYXNlZCBvbiBhcmVhXG4gICAgaWYgKGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpIHtcbiAgICAgIGFyZWEgPSBPYmplY3QoX2NvbW1vbl9jdl91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiY29tcHV0ZUltYWdlQXJlYVwiXSkod2lkdGgsIGhlaWdodCwgaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSk7XG4gICAgICBpbnB1dFN0cmVhbS5zZXRUb3BSaWdodCh7XG4gICAgICAgIHg6IGFyZWEuc3gsXG4gICAgICAgIHk6IGFyZWEuc3lcbiAgICAgIH0pO1xuICAgICAgaW5wdXRTdHJlYW0uc2V0Q2FudmFzU2l6ZSh7XG4gICAgICAgIHg6IHdpZHRoLFxuICAgICAgICB5OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgICAgd2lkdGggPSBhcmVhLnN3O1xuICAgICAgaGVpZ2h0ID0gYXJlYS5zaDtcbiAgICB9XG4gICAgdmFyIHNpemUgPSB7XG4gICAgICB4OiBNYXRoLmZsb29yKHdpZHRoICogdGhpc0hhbGZTYW1wbGUpLFxuICAgICAgeTogTWF0aC5mbG9vcihoZWlnaHQgKiB0aGlzSGFsZlNhbXBsZSlcbiAgICB9O1xuICAgIHBhdGNoU2l6ZSA9IE9iamVjdChfY29tbW9uX2N2X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJjYWxjdWxhdGVQYXRjaFNpemVcIl0pKGNvbmZpZy5wYXRjaFNpemUsIHNpemUpO1xuICAgIGlmIChmYWxzZSkge31cbiAgICBpbnB1dFN0cmVhbS5zZXRXaWR0aChNYXRoLm1heChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS54IC8gcGF0Y2hTaXplLngpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueCksIHBhdGNoU2l6ZS54KSk7XG4gICAgaW5wdXRTdHJlYW0uc2V0SGVpZ2h0KE1hdGgubWF4KE1hdGguZmxvb3IoTWF0aC5mbG9vcihzaXplLnkgLyBwYXRjaFNpemUueSkgKiAoMSAvIHRoaXNIYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS55KSwgcGF0Y2hTaXplLnkpKTtcbiAgICBpZiAoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAlIHBhdGNoU2l6ZS54ID09PSAwICYmIGlucHV0U3RyZWFtLmdldEhlaWdodCgpICUgcGF0Y2hTaXplLnkgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5nczogV2lkdGggKFwiLmNvbmNhdCh3aWR0aCwgXCIgKWFuZCBoZWlnaHQgKFwiKS5jb25jYXQoaGVpZ2h0LCBcIikgbXVzdCBhIG11bHRpcGxlIG9mIFwiKS5jb25jYXQocGF0Y2hTaXplLngpKTtcbiAgfVxufSk7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyg0NikpKVxuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBsaXN0Q2FjaGVDbGVhciA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpLFxuICBsaXN0Q2FjaGVEZWxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKSxcbiAgbGlzdENhY2hlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCksXG4gIGxpc3RDYWNoZUhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpLFxuICBsaXN0Q2FjaGVTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXE7XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNLZXlhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KSA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXSA6IGRhdGEubWFwO1xufVxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMiksXG4gIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYXJndW1lbnRzO1xufSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiYgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpLFxuICBpc0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ1KSxcbiAgc3RyaW5nVG9QYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDYpLFxuICB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ5KTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5V2l0aEhvbGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzMpO1xudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzQpO1xudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG52YXIgbm9uSXRlcmFibGVSZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzUpO1xuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlXaXRob3V0SG9sZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzOSk7XG52YXIgaXRlcmFibGVUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApO1xudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MSk7XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc05hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oODIpLFxuICBnZXRWYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKSxcbiAgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICBpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcbiAgICBtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24gKCkge307XG4gICAgbW9kdWxlLnBhdGhzID0gW107XG4gICAgLy8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG4gICAgaWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5sO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLmk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG4gIH1cbiAgcmV0dXJuIG1vZHVsZTtcbn07XG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSxcbiAgaXNMZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMiksXG4gIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fCBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZztcbn1cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHZhbHVlICsgJyc7XG4gIHJldHVybiByZXN1bHQgPT0gJzAnICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyAnLTAnIDogcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSksXG4gIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KSkpXG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0oKTtcbnRyeSB7XG4gIC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuICBnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuICAvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtYXBDYWNoZUNsZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OSksXG4gIG1hcENhY2hlRGVsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NiksXG4gIG1hcENhY2hlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCksXG4gIG1hcENhY2hlSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OSksXG4gIG1hcENhY2hlU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDApO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcblxuLyoqKi8gfSksXG4vKiA0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUFzc2lnblZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyksXG4gIGVxID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBvdmVyQXJnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTEpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgIHByb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSB8fCBvYmplY3RQcm90bztcbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKG1vZHVsZSkge3ZhciByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSksXG4gIHN0dWJGYWxzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE0KTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9ICB0cnVlICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KShtb2R1bGUpKSlcblxuLyoqKi8gfSksXG4vKiA1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE2KSxcbiAgYmFzZVVuYXJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTcpLFxuICBub2RlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE4KTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcblxuLyoqKi8gfSksXG4vKiA1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlQXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSxcbiAgZXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG5cbi8qKiovIH0pLFxuLyogNTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5TGlrZUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMSksXG4gIGJhc2VLZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMyksXG4gIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG5cbi8qKiovIH0pLFxuLyogNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cbi8qKiovIH0pLFxuLyogNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFwcGx5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gZnVuYy5sZW5ndGggLSAxIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcblxuLyoqKi8gfSksXG4vKiA1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVNldFRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjgpLFxuICBzaG9ydE91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMwKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG5cbi8qKiovIH0pLFxuLyogNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5TGlrZVRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcbi8qIDYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfdHlwZW9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMylbXCJkZWZhdWx0XCJdO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzYpO1xuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b1Byb3BlcnR5S2V5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VQaWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDIpLFxuICBmbGF0UmVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTU2KTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uIChvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gcGljaztcblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG52YXIgaXNOYXRpdmVGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTYxKTtcbnZhciBjb25zdHJ1Y3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2Mik7XG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG4gIG1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIWlzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBnZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gTk9URSBGT1IgQU5ZT05FIElOIEhFUkUgSU4gVEhFIEZVVFVSRTogVGhpcyBtb2R1bGUgaXMgdXNlZCB3aGVuIHRoZSBtb2R1bGUgaXMgYnVpbHQgZm9yIHVzZSBpbiBOb2RlLlxuLy8gV2VicGFjay5jb25maWcuanMgZXhwbGljaXRseSBSRVBMQUNFUyB0aGlzIG1vZHVsZSB3aXRoIHRoZSBmaWxlIGNhbGxlZCBmcmFtZV9ncmFiYmVyX2Jyb3dzZXIgd2hlbiBpdCBpcyBwYWNraW5nIHRoZSBCcm93c2VyIGRpc3RyaWJ1dGlvbi5cblxudmFyIENWVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBOZGFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjQpO1xudmFyIEludGVycDJEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjUpLmQyO1xudmFyIEZyYW1lR3JhYmJlciA9IHt9O1xuRnJhbWVHcmFiYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbnB1dFN0cmVhbSwgY2FudmFzKSB7XG4gIC8vIGNvbnNvbGUud2FybignKioqIEZyYW1lR3JhYmJlck5vZGUgY3JlYXRlKCknKTtcbiAgdmFyIF90aGF0ID0ge307XG4gIHZhciBfdmlkZW9TaXplID0gQ1ZVdGlscy5pbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRSZWFsV2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0UmVhbEhlaWdodCgpKTtcbiAgdmFyIF9jYW52YXNTaXplID0gaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpO1xuICB2YXIgX3NpemUgPSBDVlV0aWxzLmltYWdlUmVmKGlucHV0U3RyZWFtLmdldFdpZHRoKCksIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKTtcbiAgdmFyIF90b3BSaWdodCA9IGlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XG4gIHZhciBfZGF0YSA9IG5ldyBVaW50OEFycmF5KF9zaXplLnggKiBfc2l6ZS55KTtcbiAgdmFyIF9ncmF5RGF0YSA9IG5ldyBVaW50OEFycmF5KF92aWRlb1NpemUueCAqIF92aWRlb1NpemUueSk7XG4gIHZhciBfY2FudmFzRGF0YSA9IG5ldyBVaW50OEFycmF5KF9jYW52YXNTaXplLnggKiBfY2FudmFzU2l6ZS55KTtcbiAgLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuICB2YXIgX2dyYXlJbWFnZUFycmF5ID0gTmRhcnJheShfZ3JheURhdGEsIFtfdmlkZW9TaXplLnksIF92aWRlb1NpemUueF0pLnRyYW5zcG9zZSgxLCAwKTtcbiAgdmFyIF9jYW52YXNJbWFnZUFycmF5ID0gTmRhcnJheShfY2FudmFzRGF0YSwgW19jYW52YXNTaXplLnksIF9jYW52YXNTaXplLnhdKS50cmFuc3Bvc2UoMSwgMCk7XG4gIHZhciBfdGFyZ2V0SW1hZ2VBcnJheSA9IF9jYW52YXNJbWFnZUFycmF5LmhpKF90b3BSaWdodC54ICsgX3NpemUueCwgX3RvcFJpZ2h0LnkgKyBfc2l6ZS55KS5sbyhfdG9wUmlnaHQueCwgX3RvcFJpZ2h0LnkpO1xuICB2YXIgX3N0ZXBTaXplWCA9IF92aWRlb1NpemUueCAvIF9jYW52YXNTaXplLng7XG4gIHZhciBfc3RlcFNpemVZID0gX3ZpZGVvU2l6ZS55IC8gX2NhbnZhc1NpemUueTtcbiAgaWYgKGZhbHNlKSB7fVxuXG4gIC8qKlxuICAgKiBVc2VzIHRoZSBnaXZlbiBhcnJheSBhcyBmcmFtZS1idWZmZXJcbiAgICovXG4gIF90aGF0LmF0dGFjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIF9kYXRhID0gZGF0YTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXNlZCBmcmFtZS1idWZmZXJcbiAgICovXG4gIF90aGF0LmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kYXRhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGEgZnJhbWUgZnJvbSB0aGUgaW5wdXQtc3RyZWFtIGFuZCBwdXRzIGludG8gdGhlIGZyYW1lLWJ1ZmZlci5cbiAgICogVGhlIGltYWdlLWRhdGEgaXMgY29udmVydGVkIHRvIGdyYXktc2NhbGUgYW5kIHRoZW4gaGFsZi1zYW1wbGVkIGlmIGNvbmZpZ3VyZWQuXG4gICAqL1xuICBfdGhhdC5ncmFiID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcmFtZSA9IGlucHV0U3RyZWFtLmdldEZyYW1lKCk7XG4gICAgaWYgKGZyYW1lKSB7XG4gICAgICB0aGlzLnNjYWxlQW5kQ3JvcChmcmFtZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBfdGhhdC5zY2FsZUFuZENyb3AgPSBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAvLyAxLiBjb21wdXRlIGZ1bGwtc2l6ZWQgZ3JheSBpbWFnZVxuICAgIENWVXRpbHMuY29tcHV0ZUdyYXkoZnJhbWUuZGF0YSwgX2dyYXlEYXRhKTtcblxuICAgIC8vIDIuIGludGVycG9sYXRlXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBfY2FudmFzU2l6ZS55OyB5KyspIHtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgX2NhbnZhc1NpemUueDsgeCsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIF9jYW52YXNJbWFnZUFycmF5LnNldCh4LCB5LCBJbnRlcnAyRChfZ3JheUltYWdlQXJyYXksIHggKiBfc3RlcFNpemVYLCB5ICogX3N0ZXBTaXplWSkgfCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0YXJnZXRJbWFnZUFycmF5IG11c3QgYmUgZXF1YWwgdG8gdGFyZ2V0U2l6ZVxuICAgIGlmIChfdGFyZ2V0SW1hZ2VBcnJheS5zaGFwZVswXSAhPT0gX3NpemUueCB8fCBfdGFyZ2V0SW1hZ2VBcnJheS5zaGFwZVsxXSAhPT0gX3NpemUueSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFwZXMgZG8gbm90IG1hdGNoIScpO1xuICAgIH1cblxuICAgIC8vIDMuIGNyb3BcbiAgICBmb3IgKHZhciBfeSA9IDA7IF95IDwgX3NpemUueTsgX3krKykge1xuICAgICAgZm9yICh2YXIgX3ggPSAwOyBfeCA8IF9zaXplLng7IF94KyspIHtcbiAgICAgICAgX2RhdGFbX3kgKiBfc2l6ZS54ICsgX3hdID0gX3RhcmdldEltYWdlQXJyYXkuZ2V0KF94LCBfeSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfdGhhdC5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfc2l6ZTtcbiAgfTtcbiAgcmV0dXJuIF90aGF0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gRnJhbWVHcmFiYmVyO1xuXG4vKioqLyB9KSxcbi8qIDY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImdldC1waXhlbHNcIik7XG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYWNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cblxuLyoqXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXG4gKi9cbnZhciBSYXN0ZXJpemVyID0ge1xuICBjcmVhdGVDb250b3VyMkQ6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRvdXIyRCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlyOiBudWxsLFxuICAgICAgaW5kZXg6IG51bGwsXG4gICAgICBmaXJzdFZlcnRleDogbnVsbCxcbiAgICAgIGluc2lkZUNvbnRvdXJzOiBudWxsLFxuICAgICAgbmV4dHBlZXI6IG51bGwsXG4gICAgICBwcmV2cGVlcjogbnVsbFxuICAgIH07XG4gIH0sXG4gIENPTlRPVVJfRElSOiB7XG4gICAgQ1dfRElSOiAwLFxuICAgIENDV19ESVI6IDEsXG4gICAgVU5LTk9XTl9ESVI6IDJcbiAgfSxcbiAgRElSOiB7XG4gICAgT1VUU0lERV9FREdFOiAtMzI3NjcsXG4gICAgSU5TSURFX0VER0U6IC0zMjc2NlxuICB9LFxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgIHZhciBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICB2YXIgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGE7XG4gICAgdmFyIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICB2YXIgdHJhY2VyID0gX3RyYWNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhc3Rlcml6ZTogZnVuY3Rpb24gcmFzdGVyaXplKGRlcHRobGFiZWwpIHtcbiAgICAgICAgdmFyIGNvbG9yO1xuICAgICAgICB2YXIgYmM7XG4gICAgICAgIHZhciBsYztcbiAgICAgICAgdmFyIGxhYmVsaW5kZXg7XG4gICAgICAgIHZhciBjeDtcbiAgICAgICAgdmFyIGN5O1xuICAgICAgICB2YXIgY29sb3JNYXAgPSBbXTtcbiAgICAgICAgdmFyIHZlcnRleDtcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIHZhciBjYztcbiAgICAgICAgdmFyIHNjO1xuICAgICAgICB2YXIgcG9zO1xuICAgICAgICB2YXIgY29ubmVjdGVkQ291bnQgPSAwO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDQwMDsgaSsrKSB7XG4gICAgICAgICAgY29sb3JNYXBbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbG9yTWFwWzBdID0gaW1hZ2VEYXRhWzBdO1xuICAgICAgICBjYyA9IG51bGw7XG4gICAgICAgIGZvciAoY3kgPSAxOyBjeSA8IGhlaWdodCAtIDE7IGN5KyspIHtcbiAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcbiAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xuICAgICAgICAgIGZvciAoY3ggPSAxOyBjeCA8IHdpZHRoIC0gMTsgY3grKykge1xuICAgICAgICAgICAgcG9zID0gY3kgKiB3aWR0aCArIGN4O1xuICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbG9yID0gaW1hZ2VEYXRhW3Bvc107XG4gICAgICAgICAgICAgIGlmIChjb2xvciAhPT0gYmMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbGMgPSBjb25uZWN0ZWRDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgICBjb2xvck1hcFtsY10gPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgIGJjID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXIuY29udG91clRyYWNpbmcoY3ksIGN4LCBsYywgY29sb3IsIFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRSk7XG4gICAgICAgICAgICAgICAgICBpZiAodmVydGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSBsYztcbiAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XG4gICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgIHAuaW5kZXggPSBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gY2M7XG4gICAgICAgICAgICAgICAgICAgIHAuaW5zaWRlQ29udG91cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYy5wcmV2cGVlciA9IHA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2MgPSBwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXIuY29udG91clRyYWNpbmcoY3ksIGN4LCBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSwgY29sb3IsIGxhYmVsaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5maXJzdFZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aGxhYmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwLmluZGV4ID0gZGVwdGhsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgc2MgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNjICE9PSBudWxsICYmIHNjLmluZGV4ICE9PSBsYWJlbGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gc2MuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNjLmluc2lkZUNvbnRvdXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3Vycy5wcmV2cGVlciA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHNjLmluc2lkZUNvbnRvdXJzID0gcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRSB8fCBsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcbiAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IDA7XG4gICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcbiAgICAgICAgICAgICAgICBiYyA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxhYmVsaW5kZXggPSBsYWJlbERhdGFbcG9zXTtcbiAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFtsYWJlbGluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2MgPSBjYztcbiAgICAgICAgd2hpbGUgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgc2MuaW5kZXggPSBkZXB0aGxhYmVsO1xuICAgICAgICAgIHNjID0gc2MubmV4dHBlZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYzogY2MsXG4gICAgICAgICAgY291bnQ6IGNvbm5lY3RlZENvdW50XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGVidWc6IHtcbiAgICAgICAgZHJhd0NvbnRvdXI6IGZ1bmN0aW9uIGRyYXdDb250b3VyKGNhbnZhcywgZmlyc3RDb250b3VyKSB7XG4gICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgIHZhciBwcSA9IGZpcnN0Q29udG91cjtcbiAgICAgICAgICB2YXIgaXE7XG4gICAgICAgICAgdmFyIHE7XG4gICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaXEgPSBwcS5pbnNpZGVDb250b3VycztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocHEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBxID0gaXE7XG4gICAgICAgICAgICAgIGlxID0gaXEubmV4dHBlZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBxID0gcHE7XG4gICAgICAgICAgICAgIHBxID0gcHEubmV4dHBlZXI7XG4gICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlxID0gcHEuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHEuZGlyKSB7XG4gICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI6XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSOlxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLlVOS05PV05fRElSOlxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcS5maXJzdFZlcnRleDtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgICBjdHgubGluZVRvKHAueCwgcC55KTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHAgIT09IHEuZmlyc3RWZXJ0ZXgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFJhc3Rlcml6ZXIpO1xuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuXG4vKiBAcHJlc2VydmUgQVNNIEJFR0lOICovXG5mdW5jdGlvbiBTa2VsZXRvbml6ZXIoc3RkbGliLCBmb3JlaWduLCBidWZmZXIpIHtcbiAgJ3VzZSBhc20nO1xuXG4gIHZhciBpbWFnZXMgPSBuZXcgc3RkbGliLlVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgdmFyIHNpemUgPSBmb3JlaWduLnNpemUgfCAwO1xuICB2YXIgaW11bCA9IHN0ZGxpYi5NYXRoLmltdWw7XG4gIGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgaW5JbWFnZVB0ciB8PSAwO1xuICAgIG91dEltYWdlUHRyIHw9IDA7XG4gICAgdmFyIHYgPSAwO1xuICAgIHZhciB1ID0gMDtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgeVN0YXJ0MSA9IDA7XG4gICAgdmFyIHlTdGFydDIgPSAwO1xuICAgIHZhciB4U3RhcnQxID0gMDtcbiAgICB2YXIgeFN0YXJ0MiA9IDA7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8IChzaXplIC0gMSB8IDApOyB2ID0gdiArIDEgfCAwKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyBzaXplIHwgMDtcbiAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoc2l6ZSAtIDEgfCAwKTsgdSA9IHUgKyAxIHwgMCkge1xuICAgICAgICB5U3RhcnQxID0gb2Zmc2V0IC0gc2l6ZSB8IDA7XG4gICAgICAgIHlTdGFydDIgPSBvZmZzZXQgKyBzaXplIHwgMDtcbiAgICAgICAgeFN0YXJ0MSA9IHUgLSAxIHwgMDtcbiAgICAgICAgeFN0YXJ0MiA9IHUgKyAxIHwgMDtcbiAgICAgICAgc3VtID0gKGltYWdlc1tpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEgfCAwXSB8IDApICsgKGltYWdlc1tpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDIgfCAwXSB8IDApICsgKGltYWdlc1tpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSB8IDBdIHwgMCkgKyAoaW1hZ2VzW2luSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSB8IDBdIHwgMCkgKyAoaW1hZ2VzW2luSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MiB8IDBdIHwgMCkgfCAwO1xuICAgICAgICBpZiAoKHN1bSB8IDApID09ICg1IHwgMCkpIHtcbiAgICAgICAgICBpbWFnZXNbb3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1IHwgMF0gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltYWdlc1tvdXRJbWFnZVB0ciArIG9mZnNldCArIHUgfCAwXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3VidHJhY3QoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgYUltYWdlUHRyIHw9IDA7XG4gICAgYkltYWdlUHRyIHw9IDA7XG4gICAgb3V0SW1hZ2VQdHIgfD0gMDtcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcbiAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIC0gMSB8IDA7XG4gICAgICBpbWFnZXNbb3V0SW1hZ2VQdHIgKyBsZW5ndGggfCAwXSA9IChpbWFnZXNbYUltYWdlUHRyICsgbGVuZ3RoIHwgMF0gfCAwKSAtIChpbWFnZXNbYkltYWdlUHRyICsgbGVuZ3RoIHwgMF0gfCAwKSB8IDA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICBhSW1hZ2VQdHIgfD0gMDtcbiAgICBiSW1hZ2VQdHIgfD0gMDtcbiAgICBvdXRJbWFnZVB0ciB8PSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggLSAxIHwgMDtcbiAgICAgIGltYWdlc1tvdXRJbWFnZVB0ciArIGxlbmd0aCB8IDBdID0gaW1hZ2VzW2FJbWFnZVB0ciArIGxlbmd0aCB8IDBdIHwgMCB8IChpbWFnZXNbYkltYWdlUHRyICsgbGVuZ3RoIHwgMF0gfCAwKSB8IDA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNvdW50Tm9uWmVybyhpbWFnZVB0cikge1xuICAgIGltYWdlUHRyIHw9IDA7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG4gICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCAtIDEgfCAwO1xuICAgICAgc3VtID0gKHN1bSB8IDApICsgKGltYWdlc1tpbWFnZVB0ciArIGxlbmd0aCB8IDBdIHwgMCkgfCAwO1xuICAgIH1cbiAgICByZXR1cm4gc3VtIHwgMDtcbiAgfVxuICBmdW5jdGlvbiBpbml0KGltYWdlUHRyLCB2YWx1ZSkge1xuICAgIGltYWdlUHRyIHw9IDA7XG4gICAgdmFsdWUgfD0gMDtcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcbiAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIC0gMSB8IDA7XG4gICAgICBpbWFnZXNbaW1hZ2VQdHIgKyBsZW5ndGggfCAwXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkaWxhdGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICBpbkltYWdlUHRyIHw9IDA7XG4gICAgb3V0SW1hZ2VQdHIgfD0gMDtcbiAgICB2YXIgdiA9IDA7XG4gICAgdmFyIHUgPSAwO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciB5U3RhcnQxID0gMDtcbiAgICB2YXIgeVN0YXJ0MiA9IDA7XG4gICAgdmFyIHhTdGFydDEgPSAwO1xuICAgIHZhciB4U3RhcnQyID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHYgPSAxOyAodiB8IDApIDwgKHNpemUgLSAxIHwgMCk7IHYgPSB2ICsgMSB8IDApIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHNpemUgfCAwO1xuICAgICAgZm9yICh1ID0gMTsgKHUgfCAwKSA8IChzaXplIC0gMSB8IDApOyB1ID0gdSArIDEgfCAwKSB7XG4gICAgICAgIHlTdGFydDEgPSBvZmZzZXQgLSBzaXplIHwgMDtcbiAgICAgICAgeVN0YXJ0MiA9IG9mZnNldCArIHNpemUgfCAwO1xuICAgICAgICB4U3RhcnQxID0gdSAtIDEgfCAwO1xuICAgICAgICB4U3RhcnQyID0gdSArIDEgfCAwO1xuICAgICAgICBzdW0gPSAoaW1hZ2VzW2luSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSB8IDBdIHwgMCkgKyAoaW1hZ2VzW2luSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MiB8IDBdIHwgMCkgKyAoaW1hZ2VzW2luSW1hZ2VQdHIgKyBvZmZzZXQgKyB1IHwgMF0gfCAwKSArIChpbWFnZXNbaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxIHwgMF0gfCAwKSArIChpbWFnZXNbaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyIHwgMF0gfCAwKSB8IDA7XG4gICAgICAgIGlmICgoc3VtIHwgMCkgPiAoMCB8IDApKSB7XG4gICAgICAgICAgaW1hZ2VzW291dEltYWdlUHRyICsgb2Zmc2V0ICsgdSB8IDBdID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbWFnZXNbb3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1IHwgMF0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lbWNweShzcmNJbWFnZVB0ciwgZHN0SW1hZ2VQdHIpIHtcbiAgICBzcmNJbWFnZVB0ciB8PSAwO1xuICAgIGRzdEltYWdlUHRyIHw9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG4gICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCAtIDEgfCAwO1xuICAgICAgaW1hZ2VzW2RzdEltYWdlUHRyICsgbGVuZ3RoIHwgMF0gPSBpbWFnZXNbc3JjSW1hZ2VQdHIgKyBsZW5ndGggfCAwXSB8IDA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHplcm9Cb3JkZXIoaW1hZ2VQdHIpIHtcbiAgICBpbWFnZVB0ciB8PSAwO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgZm9yICh4ID0gMDsgKHggfCAwKSA8IChzaXplIC0gMSB8IDApOyB4ID0geCArIDEgfCAwKSB7XG4gICAgICBpbWFnZXNbaW1hZ2VQdHIgKyB4IHwgMF0gPSAwO1xuICAgICAgaW1hZ2VzW2ltYWdlUHRyICsgeSB8IDBdID0gMDtcbiAgICAgIHkgPSB5ICsgc2l6ZSAtIDEgfCAwO1xuICAgICAgaW1hZ2VzW2ltYWdlUHRyICsgeSB8IDBdID0gMDtcbiAgICAgIHkgPSB5ICsgMSB8IDA7XG4gICAgfVxuICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoc2l6ZSB8IDApOyB4ID0geCArIDEgfCAwKSB7XG4gICAgICBpbWFnZXNbaW1hZ2VQdHIgKyB5IHwgMF0gPSAwO1xuICAgICAgeSA9IHkgKyAxIHwgMDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2tlbGV0b25pemUoKSB7XG4gICAgdmFyIHN1YkltYWdlUHRyID0gMDtcbiAgICB2YXIgZXJvZGVkSW1hZ2VQdHIgPSAwO1xuICAgIHZhciB0ZW1wSW1hZ2VQdHIgPSAwO1xuICAgIHZhciBza2VsSW1hZ2VQdHIgPSAwO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBkb25lID0gMDtcbiAgICBlcm9kZWRJbWFnZVB0ciA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuICAgIHRlbXBJbWFnZVB0ciA9IGVyb2RlZEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIgfCAwO1xuICAgIHNrZWxJbWFnZVB0ciA9IHRlbXBJbWFnZVB0ciArIGVyb2RlZEltYWdlUHRyIHwgMDtcblxuICAgIC8vIGluaXQgc2tlbC1pbWFnZVxuICAgIGluaXQoc2tlbEltYWdlUHRyLCAwKTtcbiAgICB6ZXJvQm9yZGVyKHN1YkltYWdlUHRyKTtcbiAgICBkbyB7XG4gICAgICBlcm9kZShzdWJJbWFnZVB0ciwgZXJvZGVkSW1hZ2VQdHIpO1xuICAgICAgZGlsYXRlKGVyb2RlZEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIpO1xuICAgICAgc3VidHJhY3Qoc3ViSW1hZ2VQdHIsIHRlbXBJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcbiAgICAgIGJpdHdpc2VPcihza2VsSW1hZ2VQdHIsIHRlbXBJbWFnZVB0ciwgc2tlbEltYWdlUHRyKTtcbiAgICAgIG1lbWNweShlcm9kZWRJbWFnZVB0ciwgc3ViSW1hZ2VQdHIpO1xuICAgICAgc3VtID0gY291bnROb25aZXJvKHN1YkltYWdlUHRyKSB8IDA7XG4gICAgICBkb25lID0gKHN1bSB8IDApID09IDAgfCAwO1xuICAgIH0gd2hpbGUgKCFkb25lKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNrZWxldG9uaXplOiBza2VsZXRvbml6ZVxuICB9O1xufVxuLyogQHByZXNlcnZlIEFTTSBFTkQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoU2tlbGV0b25pemVyKTtcbi8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cbi8qKiovIH0pLFxuLyogNjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2Nik7XG5cblxuLyoqKi8gfSksXG4vKiA3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3RhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKSxcbiAgYXNzaWduTWVyZ2VWYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpLFxuICBiYXNlRm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpLFxuICBiYXNlTWVyZ2VEZWVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDMpLFxuICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLFxuICBrZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KSxcbiAgc2FmZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uIChzcmNWYWx1ZSwga2V5KSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKCkpO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIGtleSArICcnLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcblxuLyoqKi8gfSksXG4vKiA3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTGlzdENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCksXG4gIHN0YWNrQ2xlYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KSxcbiAgc3RhY2tEZWxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KSxcbiAgc3RhY2tHZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KSxcbiAgc3RhY2tIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKSxcbiAgc3RhY2tTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuXG4vKioqLyB9KSxcbi8qIDczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcblxuLyoqKi8gfSksXG4vKiA3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXNzb2NJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuXG4vKioqLyB9KSxcbi8qIDc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcblxuLyoqKi8gfSksXG4vKiA3NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXNzb2NJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKiovIH0pLFxuLyogNzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIExpc3RDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKCk7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG5cbi8qKiovIH0pLFxuLyogNzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuXG4vKioqLyB9KSxcbi8qIDc5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG5cbi8qKiovIH0pLFxuLyogODEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIExpc3RDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpLFxuICBNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KSxcbiAgTWFwQ2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCBwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcblxuLyoqKi8gfSksXG4vKiA4MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpLFxuICBpc01hc2tlZCA9IF9fd2VicGFja19yZXF1aXJlX18oODUpLFxuICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLFxuICB0b1NvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oODcpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICsgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJykucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuXG4vKioqLyB9KSxcbi8qIDgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG5cbi8qKiovIH0pLFxuLyogODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuXG4vKioqLyB9KSxcbi8qIDg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb3JlSnNEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nik7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICdTeW1ib2woc3JjKV8xLicgKyB1aWQgOiAnJztcbn0oKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgbWFza1NyY0tleSBpbiBmdW5jO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcblxuLyoqKi8gfSksXG4vKiA4NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuXG4vKioqLyB9KSxcbi8qIDg3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jICsgJyc7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuXG4vKioqLyB9KSxcbi8qIDg4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcblxuLyoqKi8gfSksXG4vKiA4OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgSGFzaCA9IF9fd2VicGFja19yZXF1aXJlX18oOTApLFxuICBMaXN0Q2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSxcbiAgTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCgpLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpKCksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoKClcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcblxuLyoqKi8gfSksXG4vKiA5MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaGFzaENsZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSksXG4gIGhhc2hEZWxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyKSxcbiAgaGFzaEdldCA9IF9fd2VicGFja19yZXF1aXJlX18oOTMpLFxuICBoYXNoSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NCksXG4gIGhhc2hTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcblxuLyoqKi8gfSksXG4vKiA5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG5cbi8qKiovIH0pLFxuLyogOTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcblxuLyoqKi8gfSksXG4vKiA5MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcblxuLyoqKi8gfSksXG4vKiA5NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG5cbi8qKiovIH0pLFxuLyogOTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG5hdGl2ZUNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG5cbi8qKiovIH0pLFxuLyogOTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE1hcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuXG4vKioqLyB9KSxcbi8qIDk3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyA/IHZhbHVlICE9PSAnX19wcm90b19fJyA6IHZhbHVlID09PSBudWxsO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG5cbi8qKiovIH0pLFxuLyogOTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE1hcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcblxuLyoqKi8gfSksXG4vKiA5OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TWFwRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcblxuLyoqKi8gfSksXG4vKiAxMDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE1hcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgIHNpemUgPSBkYXRhLnNpemU7XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuXG4vKioqLyB9KSxcbi8qIDEwMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY3JlYXRlQmFzZUZvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTAyKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuXG4vKioqLyB9KSxcbi8qIDEwMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuXG4vKioqLyB9KSxcbi8qIDEwMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXNzaWduTWVyZ2VWYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpLFxuICBjbG9uZUJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTA0KSxcbiAgY2xvbmVUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpLFxuICBjb3B5QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOCksXG4gIGluaXRDbG9uZU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTA5KSxcbiAgaXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSxcbiAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpLFxuICBpc0FycmF5TGlrZU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEzKSxcbiAgaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKSxcbiAgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpLFxuICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLFxuICBpc1BsYWluT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTUpLFxuICBpc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKSxcbiAgc2FmZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpLFxuICB0b1BsYWluT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTkpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkgKyAnJywgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSA6IHVuZGVmaW5lZDtcbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG5cbi8qKiovIH0pLFxuLyogMTA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHt2YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gIHRydWUgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KShtb2R1bGUpKSlcblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsb25lQXJyYXlCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcblxuLyoqKi8gfSksXG4vKiAxMDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFVpbnQ4QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcblxuLyoqKi8gfSksXG4vKiAxMDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcblxuLyoqKi8gfSksXG4vKiAxMDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuXG4vKioqLyB9KSxcbi8qIDEwOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKSxcbiAgZ2V0UHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCksXG4gIGlzUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDExMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0KCk7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuXG4vKioqLyB9KSxcbi8qIDExMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG5cbi8qKiovIH0pLFxuLyogMTEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMiksXG4gIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG5cbi8qKiovIH0pLFxuLyogMTEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpLFxuICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcblxuLyoqKi8gfSksXG4vKiAxMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG5cbi8qKiovIH0pLFxuLyogMTE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMiksXG4gIGdldFByb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTApLFxuICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMTE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMiksXG4gIGlzTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCksXG4gIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID0gdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID0gdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKioqLyB9KSxcbi8qIDExNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG5cbi8qKiovIH0pLFxuLyogMTE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHt2YXIgZnJlZUdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gIHRydWUgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KShtb2R1bGUpKSlcblxuLyoqKi8gfSksXG4vKiAxMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvcHlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCksXG4gIGtleXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMTIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NpZ25WYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpLFxuICBiYXNlQXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMTIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlVGltZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMiksXG4gIGlzQXJndW1lbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCksXG4gIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSxcbiAgaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKSxcbiAgaXNJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpLFxuICBpc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiYgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgIGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykgfHxcbiAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSB8fFxuICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuXG4vKioqLyB9KSxcbi8qIDEyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcblxuLyoqKi8gfSksXG4vKiAxMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSksXG4gIGlzUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSksXG4gIG5hdGl2ZUtleXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTI0KTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuXG4vKioqLyB9KSxcbi8qIDEyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuXG4vKioqLyB9KSxcbi8qIDEyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNiksXG4gIGlzSXRlcmF0ZWVDYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzEpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbiAob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG4gICAgY3VzdG9taXplciA9IGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IChsZW5ndGgtLSwgY3VzdG9taXplcikgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuXG4vKioqLyB9KSxcbi8qIDEyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaWRlbnRpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KSxcbiAgb3ZlclJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KSxcbiAgc2V0VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuXG4vKioqLyB9KSxcbi8qIDEyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcblxuLyoqKi8gfSksXG4vKiAxMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvbnN0YW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjkpLFxuICBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpLFxuICBpZGVudGl0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uIChmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcblxuLyoqKi8gfSksXG4vKiAxMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcblxuLyoqKi8gfSksXG4vKiAxMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgbGFzdENhbGxlZCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcblxuLyoqKi8gfSksXG4vKiAxMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGVxID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNiksXG4gIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSksXG4gIGlzSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSxcbiAgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyA/IGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkgOiB0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdCkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcblxuLyoqKi8gfSksXG4vKiAxMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLypcbiAqIHR5cGVkZWZzLmpzXG4gKiBOb3JtYWxpemVzIGJyb3dzZXItc3BlY2lmaWMgcHJlZml4ZXMgYW5kIHByb3ZpZGUgc29tZSBiYXNpYyBwb2x5ZmlsbHNcbiAqL1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uICggLyogZnVuY3Rpb24gRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgKi9jYWxsYmFjaykge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgIH07XG4gICAgfSgpO1xuICB9XG59XG5pZiAodHlwZW9mIE1hdGguaW11bCAhPT0gJ2Z1bmN0aW9uJykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gIE1hdGguaW11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGFoID0gYSA+Pj4gMTYgJiAweGZmZmY7XG4gICAgdmFyIGFsID0gYSAmIDB4ZmZmZjtcbiAgICB2YXIgYmggPSBiID4+PiAxNiAmIDB4ZmZmZjtcbiAgICB2YXIgYmwgPSBiICYgMHhmZmZmO1xuICAgIC8vIHRoZSBzaGlmdCBieSAwIGZpeGVzIHRoZSBzaWduIG9uIHRoZSBoaWdoIHBhcnRcbiAgICAvLyB0aGUgZmluYWwgfDAgY29udmVydHMgdGhlIHVuc2lnbmVkIHZhbHVlIGludG8gYSBzaWduZWQgdmFsdWVcbiAgICByZXR1cm4gYWwgKiBibCArIChhaCAqIGJsICsgYWwgKiBiaCA8PCAxNiA+Pj4gMCkgfCAwO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbn1cblxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgLy8gLmxlbmd0aCBvZiBmdW5jdGlvbiBpcyAyXG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cbiAgICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgaWYgKG5leHRTb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgLy8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcbiAgICAgICAgICAvLyBBdm9pZCBidWdzIHdoZW4gaGFzT3duUHJvcGVydHkgaXMgc2hhZG93ZWRcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7XG4gICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAxMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG4vKiAxMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG4vKiAxMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcbi8qIDEzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX3R5cGVvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b1ByaW1pdGl2ZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcbi8qIDEzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX3R5cGVvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi9cbiAgbW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHtcbiAgICByZXR1cm4gZTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB2YXIgdCxcbiAgICBlID0ge30sXG4gICAgciA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgbiA9IHIuaGFzT3duUHJvcGVydHksXG4gICAgbyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdFtlXSA9IHIudmFsdWU7XG4gICAgfSxcbiAgICBpID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICBhID0gaS5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICBjID0gaS5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsXG4gICAgdSA9IGkudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG4gIGZ1bmN0aW9uIGRlZmluZSh0LCBlLCByKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCB7XG4gICAgICB2YWx1ZTogcixcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMFxuICAgIH0pLCB0W2VdO1xuICB9XG4gIHRyeSB7XG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAodCkge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZSh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gdFtlXSA9IHI7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB3cmFwKHQsIGUsIHIsIG4pIHtcbiAgICB2YXIgaSA9IGUgJiYgZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBlIDogR2VuZXJhdG9yLFxuICAgICAgYSA9IE9iamVjdC5jcmVhdGUoaS5wcm90b3R5cGUpLFxuICAgICAgYyA9IG5ldyBDb250ZXh0KG4gfHwgW10pO1xuICAgIHJldHVybiBvKGEsIFwiX2ludm9rZVwiLCB7XG4gICAgICB2YWx1ZTogbWFrZUludm9rZU1ldGhvZCh0LCByLCBjKVxuICAgIH0pLCBhO1xuICB9XG4gIGZ1bmN0aW9uIHRyeUNhdGNoKHQsIGUsIHIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgYXJnOiB0LmNhbGwoZSwgcilcbiAgICAgIH07XG4gICAgfSBjYXRjaCAodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICBhcmc6IHRcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGUud3JhcCA9IHdyYXA7XG4gIHZhciBoID0gXCJzdXNwZW5kZWRTdGFydFwiLFxuICAgIGwgPSBcInN1c3BlbmRlZFlpZWxkXCIsXG4gICAgZiA9IFwiZXhlY3V0aW5nXCIsXG4gICAgcyA9IFwiY29tcGxldGVkXCIsXG4gICAgeSA9IHt9O1xuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cbiAgdmFyIHAgPSB7fTtcbiAgZGVmaW5lKHAsIGEsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIHZhciBkID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgIHYgPSBkICYmIGQoZCh2YWx1ZXMoW10pKSk7XG4gIHYgJiYgdiAhPT0gciAmJiBuLmNhbGwodiwgYSkgJiYgKHAgPSB2KTtcbiAgdmFyIGcgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwKTtcbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHQpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgZGVmaW5lKHQsIGUsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UoZSwgdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKHQsIGUpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UociwgbywgaSwgYSkge1xuICAgICAgdmFyIGMgPSB0cnlDYXRjaCh0W3JdLCB0LCBvKTtcbiAgICAgIGlmIChcInRocm93XCIgIT09IGMudHlwZSkge1xuICAgICAgICB2YXIgdSA9IGMuYXJnLFxuICAgICAgICAgIGggPSB1LnZhbHVlO1xuICAgICAgICByZXR1cm4gaCAmJiBcIm9iamVjdFwiID09IF90eXBlb2YoaCkgJiYgbi5jYWxsKGgsIFwiX19hd2FpdFwiKSA/IGUucmVzb2x2ZShoLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHQsIGksIGEpO1xuICAgICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGludm9rZShcInRocm93XCIsIHQsIGksIGEpO1xuICAgICAgICB9KSA6IGUucmVzb2x2ZShoKS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdS52YWx1ZSA9IHQsIGkodSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIHQsIGksIGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGEoYy5hcmcpO1xuICAgIH1cbiAgICB2YXIgcjtcbiAgICBvKHRoaXMsIFwiX2ludm9rZVwiLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUodCwgbikge1xuICAgICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGUoZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgICAgIGludm9rZSh0LCBuLCBlLCByKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gciA9IHIgPyByLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChlLCByLCBuKSB7XG4gICAgdmFyIG8gPSBoO1xuICAgIHJldHVybiBmdW5jdGlvbiAoaSwgYSkge1xuICAgICAgaWYgKG8gPT09IGYpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICBpZiAobyA9PT0gcykge1xuICAgICAgICBpZiAoXCJ0aHJvd1wiID09PSBpKSB0aHJvdyBhO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB0LFxuICAgICAgICAgIGRvbmU6ICEwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmb3IgKG4ubWV0aG9kID0gaSwgbi5hcmcgPSBhOzspIHtcbiAgICAgICAgdmFyIGMgPSBuLmRlbGVnYXRlO1xuICAgICAgICBpZiAoYykge1xuICAgICAgICAgIHZhciB1ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShjLCBuKTtcbiAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgaWYgKHUgPT09IHkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChcIm5leHRcIiA9PT0gbi5tZXRob2QpIG4uc2VudCA9IG4uX3NlbnQgPSBuLmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IG4ubWV0aG9kKSB7XG4gICAgICAgICAgaWYgKG8gPT09IGgpIHRocm93IG8gPSBzLCBuLmFyZztcbiAgICAgICAgICBuLmRpc3BhdGNoRXhjZXB0aW9uKG4uYXJnKTtcbiAgICAgICAgfSBlbHNlIFwicmV0dXJuXCIgPT09IG4ubWV0aG9kICYmIG4uYWJydXB0KFwicmV0dXJuXCIsIG4uYXJnKTtcbiAgICAgICAgbyA9IGY7XG4gICAgICAgIHZhciBwID0gdHJ5Q2F0Y2goZSwgciwgbik7XG4gICAgICAgIGlmIChcIm5vcm1hbFwiID09PSBwLnR5cGUpIHtcbiAgICAgICAgICBpZiAobyA9IG4uZG9uZSA/IHMgOiBsLCBwLmFyZyA9PT0geSkgY29udGludWU7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBwLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IG4uZG9uZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXCJ0aHJvd1wiID09PSBwLnR5cGUgJiYgKG8gPSBzLCBuLm1ldGhvZCA9IFwidGhyb3dcIiwgbi5hcmcgPSBwLmFyZyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGUsIHIpIHtcbiAgICB2YXIgbiA9IHIubWV0aG9kLFxuICAgICAgbyA9IGUuaXRlcmF0b3Jbbl07XG4gICAgaWYgKG8gPT09IHQpIHJldHVybiByLmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBuICYmIGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKHIubWV0aG9kID0gXCJyZXR1cm5cIiwgci5hcmcgPSB0LCBtYXliZUludm9rZURlbGVnYXRlKGUsIHIpLCBcInRocm93XCIgPT09IHIubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBuICYmIChyLm1ldGhvZCA9IFwidGhyb3dcIiwgci5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBuICsgXCInIG1ldGhvZFwiKSksIHk7XG4gICAgdmFyIGkgPSB0cnlDYXRjaChvLCBlLml0ZXJhdG9yLCByLmFyZyk7XG4gICAgaWYgKFwidGhyb3dcIiA9PT0gaS50eXBlKSByZXR1cm4gci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gaS5hcmcsIHIuZGVsZWdhdGUgPSBudWxsLCB5O1xuICAgIHZhciBhID0gaS5hcmc7XG4gICAgcmV0dXJuIGEgPyBhLmRvbmUgPyAocltlLnJlc3VsdE5hbWVdID0gYS52YWx1ZSwgci5uZXh0ID0gZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSByLm1ldGhvZCAmJiAoci5tZXRob2QgPSBcIm5leHRcIiwgci5hcmcgPSB0KSwgci5kZWxlZ2F0ZSA9IG51bGwsIHkpIDogYSA6IChyLm1ldGhvZCA9IFwidGhyb3dcIiwgci5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIHIuZGVsZWdhdGUgPSBudWxsLCB5KTtcbiAgfVxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkodCkge1xuICAgIHZhciBlID0ge1xuICAgICAgdHJ5TG9jOiB0WzBdXG4gICAgfTtcbiAgICAxIGluIHQgJiYgKGUuY2F0Y2hMb2MgPSB0WzFdKSwgMiBpbiB0ICYmIChlLmZpbmFsbHlMb2MgPSB0WzJdLCBlLmFmdGVyTG9jID0gdFszXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkodCkge1xuICAgIHZhciBlID0gdC5jb21wbGV0aW9uIHx8IHt9O1xuICAgIGUudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSBlLmFyZywgdC5jb21wbGV0aW9uID0gZTtcbiAgfVxuICBmdW5jdGlvbiBDb250ZXh0KHQpIHtcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbe1xuICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgIH1dLCB0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7XG4gIH1cbiAgZnVuY3Rpb24gdmFsdWVzKGUpIHtcbiAgICBpZiAoZSB8fCBcIlwiID09PSBlKSB7XG4gICAgICB2YXIgciA9IGVbYV07XG4gICAgICBpZiAocikgcmV0dXJuIHIuY2FsbChlKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUubmV4dCkgcmV0dXJuIGU7XG4gICAgICBpZiAoIWlzTmFOKGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgbyA9IC0xLFxuICAgICAgICAgIGkgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgZm9yICg7ICsrbyA8IGUubGVuZ3RoOykgaWYgKG4uY2FsbChlLCBvKSkgcmV0dXJuIG5leHQudmFsdWUgPSBlW29dLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcbiAgICAgICAgICAgIHJldHVybiBuZXh0LnZhbHVlID0gdCwgbmV4dC5kb25lID0gITAsIG5leHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGkubmV4dCA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoX3R5cGVvZihlKSArIFwiIGlzIG5vdCBpdGVyYWJsZVwiKTtcbiAgfVxuICByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIG8oZywgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgfSksIG8oR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbixcbiAgICBjb25maWd1cmFibGU6ICEwXG4gIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdSwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgZSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCAmJiB0LmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiAhIWUgJiYgKGUgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lKSk7XG4gIH0sIGUubWFyayA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZih0LCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAodC5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKHQsIHUsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZyksIHQ7XG4gIH0sIGUuYXdyYXAgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB7XG4gICAgICBfX2F3YWl0OiB0XG4gICAgfTtcbiAgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBjLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBlLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBlLmFzeW5jID0gZnVuY3Rpb24gKHQsIHIsIG4sIG8sIGkpIHtcbiAgICB2b2lkIDAgPT09IGkgJiYgKGkgPSBQcm9taXNlKTtcbiAgICB2YXIgYSA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAodCwgciwgbiwgbyksIGkpO1xuICAgIHJldHVybiBlLmlzR2VuZXJhdG9yRnVuY3Rpb24ocikgPyBhIDogYS5uZXh0KCkudGhlbihmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQuZG9uZSA/IHQudmFsdWUgOiBhLm5leHQoKTtcbiAgICB9KTtcbiAgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKGcpLCBkZWZpbmUoZywgdSwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShnLCBhLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBkZWZpbmUoZywgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pLCBlLmtleXMgPSBmdW5jdGlvbiAodCkge1xuICAgIHZhciBlID0gT2JqZWN0KHQpLFxuICAgICAgciA9IFtdO1xuICAgIGZvciAodmFyIG4gaW4gZSkgci5wdXNoKG4pO1xuICAgIHJldHVybiByLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGZvciAoOyByLmxlbmd0aDspIHtcbiAgICAgICAgdmFyIHQgPSByLnBvcCgpO1xuICAgICAgICBpZiAodCBpbiBlKSByZXR1cm4gbmV4dC52YWx1ZSA9IHQsIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgIH07XG4gIH0sIGUudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoZSkge1xuICAgICAgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB0LCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFlKSBmb3IgKHZhciByIGluIHRoaXMpIFwidFwiID09PSByLmNoYXJBdCgwKSAmJiBuLmNhbGwodGhpcywgcikgJiYgIWlzTmFOKCtyLnNsaWNlKDEpKSAmJiAodGhpc1tyXSA9IHQpO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuZG9uZSA9ICEwO1xuICAgICAgdmFyIHQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHQudHlwZSkgdGhyb3cgdC5hcmc7XG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHRocm93IGU7XG4gICAgICB2YXIgciA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobiwgbykge1xuICAgICAgICByZXR1cm4gYS50eXBlID0gXCJ0aHJvd1wiLCBhLmFyZyA9IGUsIHIubmV4dCA9IG4sIG8gJiYgKHIubWV0aG9kID0gXCJuZXh0XCIsIHIuYXJnID0gdCksICEhbztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG8gPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgbyA+PSAwOyAtLW8pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnRyeUVudHJpZXNbb10sXG4gICAgICAgICAgYSA9IGkuY29tcGxldGlvbjtcbiAgICAgICAgaWYgKFwicm9vdFwiID09PSBpLnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgaWYgKGkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBjID0gbi5jYWxsKGksIFwiY2F0Y2hMb2NcIiksXG4gICAgICAgICAgICB1ID0gbi5jYWxsKGksIFwiZmluYWxseUxvY1wiKTtcbiAgICAgICAgICBpZiAoYyAmJiB1KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgaS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShpLmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgaS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgaS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShpLmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgaS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IHIgPj0gMDsgLS1yKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy50cnlFbnRyaWVzW3JdO1xuICAgICAgICBpZiAoby50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIG4uY2FsbChvLCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgby5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGkgPSBvO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpICYmIChcImJyZWFrXCIgPT09IHQgfHwgXCJjb250aW51ZVwiID09PSB0KSAmJiBpLnRyeUxvYyA8PSBlICYmIGUgPD0gaS5maW5hbGx5TG9jICYmIChpID0gbnVsbCk7XG4gICAgICB2YXIgYSA9IGkgPyBpLmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJldHVybiBhLnR5cGUgPSB0LCBhLmFyZyA9IGUsIGkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gaS5maW5hbGx5TG9jLCB5KSA6IHRoaXMuY29tcGxldGUoYSk7XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUodCwgZSkge1xuICAgICAgaWYgKFwidGhyb3dcIiA9PT0gdC50eXBlKSB0aHJvdyB0LmFyZztcbiAgICAgIHJldHVybiBcImJyZWFrXCIgPT09IHQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHQudHlwZSA/IHRoaXMubmV4dCA9IHQuYXJnIDogXCJyZXR1cm5cIiA9PT0gdC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gdC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSB0LnR5cGUgJiYgZSAmJiAodGhpcy5uZXh0ID0gZSksIHk7XG4gICAgfSxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaCh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKSB7XG4gICAgICAgIHZhciByID0gdGhpcy50cnlFbnRyaWVzW2VdO1xuICAgICAgICBpZiAoci5maW5hbGx5TG9jID09PSB0KSByZXR1cm4gdGhpcy5jb21wbGV0ZShyLmNvbXBsZXRpb24sIHIuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KHIpLCB5O1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godCkge1xuICAgICAgZm9yICh2YXIgZSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkge1xuICAgICAgICB2YXIgciA9IHRoaXMudHJ5RW50cmllc1tlXTtcbiAgICAgICAgaWYgKHIudHJ5TG9jID09PSB0KSB7XG4gICAgICAgICAgdmFyIG4gPSByLmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gbi50eXBlKSB7XG4gICAgICAgICAgICB2YXIgbyA9IG4uYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoZSwgciwgbikge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHIsXG4gICAgICAgIG5leHRMb2M6IG5cbiAgICAgIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB0KSwgeTtcbiAgICB9XG4gIH0sIGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvclJ1bnRpbWUsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG4vKiAxMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zdXBlclByb3BCYXNlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuLyogMTM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheUxpa2VUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKioqLyB9KSxcbi8qIDE0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG4vKiAxNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuLyogMTQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlUGlja0J5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDMpLFxuICBoYXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUzKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uICh2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2s7XG5cbi8qKiovIH0pLFxuLyogMTQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDQpLFxuICBiYXNlU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTIpLFxuICBjYXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICByZXN1bHQgPSB7fTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGlja0J5O1xuXG4vKioqLyB9KSxcbi8qIDE0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2FzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSxcbiAgdG9LZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICB2YXIgaW5kZXggPSAwLFxuICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiBpbmRleCAmJiBpbmRleCA9PSBsZW5ndGggPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG5cbi8qKiovIH0pLFxuLyogMTQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNiksXG4gIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8IG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcblxuLyoqKi8gfSksXG4vKiAxNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG1lbW9pemVDYXBwZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0Nyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuXG4vKioqLyB9KSxcbi8qIDE0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbWVtb2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ4KTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG5cbi8qKiovIH0pLFxuLyogMTQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBNYXBDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCByZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKSgpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuXG4vKioqLyB9KSxcbi8qIDE0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTApO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuXG4vKioqLyB9KSxcbi8qIDE1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyksXG4gIGFycmF5TWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTEpLFxuICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNiksXG4gIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHZhbHVlICsgJyc7XG4gIHJldHVybiByZXN1bHQgPT0gJzAnICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyAnLTAnIDogcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG5cbi8qKiovIH0pLFxuLyogMTUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuXG4vKioqLyB9KSxcbi8qIDE1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KSxcbiAgY2FzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSxcbiAgaXNJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpLFxuICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLFxuICB0b0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgIG5lc3RlZCA9IG9iamVjdDtcbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKSA/IG9ialZhbHVlIDogaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0O1xuXG4vKioqLyB9KSxcbi8qIDE1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUhhc0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTQpLFxuICBoYXNQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTUpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuXG4vKioqLyB9KSxcbi8qIDE1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuXG4vKioqLyB9KSxcbi8qIDE1NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2FzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSxcbiAgaXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSxcbiAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpLFxuICBpc0luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSksXG4gIGlzTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCksXG4gIHRvS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICByZXN1bHQgPSBmYWxzZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG5cbi8qKiovIH0pLFxuLyogMTU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmbGF0dGVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTcpLFxuICBvdmVyUmVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpLFxuICBzZXRUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRSZXN0O1xuXG4vKioqLyB9KSxcbi8qIDE1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUZsYXR0ZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1OCk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuXG4vKioqLyB9KSxcbi8qIDE1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlQdXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTkpLFxuICBpc0ZsYXR0ZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjApO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG5cbi8qKiovIH0pLFxuLyogMTU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuXG4vKioqLyB9KSxcbi8qIDE2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyksXG4gIGlzQXJndW1lbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCksXG4gIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8ICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuXG4vKioqLyB9KSxcbi8qIDE2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICB0cnkge1xuICAgIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCI7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlRnVuY3Rpb24sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG4vKiAxNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjMpO1xuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9XG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqKi8gfSksXG4vKiAxNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKiovIH0pLFxuLyogMTY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5kYXJyYXlcIik7XG5cbi8qKiovIH0pLFxuLyogMTY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5kYXJyYXktbGluZWFyLWludGVycG9sYXRlXCIpO1xuXG4vKioqLyB9KSxcbi8qIDE2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJCYXJjb2RlRGVjb2RlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGJhcmNvZGVfZGVjb2RlcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJSZWFkZXJzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gcmVhZGVyX25hbWVzcGFjZU9iamVjdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDYW1lcmFBY2Nlc3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBjYW1lcmFfYWNjZXNzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkltYWdlRGVidWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBpbWFnZV9kZWJ1Z1tcImFcIiAvKiBkZWZhdWx0ICovXTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJJbWFnZVdyYXBwZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBpbWFnZV93cmFwcGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlJlc3VsdENvbGxlY3RvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHJlc3VsdF9jb2xsZWN0b3I7IH0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL3NyYy9yZWFkZXIvaW5kZXgudHNcbnZhciByZWFkZXJfbmFtZXNwYWNlT2JqZWN0ID0ge307XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIocmVhZGVyX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQocmVhZGVyX25hbWVzcGFjZU9iamVjdCwgXCJCYXJjb2RlUmVhZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmFyY29kZV9yZWFkZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKHJlYWRlcl9uYW1lc3BhY2VPYmplY3QsIFwiVHdvT2ZGaXZlUmVhZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gXzJvZjVfcmVhZGVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChyZWFkZXJfbmFtZXNwYWNlT2JqZWN0LCBcIk5ld0NvZGFiYXJSZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb2RhYmFyX3JlYWRlcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQocmVhZGVyX25hbWVzcGFjZU9iamVjdCwgXCJDb2RlMTI4UmVhZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29kZV8xMjhfcmVhZGVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChyZWFkZXJfbmFtZXNwYWNlT2JqZWN0LCBcIkNvZGUzMlJlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvZGVfMzJfcmVhZGVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChyZWFkZXJfbmFtZXNwYWNlT2JqZWN0LCBcIkNvZGUzOVJlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvZGVfMzlfcmVhZGVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChyZWFkZXJfbmFtZXNwYWNlT2JqZWN0LCBcIkNvZGUzOVZJTlJlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvZGVfMzlfdmluX3JlYWRlcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQocmVhZGVyX25hbWVzcGFjZU9iamVjdCwgXCJDb2RlOTNSZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb2RlXzkzX3JlYWRlcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQocmVhZGVyX25hbWVzcGFjZU9iamVjdCwgXCJFQU4yUmVhZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZWFuXzJfcmVhZGVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChyZWFkZXJfbmFtZXNwYWNlT2JqZWN0LCBcIkVBTjVSZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlYW5fNV9yZWFkZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKHJlYWRlcl9uYW1lc3BhY2VPYmplY3QsIFwiRUFOOFJlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGVhbl84X3JlYWRlcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQocmVhZGVyX25hbWVzcGFjZU9iamVjdCwgXCJFQU5SZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlYW5fcmVhZGVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChyZWFkZXJfbmFtZXNwYWNlT2JqZWN0LCBcIkkyb2Y1UmVhZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaTJvZjVfcmVhZGVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChyZWFkZXJfbmFtZXNwYWNlT2JqZWN0LCBcIlVQQ0VSZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB1cGNfZV9yZWFkZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKHJlYWRlcl9uYW1lc3BhY2VPYmplY3QsIFwiVVBDUmVhZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBjX3JlYWRlcjsgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbnZhciBoZWxwZXJzX3R5cGVvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xudmFyIHR5cGVvZl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihoZWxwZXJzX3R5cGVvZik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lcmdlLmpzXG52YXIgbWVyZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbnZhciBtZXJnZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihtZXJnZSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tbW9uL3R5cGVkZWZzLmpzXG52YXIgdHlwZWRlZnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tbW9uL2ltYWdlX3dyYXBwZXIudHNcbnZhciBpbWFnZV93cmFwcGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzXG52YXIgYXN5bmNUb0dlbmVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIGFzeW5jVG9HZW5lcmF0b3JfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYXN5bmNUb0dlbmVyYXRvcik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbnZhciByZWdlbmVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgcmVnZW5lcmF0b3JfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVnZW5lcmF0b3IpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbW1vbi9pbWFnZV9kZWJ1Zy50c1xudmFyIGltYWdlX2RlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qc1xudmFyIGNsYXNzQ2FsbENoZWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBjbGFzc0NhbGxDaGVja19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjbGFzc0NhbGxDaGVjayk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qc1xudmFyIGNyZWF0ZUNsYXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBjcmVhdGVDbGFzc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcmVhdGVDbGFzcyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihhc3NlcnRUaGlzSW5pdGlhbGl6ZWQpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanNcbnZhciBpbmhlcml0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgaW5oZXJpdHNfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaW5oZXJpdHMpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1xudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocG9zc2libGVDb25zdHJ1Y3RvclJldHVybik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qc1xudmFyIGdldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBnZXRQcm90b3R5cGVPZl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihnZXRQcm90b3R5cGVPZik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihkZWZpbmVQcm9wZXJ0eSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tbW9uL2FycmF5X2hlbHBlci50c1xudmFyIGFycmF5X2hlbHBlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3JlYWRlci9iYXJjb2RlX3JlYWRlci50c1xuXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tY3ljbGVcblxuXG5cbi8vIGZvciBzb21lIHJlYXNvbiB0aGlzIHRocm93cyBhIHNoYWRvdyBlcnJvciBvbiBpdHNlbGY/IVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xudmFyIEJhcmNvZGVEaXJlY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEJhcmNvZGVEaXJlY3Rpb24pIHtcbiAgQmFyY29kZURpcmVjdGlvbltCYXJjb2RlRGlyZWN0aW9uW1wiRm9yd2FyZFwiXSA9IDFdID0gXCJGb3J3YXJkXCI7XG4gIEJhcmNvZGVEaXJlY3Rpb25bQmFyY29kZURpcmVjdGlvbltcIlJldmVyc2VcIl0gPSAtMV0gPSBcIlJldmVyc2VcIjtcbiAgcmV0dXJuIEJhcmNvZGVEaXJlY3Rpb247XG59KHt9KTtcbnZhciBiYXJjb2RlX3JlYWRlcl9CYXJjb2RlUmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFyY29kZVJlYWRlcihjb25maWcsIHN1cHBsZW1lbnRzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2tfZGVmYXVsdCgpKHRoaXMsIEJhcmNvZGVSZWFkZXIpO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcIl9yb3dcIiwgW10pO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcImNvbmZpZ1wiLCB7fSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKHRoaXMsIFwic3VwcGxlbWVudHNcIiwgW10pO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcIlNJTkdMRV9DT0RFX0VSUk9SXCIsIDApO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcIkZPUk1BVFwiLCAndW5rbm93bicpO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcIkNPTkZJR19LRVlTXCIsIHt9KTtcbiAgICB0aGlzLl9yb3cgPSBbXTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICBpZiAoc3VwcGxlbWVudHMpIHtcbiAgICAgIHRoaXMuc3VwcGxlbWVudHMgPSBzdXBwbGVtZW50cztcbiAgICB9XG4gIH1cbiAgY3JlYXRlQ2xhc3NfZGVmYXVsdCgpKEJhcmNvZGVSZWFkZXIsIFt7XG4gICAga2V5OiBcIl9uZXh0VW5zZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25leHRVbnNldChsaW5lKSB7XG4gICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghbGluZVtpXSkgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9tYXRjaFBhdHRlcm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21hdGNoUGF0dGVybihjb3VudGVyLCBjb2RlKSB7XG4gICAgICB2YXIgbWF4U2luZ2xlRXJyb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuU0lOR0xFX0NPREVfRVJST1IgfHwgMTtcbiAgICAgIHZhciBlcnJvciA9IDA7XG4gICAgICB2YXIgc2luZ2xlRXJyb3IgPSAwO1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICB2YXIgbW9kdWxvID0gMDtcbiAgICAgIHZhciBiYXJXaWR0aCA9IDA7XG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgdmFyIHNjYWxlZCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGNvdW50ZXJbaV07XG4gICAgICAgIG1vZHVsbyArPSBjb2RlW2ldO1xuICAgICAgfVxuICAgICAgaWYgKHN1bSA8IG1vZHVsbykge1xuICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIGJhcldpZHRoID0gc3VtIC8gbW9kdWxvO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtYXhTaW5nbGVFcnJvciAqPSBiYXJXaWR0aDtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjb3VudGVyLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjb3VudCA9IGNvdW50ZXJbX2ldO1xuICAgICAgICBzY2FsZWQgPSBjb2RlW19pXSAqIGJhcldpZHRoO1xuICAgICAgICBzaW5nbGVFcnJvciA9IE1hdGguYWJzKGNvdW50IC0gc2NhbGVkKSAvIHNjYWxlZDtcbiAgICAgICAgaWYgKHNpbmdsZUVycm9yID4gbWF4U2luZ2xlRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvciArPSBzaW5nbGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvciAvIG1vZHVsbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX25leHRTZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25leHRTZXQobGluZSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lW2ldKSByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvcnJlY3RCYXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLCBpbmRpY2VzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgICB2YXIgdG1wID0gMDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB0bXAgPSBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gKiAoMSAtICgxIC0gY29ycmVjdGlvbikgLyAyKTtcbiAgICAgICAgaWYgKHRtcCA+IDEpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gPSB0bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlUGF0dGVyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuJywgcGF0dGVybik7XG4gICAgICB0aGlzLl9yb3cgPSBwYXR0ZXJuO1xuICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBhdHRlcm4gY2FsbGluZyBkZWNvZGUnLCB0eXBlb2YgdGhpcywgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcy5GT1JNQVQsIEpTT04uc3RyaW5naWZ5KHRoaXMpKTtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29kZSgpO1xuICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpcnN0IHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICByZXN1bHQgPSB0aGlzLmRlY29kZSgpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV2ZXJzZWQgcmVzdWx0PScsIHJlc3VsdCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5SZXZlcnNlO1xuICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuc3RhcnQ7XG4gICAgICAgICAgcmVzdWx0LmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuZW5kO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5Gb3J3YXJkO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuZm9ybWF0ID0gdGhpcy5GT1JNQVQ7XG4gICAgICB9XG4gICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9tYXRjaFJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXRjaFJhbmdlKHN0YXJ0LCBlbmQsIHZhbHVlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPCAwID8gMCA6IHN0YXJ0O1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9yb3dbaV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbGxDb3VudGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlsbENvdW50ZXJzKCkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdyk7XG4gICAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgdmFyIGlzV2hpdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICB2YXIgY291bnRlcnMgPSBbXTtcbiAgICAgIHZhciBjb3VudGVyUG9zID0gMDtcbiAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY291bnRlcnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90b0NvdW50ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90b0NvdW50ZXJzKHN0YXJ0LCBjb3VudGVycykge1xuICAgICAgdmFyIG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgdmFyIGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICB2YXIgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbc3RhcnRdO1xuICAgICAgdmFyIGNvdW50ZXJQb3MgPSAwO1xuICAgICAgYXJyYXlfaGVscGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaXQoY291bnRlcnMsIDApO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IG51bUNvdW50ZXJzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY291bnRlcnM7XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUvaW1wbGVtZW50IHRoaXMgaW4geW91ciBjdXN0b20gcmVhZGVycy5cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVJbWFnZShpbWFnZVdyYXBwZXIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12b2lkXG4gICAgICB2b2lkIGltYWdlV3JhcHBlcjtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIkV4Y2VwdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgU3RhcnROb3RGb3VuZEV4Y2VwdGlvbjogJ1N0YXJ0LUluZm8gd2FzIG5vdCBmb3VuZCEnLFxuICAgICAgICBDb2RlTm90Rm91bmRFeGNlcHRpb246ICdDb2RlIGNvdWxkIG5vdCBiZSBmb3VuZCEnLFxuICAgICAgICBQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb246ICdQYXR0ZXJuIGNvdWxkIG5vdCBiZSBmb3VuZCEnXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmFyY29kZVJlYWRlcjtcbn0oKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJhcmNvZGVfcmVhZGVyID0gKGJhcmNvZGVfcmVhZGVyX0JhcmNvZGVSZWFkZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcmVhZGVyLzJvZjVfcmVhZGVyLnRzXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mX2RlZmF1bHQoKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX2RlZmF1bHQoKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIE4gPSAxO1xudmFyIFcgPSAzO1xudmFyIFNUQVJUX1BBVFRFUk4gPSBbVywgTiwgVywgTiwgTiwgTl07XG52YXIgU1RPUF9QQVRURVJOID0gW1csIE4sIE4sIE4sIFddO1xudmFyIENPREVfUEFUVEVSTiA9IFtbTiwgTiwgVywgVywgTl0sIFtXLCBOLCBOLCBOLCBXXSwgW04sIFcsIE4sIE4sIFddLCBbVywgVywgTiwgTiwgTl0sIFtOLCBOLCBXLCBOLCBXXSwgW1csIE4sIFcsIE4sIE5dLCBbTiwgVywgVywgTiwgTl0sIFtOLCBOLCBOLCBXLCBXXSwgW1csIE4sIE4sIFcsIE5dLCBbTiwgVywgTiwgVywgTl1dO1xudmFyIFNUQVJUX1BBVFRFUk5fTEVOR1RIID0gU1RBUlRfUEFUVEVSTi5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgdmFsKSB7XG4gIHJldHVybiBzdW0gKyB2YWw7XG59LCAwKTtcbnZhciBfMm9mNV9yZWFkZXJfVHdvT2ZGaXZlUmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFyY29kZVJlYWRlcikge1xuICBpbmhlcml0c19kZWZhdWx0KCkoVHdvT2ZGaXZlUmVhZGVyLCBfQmFyY29kZVJlYWRlcik7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVHdvT2ZGaXZlUmVhZGVyKTtcbiAgZnVuY3Rpb24gVHdvT2ZGaXZlUmVhZGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBjbGFzc0NhbGxDaGVja19kZWZhdWx0KCkodGhpcywgVHdvT2ZGaXZlUmVhZGVyKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwuYXBwbHkoX3N1cGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiYmFyU3BhY2VSYXRpb1wiLCBbMSwgMV0pO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKShhc3NlcnRUaGlzSW5pdGlhbGl6ZWRfZGVmYXVsdCgpKF90aGlzKSwgXCJGT1JNQVRcIiwgJzJvZjUnKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiU0lOR0xFX0NPREVfRVJST1JcIiwgMC43OCk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIkFWR19DT0RFX0VSUk9SXCIsIDAuMzApO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBjcmVhdGVDbGFzc19kZWZhdWx0KCkoVHdvT2ZGaXZlUmVhZGVyLCBbe1xuICAgIGtleTogXCJfZmluZFBhdHRlcm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRQYXR0ZXJuKHBhdHRlcm4sIG9mZnNldCkge1xuICAgICAgdmFyIGlzV2hpdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIHRyeUhhcmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgICB2YXIgY291bnRlciA9IFtdO1xuICAgICAgdmFyIGNvdW50ZXJQb3MgPSAwO1xuICAgICAgdmFyIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIGNvZGU6IC0xLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiAwXG4gICAgICB9O1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICB2YXIgZXJyb3IgPSAwO1xuICAgICAgdmFyIGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvdW50ZXJbaV0gPSAwO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kgPSBvZmZzZXQ7IF9pIDwgdGhpcy5fcm93Lmxlbmd0aDsgX2krKykge1xuICAgICAgICBpZiAodGhpcy5fcm93W19pXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IF9pIC0gc3VtO1xuICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gX2k7XG4gICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBjb3VudGVyLmxlbmd0aCAtIDI7IF9qKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW19qXSA9IGNvdW50ZXJbX2ogKyAyXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZmluZFN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kU3RhcnQoKSB7XG4gICAgICB2YXIgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICB2YXIgbmFycm93QmFyV2lkdGggPSAxO1xuICAgICAgdmFyIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSAwO1xuICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIFNUQVJUX1BBVFRFUk5fTEVOR1RIKTtcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogNTtcbiAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykge1xuICAgICAgdmFyIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyO1xuICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kRW5kKCkge1xuICAgICAgLy8gVE9ETzogcmV2ZXJzZSwgZm9sbG93ZWQgYnkgc29tZSBjYWxjcywgZm9sbG93ZWQgYnkgYW5vdGhlciByZXZlcnNlPyByZWFsbHk/XG4gICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgIHZhciBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RPUF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gcmV2ZXJzZSBudW1iZXJzXG4gICAgICB2YXIgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICAgIGVuZEluZm8uc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XG4gICAgICBlbmRJbmZvLmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSB0bXA7XG4gICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl92ZXJpZnlDb3VudGVyTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSB7XG4gICAgICByZXR1cm4gY291bnRlcnMubGVuZ3RoICUgMTAgPT09IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZWNvZGVDb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWNvZGVDb2RlKGNvdW50ZXIpIHtcbiAgICAgIHZhciBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcbiAgICAgIHZhciBiZXN0TWF0Y2ggPSB7XG4gICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogMFxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGNvZGUgPSAwOyBjb2RlIDwgQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlY29kZVBheWxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKSB7XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHZhciBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgdmFyIGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMF07XG4gICAgICB2YXIgY29kZSA9IG51bGw7XG4gICAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgIGNvdW50ZXJbaV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xuICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvdW50ZXIpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChcIlwiLmNvbmNhdChjb2RlLmNvZGUpKTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZShyb3csIHN0YXJ0KSB7XG4gICAgICB2YXIgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBlbmRJbmZvID0gdGhpcy5fZmluZEVuZCgpO1xuICAgICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGNvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVycykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgZGVjb2RlZENvZGVzID0gW107XG4gICAgICBkZWNvZGVkQ29kZXMucHVzaChzdGFydEluZm8pO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IDUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFUXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHdvT2ZGaXZlUmVhZGVyO1xufShiYXJjb2RlX3JlYWRlcik7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBfMm9mNV9yZWFkZXIgPSAoXzJvZjVfcmVhZGVyX1R3b09mRml2ZVJlYWRlcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9yZWFkZXIvY29kYWJhcl9yZWFkZXIudHNcblxuXG5cblxuXG5cblxuZnVuY3Rpb24gY29kYWJhcl9yZWFkZXJfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGNvZGFiYXJfcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mX2RlZmF1bHQoKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX2RlZmF1bHQoKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBjb2RhYmFyX3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5cbi8vIGNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OS0kOi8uK0FCQ0QnO1xudmFyIEFMUEhBQkVUID0gWzQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA0NSwgMzYsIDU4LCA0NywgNDYsIDQzLCA2NSwgNjYsIDY3LCA2OF07XG52YXIgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IFsweDAwMywgMHgwMDYsIDB4MDA5LCAweDA2MCwgMHgwMTIsIDB4MDQyLCAweDAyMSwgMHgwMjQsIDB4MDMwLCAweDA0OCwgMHgwMGMsIDB4MDE4LCAweDA0NSwgMHgwNTEsIDB4MDU0LCAweDAxNSwgMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdO1xudmFyIFNUQVJUX0VORCA9IFsweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XG52YXIgTUlOX0VOQ09ERURfQ0hBUlMgPSA0O1xudmFyIE1BWF9BQ0NFUFRBQkxFID0gMi4wO1xudmFyIFBBRERJTkcgPSAxLjU7XG47XG47XG52YXIgY29kYWJhcl9yZWFkZXJfTmV3Q29kYWJhclJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0JhcmNvZGVSZWFkZXIpIHtcbiAgaW5oZXJpdHNfZGVmYXVsdCgpKE5ld0NvZGFiYXJSZWFkZXIsIF9CYXJjb2RlUmVhZGVyKTtcbiAgdmFyIF9zdXBlciA9IGNvZGFiYXJfcmVhZGVyX2NyZWF0ZVN1cGVyKE5ld0NvZGFiYXJSZWFkZXIpO1xuICBmdW5jdGlvbiBOZXdDb2RhYmFyUmVhZGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBjbGFzc0NhbGxDaGVja19kZWZhdWx0KCkodGhpcywgTmV3Q29kYWJhclJlYWRlcik7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIl9jb3VudGVyc1wiLCBbXSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIkZPUk1BVFwiLCAnY29kYWJhcicpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBjcmVhdGVDbGFzc19kZWZhdWx0KCkoTmV3Q29kYWJhclJlYWRlciwgW3tcbiAgICBrZXk6IFwiX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCwgZW5kKSB7XG4gICAgICB2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIHZhciBtYXggPSAwO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSAyKSB7XG4gICAgICAgIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgaWYgKGNvdW50ZXIgPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSBjb3VudGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudGVyIDwgbWluKSB7XG4gICAgICAgICAgbWluID0gY291bnRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIChtaW4gKyBtYXgpIC8gMi4wIHwgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RvUGF0dGVyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9QYXR0ZXJuKG9mZnNldCkge1xuICAgICAgdmFyIG51bUNvdW50ZXJzID0gNztcbiAgICAgIHZhciBlbmQgPSBvZmZzZXQgKyBudW1Db3VudGVycztcbiAgICAgIGlmIChlbmQgPiB0aGlzLl9jb3VudGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGJhclRocmVzaG9sZCA9IHRoaXMuX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQsIGVuZCk7XG4gICAgICB2YXIgc3BhY2VUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0ICsgMSwgZW5kKTtcbiAgICAgIHZhciBiaXRtYXNrID0gMSA8PCBudW1Db3VudGVycyAtIDE7XG4gICAgICB2YXIgdGhyZXNob2xkID0gMDtcbiAgICAgIHZhciBwYXR0ZXJuID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICB0aHJlc2hvbGQgPSAoaSAmIDEpID09PSAwID8gYmFyVGhyZXNob2xkIDogc3BhY2VUaHJlc2hvbGQ7XG4gICAgICAgIGlmICh0aGlzLl9jb3VudGVyc1tvZmZzZXQgKyBpXSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgIHBhdHRlcm4gfD0gYml0bWFzaztcbiAgICAgICAgfVxuICAgICAgICBiaXRtYXNrID4+PSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc1N0YXJ0RW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1N0YXJ0RW5kKHBhdHRlcm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RBUlRfRU5ELmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChTVEFSVF9FTkRbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc3VtQ291bnRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N1bUNvdW50ZXJzKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgc3VtICs9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZFN0YXJ0KCkge1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdyk7XG4gICAgICB2YXIgZW5kID0gc3RhcnQ7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGkpO1xuICAgICAgICBpZiAocGF0dGVybiAhPT0gLTEgJiYgdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xuICAgICAgICAgIC8vIFRPRE86IExvb2sgZm9yIHdoaXRlc3BhY2UgYWhlYWRcbiAgICAgICAgICBzdGFydCArPSB0aGlzLl9zdW1Db3VudGVycygwLCBpKTtcbiAgICAgICAgICBlbmQgPSBzdGFydCArIHRoaXMuX3N1bUNvdW50ZXJzKGksIGkgKyA4KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBzdGFydENvdW50ZXI6IGksXG4gICAgICAgICAgICBlbmRDb3VudGVyOiBpICsgOFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcGF0dGVyblRvQ2hhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlUGF0dGVybkxlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlUGF0dGVybkxlbmd0aChvZmZzZXQpIHtcbiAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIDc7IGkrKykge1xuICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdmVyaWZ5V2hpdGVzcGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmVyaWZ5V2hpdGVzcGFjZShzdGFydENvdW50ZXIsIGVuZENvdW50ZXIpIHtcbiAgICAgIGlmIChzdGFydENvdW50ZXIgLSAxIDw9IDAgfHwgdGhpcy5fY291bnRlcnNbc3RhcnRDb3VudGVyIC0gMV0gPj0gdGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChzdGFydENvdW50ZXIpIC8gMi4wKSB7XG4gICAgICAgIGlmIChlbmRDb3VudGVyICsgOCA+PSB0aGlzLl9jb3VudGVycy5sZW5ndGggfHwgdGhpcy5fY291bnRlcnNbZW5kQ291bnRlciArIDddID49IHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoZW5kQ291bnRlcikgLyAyLjApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2hhclRvUGF0dGVyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hhclRvUGF0dGVybihfY2hhcikge1xuICAgICAgdmFyIGNoYXJDb2RlID0gX2NoYXIuY2hhckNvZGVBdCgwKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEFMUEhBQkVUW2ldID09PSBjaGFyQ29kZSkge1xuICAgICAgICAgIHJldHVybiBDSEFSQUNURVJfRU5DT0RJTkdTW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMHgwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdGhyZXNob2xkUmVzdWx0UGF0dGVyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQsIHN0YXJ0Q291bnRlcikge1xuICAgICAgdmFyIGNhdGVnb3JpemF0aW9uID0ge1xuICAgICAgICBzcGFjZToge1xuICAgICAgICAgIG5hcnJvdzoge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNvdW50czogMCxcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogTnVtYmVyLk1BWF9WQUxVRVxuICAgICAgICAgIH0sXG4gICAgICAgICAgd2lkZToge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNvdW50czogMCxcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogTnVtYmVyLk1BWF9WQUxVRVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmFyOiB7XG4gICAgICAgICAgbmFycm93OiB7XG4gICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgY291bnRzOiAwLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3aWRlOiB7XG4gICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgY291bnRzOiAwLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIHBvcyA9IHN0YXJ0Q291bnRlcjtcbiAgICAgIHZhciBwYXR0ZXJuO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0dGVybiA9IHRoaXMuX2NoYXJUb1BhdHRlcm4ocmVzdWx0W2ldKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDY7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgdmFyIGtpbmQgPSAoaiAmIDEpID09PSAyID8gY2F0ZWdvcml6YXRpb24uYmFyIDogY2F0ZWdvcml6YXRpb24uc3BhY2U7XG4gICAgICAgICAgdmFyIGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICBjYXQuc2l6ZSArPSB0aGlzLl9jb3VudGVyc1twb3MgKyBqXTtcbiAgICAgICAgICBjYXQuY291bnRzKys7XG4gICAgICAgICAgcGF0dGVybiA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gODtcbiAgICAgIH1cbiAgICAgIFsnc3BhY2UnLCAnYmFyJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdraW5kID0gY2F0ZWdvcml6YXRpb25ba2V5XTtcbiAgICAgICAgbmV3a2luZC53aWRlLm1pbiA9IE1hdGguZmxvb3IoKG5ld2tpbmQubmFycm93LnNpemUgLyBuZXdraW5kLm5hcnJvdy5jb3VudHMgKyBuZXdraW5kLndpZGUuc2l6ZSAvIG5ld2tpbmQud2lkZS5jb3VudHMpIC8gMik7XG4gICAgICAgIG5ld2tpbmQubmFycm93Lm1heCA9IE1hdGguY2VpbChuZXdraW5kLndpZGUubWluKTtcbiAgICAgICAgbmV3a2luZC53aWRlLm1heCA9IE1hdGguY2VpbCgobmV3a2luZC53aWRlLnNpemUgKiBNQVhfQUNDRVBUQUJMRSArIFBBRERJTkcpIC8gbmV3a2luZC53aWRlLmNvdW50cyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYXRlZ29yaXphdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3ZhbGlkYXRlUmVzdWx0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZVJlc3VsdChyZXN1bHQsIHN0YXJ0Q291bnRlcikge1xuICAgICAgdmFyIHRocmVzaG9sZHMgPSB0aGlzLl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdCwgc3RhcnRDb3VudGVyKTtcbiAgICAgIHZhciBwb3MgPSBzdGFydENvdW50ZXI7XG4gICAgICB2YXIgcGF0dGVybjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdHRlcm4gPSB0aGlzLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgIGZvciAodmFyIGogPSA2OyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHZhciBraW5kID0gKGogJiAxKSA9PT0gMCA/IHRocmVzaG9sZHMuYmFyIDogdGhyZXNob2xkcy5zcGFjZTtcbiAgICAgICAgICB2YXIgY2F0ID0gKHBhdHRlcm4gJiAxKSA9PT0gMSA/IGtpbmQud2lkZSA6IGtpbmQubmFycm93O1xuICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fY291bnRlcnNbcG9zICsgal07XG4gICAgICAgICAgaWYgKHNpemUgPCBjYXQubWluIHx8IHNpemUgPiBjYXQubWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdHRlcm4gPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IDg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZShyb3csIHN0YXJ0KSB7XG4gICAgICB0aGlzLl9jb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycygpO1xuICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dFN0YXJ0ID0gc3RhcnQuc3RhcnRDb3VudGVyO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHBhdHRlcm47XG4gICAgICBkbyB7XG4gICAgICAgIHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4obmV4dFN0YXJ0KTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICBuZXh0U3RhcnQgKz0gODtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAxICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobmV4dFN0YXJ0IDwgdGhpcy5fY291bnRlcnMubGVuZ3RoKTtcblxuICAgICAgLy8gdmVyaWZ5IGVuZFxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggLSAyIDwgTUlOX0VOQ09ERURfQ0hBUlMgfHwgIXRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIHZlcmlmeSBlbmQgd2hpdGUgc3BhY2VcbiAgICAgIGlmICghdGhpcy5fdmVyaWZ5V2hpdGVzcGFjZShzdGFydC5zdGFydENvdW50ZXIsIG5leHRTdGFydCAtIDgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZVJlc3VsdChyZXN1bHQsIHN0YXJ0LnN0YXJ0Q291bnRlcikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBuZXh0U3RhcnQgPSBuZXh0U3RhcnQgPiB0aGlzLl9jb3VudGVycy5sZW5ndGggPyB0aGlzLl9jb3VudGVycy5sZW5ndGggOiBuZXh0U3RhcnQ7XG4gICAgICB2YXIgZW5kID0gc3RhcnQuc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhzdGFydC5zdGFydENvdW50ZXIsIG5leHRTdGFydCAtIDgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCAvLyBUT0RPOiBpIHRoaW5rIGl0IHNob3VsZCBub3QgYmUgcmVxdWlyZWQgdG8gcmV0dXJuIGZvcm1hdCBmcm9tIHRoaXMsIGFzIGJhcmNvZGVfcmVhZGVyIGZvcmNlIHNldHMgdGhlIGZvcm1hdCBhbnl3YXlcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOZXdDb2RhYmFyUmVhZGVyO1xufShiYXJjb2RlX3JlYWRlcik7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb2RhYmFyX3JlYWRlciA9IChjb2RhYmFyX3JlYWRlcl9OZXdDb2RhYmFyUmVhZGVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIudHNcblxuXG5cblxuXG5cblxuZnVuY3Rpb24gY29kZV8xMjhfcmVhZGVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBjb2RlXzEyOF9yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fZGVmYXVsdCgpKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIGNvZGVfMTI4X3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgY29kZV8xMjhfcmVhZGVyX0NvZGUxMjhSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXJjb2RlUmVhZGVyKSB7XG4gIGluaGVyaXRzX2RlZmF1bHQoKShDb2RlMTI4UmVhZGVyLCBfQmFyY29kZVJlYWRlcik7XG4gIHZhciBfc3VwZXIgPSBjb2RlXzEyOF9yZWFkZXJfY3JlYXRlU3VwZXIoQ29kZTEyOFJlYWRlcik7XG4gIGZ1bmN0aW9uIENvZGUxMjhSZWFkZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIGNsYXNzQ2FsbENoZWNrX2RlZmF1bHQoKSh0aGlzLCBDb2RlMTI4UmVhZGVyKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwuYXBwbHkoX3N1cGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiQ09ERV9TSElGVFwiLCA5OCk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIkNPREVfQ1wiLCA5OSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIkNPREVfQlwiLCAxMDApO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKShhc3NlcnRUaGlzSW5pdGlhbGl6ZWRfZGVmYXVsdCgpKF90aGlzKSwgXCJDT0RFX0FcIiwgMTAxKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiU1RBUlRfQ09ERV9BXCIsIDEwMyk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIlNUQVJUX0NPREVfQlwiLCAxMDQpO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKShhc3NlcnRUaGlzSW5pdGlhbGl6ZWRfZGVmYXVsdCgpKF90aGlzKSwgXCJTVEFSVF9DT0RFX0NcIiwgMTA1KTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiU1RPUF9DT0RFXCIsIDEwNik7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIkNPREVfUEFUVEVSTlwiLCBbWzIsIDEsIDIsIDIsIDIsIDJdLCBbMiwgMiwgMiwgMSwgMiwgMl0sIFsyLCAyLCAyLCAyLCAyLCAxXSwgWzEsIDIsIDEsIDIsIDIsIDNdLCBbMSwgMiwgMSwgMywgMiwgMl0sIFsxLCAzLCAxLCAyLCAyLCAyXSwgWzEsIDIsIDIsIDIsIDEsIDNdLCBbMSwgMiwgMiwgMywgMSwgMl0sIFsxLCAzLCAyLCAyLCAxLCAyXSwgWzIsIDIsIDEsIDIsIDEsIDNdLCBbMiwgMiwgMSwgMywgMSwgMl0sIFsyLCAzLCAxLCAyLCAxLCAyXSwgWzEsIDEsIDIsIDIsIDMsIDJdLCBbMSwgMiwgMiwgMSwgMywgMl0sIFsxLCAyLCAyLCAyLCAzLCAxXSwgWzEsIDEsIDMsIDIsIDIsIDJdLCBbMSwgMiwgMywgMSwgMiwgMl0sIFsxLCAyLCAzLCAyLCAyLCAxXSwgWzIsIDIsIDMsIDIsIDEsIDFdLCBbMiwgMiwgMSwgMSwgMywgMl0sIFsyLCAyLCAxLCAyLCAzLCAxXSwgWzIsIDEsIDMsIDIsIDEsIDJdLCBbMiwgMiwgMywgMSwgMSwgMl0sIFszLCAxLCAyLCAxLCAzLCAxXSwgWzMsIDEsIDEsIDIsIDIsIDJdLCBbMywgMiwgMSwgMSwgMiwgMl0sIFszLCAyLCAxLCAyLCAyLCAxXSwgWzMsIDEsIDIsIDIsIDEsIDJdLCBbMywgMiwgMiwgMSwgMSwgMl0sIFszLCAyLCAyLCAyLCAxLCAxXSwgWzIsIDEsIDIsIDEsIDIsIDNdLCBbMiwgMSwgMiwgMywgMiwgMV0sIFsyLCAzLCAyLCAxLCAyLCAxXSwgWzEsIDEsIDEsIDMsIDIsIDNdLCBbMSwgMywgMSwgMSwgMiwgM10sIFsxLCAzLCAxLCAzLCAyLCAxXSwgWzEsIDEsIDIsIDMsIDEsIDNdLCBbMSwgMywgMiwgMSwgMSwgM10sIFsxLCAzLCAyLCAzLCAxLCAxXSwgWzIsIDEsIDEsIDMsIDEsIDNdLCBbMiwgMywgMSwgMSwgMSwgM10sIFsyLCAzLCAxLCAzLCAxLCAxXSwgWzEsIDEsIDIsIDEsIDMsIDNdLCBbMSwgMSwgMiwgMywgMywgMV0sIFsxLCAzLCAyLCAxLCAzLCAxXSwgWzEsIDEsIDMsIDEsIDIsIDNdLCBbMSwgMSwgMywgMywgMiwgMV0sIFsxLCAzLCAzLCAxLCAyLCAxXSwgWzMsIDEsIDMsIDEsIDIsIDFdLCBbMiwgMSwgMSwgMywgMywgMV0sIFsyLCAzLCAxLCAxLCAzLCAxXSwgWzIsIDEsIDMsIDEsIDEsIDNdLCBbMiwgMSwgMywgMywgMSwgMV0sIFsyLCAxLCAzLCAxLCAzLCAxXSwgWzMsIDEsIDEsIDEsIDIsIDNdLCBbMywgMSwgMSwgMywgMiwgMV0sIFszLCAzLCAxLCAxLCAyLCAxXSwgWzMsIDEsIDIsIDEsIDEsIDNdLCBbMywgMSwgMiwgMywgMSwgMV0sIFszLCAzLCAyLCAxLCAxLCAxXSwgWzMsIDEsIDQsIDEsIDEsIDFdLCBbMiwgMiwgMSwgNCwgMSwgMV0sIFs0LCAzLCAxLCAxLCAxLCAxXSwgWzEsIDEsIDEsIDIsIDIsIDRdLCBbMSwgMSwgMSwgNCwgMiwgMl0sIFsxLCAyLCAxLCAxLCAyLCA0XSwgWzEsIDIsIDEsIDQsIDIsIDFdLCBbMSwgNCwgMSwgMSwgMiwgMl0sIFsxLCA0LCAxLCAyLCAyLCAxXSwgWzEsIDEsIDIsIDIsIDEsIDRdLCBbMSwgMSwgMiwgNCwgMSwgMl0sIFsxLCAyLCAyLCAxLCAxLCA0XSwgWzEsIDIsIDIsIDQsIDEsIDFdLCBbMSwgNCwgMiwgMSwgMSwgMl0sIFsxLCA0LCAyLCAyLCAxLCAxXSwgWzIsIDQsIDEsIDIsIDEsIDFdLCBbMiwgMiwgMSwgMSwgMSwgNF0sIFs0LCAxLCAzLCAxLCAxLCAxXSwgWzIsIDQsIDEsIDEsIDEsIDJdLCBbMSwgMywgNCwgMSwgMSwgMV0sIFsxLCAxLCAxLCAyLCA0LCAyXSwgWzEsIDIsIDEsIDEsIDQsIDJdLCBbMSwgMiwgMSwgMiwgNCwgMV0sIFsxLCAxLCA0LCAyLCAxLCAyXSwgWzEsIDIsIDQsIDEsIDEsIDJdLCBbMSwgMiwgNCwgMiwgMSwgMV0sIFs0LCAxLCAxLCAyLCAxLCAyXSwgWzQsIDIsIDEsIDEsIDEsIDJdLCBbNCwgMiwgMSwgMiwgMSwgMV0sIFsyLCAxLCAyLCAxLCA0LCAxXSwgWzIsIDEsIDQsIDEsIDIsIDFdLCBbNCwgMSwgMiwgMSwgMiwgMV0sIFsxLCAxLCAxLCAxLCA0LCAzXSwgWzEsIDEsIDEsIDMsIDQsIDFdLCBbMSwgMywgMSwgMSwgNCwgMV0sIFsxLCAxLCA0LCAxLCAxLCAzXSwgWzEsIDEsIDQsIDMsIDEsIDFdLCBbNCwgMSwgMSwgMSwgMSwgM10sIFs0LCAxLCAxLCAzLCAxLCAxXSwgWzEsIDEsIDMsIDEsIDQsIDFdLCBbMSwgMSwgNCwgMSwgMywgMV0sIFszLCAxLCAxLCAxLCA0LCAxXSwgWzQsIDEsIDEsIDEsIDMsIDFdLCBbMiwgMSwgMSwgNCwgMSwgMl0sIFsyLCAxLCAxLCAyLCAxLCA0XSwgWzIsIDEsIDEsIDIsIDMsIDJdLCBbMiwgMywgMywgMSwgMSwgMSwgMl1dKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiU0lOR0xFX0NPREVfRVJST1JcIiwgMC42NCk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIkFWR19DT0RFX0VSUk9SXCIsIDAuMzApO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKShhc3NlcnRUaGlzSW5pdGlhbGl6ZWRfZGVmYXVsdCgpKF90aGlzKSwgXCJGT1JNQVRcIiwgJ2NvZGVfMTI4Jyk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIk1PRFVMRV9JTkRJQ0VTXCIsIHtcbiAgICAgIGJhcjogWzAsIDIsIDRdLFxuICAgICAgc3BhY2U6IFsxLCAzLCA1XVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBjcmVhdGVDbGFzc19kZWZhdWx0KCkoQ29kZTEyOFJlYWRlciwgW3tcbiAgICBrZXk6IFwiX2RlY29kZUNvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY29kZUNvZGUoc3RhcnQsIGNvcnJlY3Rpb24pIHtcbiAgICAgIHZhciBiZXN0TWF0Y2ggPSB7XG4gICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IHN0YXJ0LFxuICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgYmFyOiAxLFxuICAgICAgICAgIHNwYWNlOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgY291bnRlciA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgIHZhciBvZmZzZXQgPSBzdGFydDtcbiAgICAgIHZhciBpc1doaXRlID0gIXRoaXMuX3Jvd1tvZmZzZXRdO1xuICAgICAgdmFyIGNvdW50ZXJQb3MgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaWYgKGNvcnJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5fY29ycmVjdChjb3VudGVyLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guY29kZSA9PT0gLTEgfHwgYmVzdE1hdGNoLmVycm9yID4gdGhpcy5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0pIHtcbiAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbih0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY29ycmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29ycmVjdChjb3VudGVyLCBjb3JyZWN0aW9uKSB7XG4gICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLmJhciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgdGhpcy5fY29ycmVjdEJhcnMoY291bnRlciwgY29ycmVjdGlvbi5zcGFjZSwgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kU3RhcnRcIixcbiAgICB2YWx1ZTpcbiAgICAvLyBUT0RPOiBfZmluZFN0YXJ0IGFuZCBkZWNvZGVDb2RlIHNoYXJlIHNpbWlsYXIgY29kZSwgY2FuIHdlIHJlLXVzZSBzb21lP1xuICAgIGZ1bmN0aW9uIF9maW5kU3RhcnQoKSB7XG4gICAgICB2YXIgY291bnRlciA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICB2YXIgYmVzdE1hdGNoID0ge1xuICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgY29kZTogLTEsXG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IDAsXG4gICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICBiYXI6IDEsXG4gICAgICAgICAgc3BhY2U6IDFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBpc1doaXRlID0gZmFsc2U7XG4gICAgICB2YXIgY291bnRlclBvcyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gY291bnRlci5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBuZXh0O1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2RlID0gdGhpcy5TVEFSVF9DT0RFX0E7IGNvZGUgPD0gdGhpcy5TVEFSVF9DT0RFX0M7IGNvZGUrKykge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCB0aGlzLkFWR19DT0RFX0VSUk9SKSB7XG4gICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24odGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLCB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XG4gICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLnNwYWNlID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlY29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGUocm93LCBzdGFydCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgLy8gICAgIGRvbmUgPSBmYWxzZSxcbiAgICAgIC8vICAgICByZXN1bHQgPSBbXSxcbiAgICAgIC8vICAgICBtdWx0aXBsaWVyID0gMCxcbiAgICAgIC8vICAgICBjaGVja3N1bSA9IDAsXG4gICAgICAvLyAgICAgY29kZXNldCxcbiAgICAgIC8vICAgICByYXdSZXN1bHQgPSBbXSxcbiAgICAgIC8vICAgICBkZWNvZGVkQ29kZXMgPSBbXSxcbiAgICAgIC8vICAgICBzaGlmdE5leHQgPSBmYWxzZSxcbiAgICAgIC8vICAgICB1bnNoaWZ0LFxuICAgICAgLy8gICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuXG4gICAgICB2YXIgY29kZSA9IHtcbiAgICAgICAgY29kZTogc3RhcnRJbmZvLmNvZGUsXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZCxcbiAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgIGJhcjogc3RhcnRJbmZvLmNvcnJlY3Rpb24uYmFyLFxuICAgICAgICAgIHNwYWNlOiBzdGFydEluZm8uY29ycmVjdGlvbi5zcGFjZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGRlY29kZWRDb2RlcyA9IFtdO1xuICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICB2YXIgY2hlY2tzdW0gPSBjb2RlLmNvZGU7XG4gICAgICB2YXIgY29kZXNldCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgIGNhc2UgX3RoaXMyLlNUQVJUX0NPREVfQTpcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuQ09ERV9BO1xuICAgICAgICAgIGNhc2UgX3RoaXMyLlNUQVJUX0NPREVfQjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuQ09ERV9CO1xuICAgICAgICAgIGNhc2UgX3RoaXMyLlNUQVJUX0NPREVfQzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuQ09ERV9DO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfShjb2RlLmNvZGUpO1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIHZhciBzaGlmdE5leHQgPSBmYWxzZTtcbiAgICAgIHZhciB1bnNoaWZ0ID0gc2hpZnROZXh0O1xuICAgICAgdmFyIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuICAgICAgdmFyIG11bHRpcGxpZXIgPSAwO1xuICAgICAgdmFyIHJhd1Jlc3VsdCA9IFtdO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdOyAvLyBUT0RPOiBpIHRoaW5rIHRoaXMgc2hvdWxkIGJlIHN0cmluZyBvbmx5LCBidXQgaXQgY3JlYXRlcyBwcm9ibGVtcyBpZiBpdCBpc1xuXG4gICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgdW5zaGlmdCA9IHNoaWZ0TmV4dDtcbiAgICAgICAgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBjb2RlLmNvcnJlY3Rpb24pO1xuICAgICAgICBpZiAoY29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgIHJhd1Jlc3VsdC5wdXNoKGNvZGUuY29kZSk7XG4gICAgICAgICAgICBtdWx0aXBsaWVyKys7XG4gICAgICAgICAgICBjaGVja3N1bSArPSBtdWx0aXBsaWVyICogY29kZS5jb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICBzd2l0Y2ggKGNvZGVzZXQpIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XG4gICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCA2NCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLmNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZS5jb2RlIC0gNjQpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICBzaGlmdE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQzpcbiAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDEwMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSA8IDEwID8gJzAnICsgY29kZS5jb2RlIDogY29kZS5jb2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5zaGlmdCkge1xuICAgICAgICAgIGNvZGVzZXQgPSBjb2Rlc2V0ID09PSB0aGlzLkNPREVfQSA/IHRoaXMuQ09ERV9CIDogdGhpcy5DT0RFX0E7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29kZS5lbmQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShjb2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNoZWNrc3VtIC09IG11bHRpcGxpZXIgKiByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGNoZWNrc3VtICUgMTAzICE9PSByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgbGFzdCBjb2RlIGZyb20gcmVzdWx0IChjaGVja3N1bSlcbiAgICAgIGlmIChyZW1vdmVMYXN0Q2hhcmFjdGVyKSB7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UocmVzdWx0Lmxlbmd0aCAtIDEsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICBjb2Rlc2V0OiBjb2Rlc2V0LFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgIGVuZEluZm86IGNvZGUsXG4gICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZDtcbiAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyO1xuICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHNlbGYuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUNvcnJlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlQ29ycmVjdGlvbihleHBlY3RlZCwgbm9ybWFsaXplZCwgaW5kaWNlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGluZGljZXMubGVuZ3RoLFxuICAgICAgICBzdW1Ob3JtYWxpemVkID0gMCxcbiAgICAgICAgc3VtRXhwZWN0ZWQgPSAwO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHN1bUV4cGVjdGVkICs9IGV4cGVjdGVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgICAgIHN1bU5vcm1hbGl6ZWQgKz0gbm9ybWFsaXplZFtpbmRpY2VzW2xlbmd0aF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1bUV4cGVjdGVkIC8gc3VtTm9ybWFsaXplZDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvZGUxMjhSZWFkZXI7XG59KGJhcmNvZGVfcmVhZGVyKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvZGVfMTI4X3JlYWRlciA9IChjb2RlXzEyOF9yZWFkZXJfQ29kZTEyOFJlYWRlcik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzXG52YXIgZ2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgZ2V0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGdldCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qc1xudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgdG9Db25zdW1hYmxlQXJyYXlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odG9Db25zdW1hYmxlQXJyYXkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9yZWFkZXIvY29kZV8zOV9yZWFkZXIudHNcblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBjb2RlXzM5X3JlYWRlcl9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gY29kZV8zOV9yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fZGVmYXVsdCgpKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIGNvZGVfMzlfcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG5cblxudmFyIEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLS4gKiQvKyUnO1xudmFyIGNvZGVfMzlfcmVhZGVyX0FMUEhBQkVUID0gbmV3IFVpbnQxNkFycmF5KHRvQ29uc3VtYWJsZUFycmF5X2RlZmF1bHQoKShBTFBIQUJFVEhfU1RSSU5HKS5tYXAoZnVuY3Rpb24gKF9jaGFyKSB7XG4gIHJldHVybiBfY2hhci5jaGFyQ29kZUF0KDApO1xufSkpO1xudmFyIGNvZGVfMzlfcmVhZGVyX0NIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoWzB4MDM0LCAweDEyMSwgMHgwNjEsIDB4MTYwLCAweDAzMSwgMHgxMzAsIDB4MDcwLCAweDAyNSwgMHgxMjQsIDB4MDY0LCAweDEwOSwgMHgwNDksIDB4MTQ4LCAweDAxOSwgMHgxMTgsIDB4MDU4LCAweDAwRCwgMHgxMEMsIDB4MDRDLCAweDAxQywgMHgxMDMsIDB4MDQzLCAweDE0MiwgMHgwMTMsIDB4MTEyLCAweDA1MiwgMHgwMDcsIDB4MTA2LCAweDA0NiwgMHgwMTYsIDB4MTgxLCAweDBDMSwgMHgxQzAsIDB4MDkxLCAweDE5MCwgMHgwRDAsIDB4MDg1LCAweDE4NCwgMHgwQzQsIDB4MDk0LCAweDBBOCwgMHgwQTIsIDB4MDhBLCAweDAyQV0pO1xudmFyIEFTVEVSSVNLID0gMHgwOTQ7XG52YXIgY29kZV8zOV9yZWFkZXJfQ29kZTM5UmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFyY29kZVJlYWRlcikge1xuICBpbmhlcml0c19kZWZhdWx0KCkoQ29kZTM5UmVhZGVyLCBfQmFyY29kZVJlYWRlcik7XG4gIHZhciBfc3VwZXIgPSBjb2RlXzM5X3JlYWRlcl9jcmVhdGVTdXBlcihDb2RlMzlSZWFkZXIpO1xuICBmdW5jdGlvbiBDb2RlMzlSZWFkZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIGNsYXNzQ2FsbENoZWNrX2RlZmF1bHQoKSh0aGlzLCBDb2RlMzlSZWFkZXIpO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKShhc3NlcnRUaGlzSW5pdGlhbGl6ZWRfZGVmYXVsdCgpKF90aGlzKSwgXCJGT1JNQVRcIiwgJ2NvZGVfMzknKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgY3JlYXRlQ2xhc3NfZGVmYXVsdCgpKENvZGUzOVJlYWRlciwgW3tcbiAgICBrZXk6IFwiX2ZpbmRTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZFN0YXJ0KCkge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgIHZhciBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQ7XG4gICAgICB2YXIgY291bnRlciA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgdmFyIGNvdW50ZXJQb3MgPSAwO1xuICAgICAgdmFyIGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgaWYgKHRoaXMuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgdmFyIHdoaXRlU3BhY2VNdXN0U3RhcnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtIChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgZW5kOiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJbMF0gKyBjb3VudGVyWzFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcls3XSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyWzhdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdG9QYXR0ZXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90b1BhdHRlcm4oY291bnRlcnMpIHtcbiAgICAgIHZhciBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgIHZhciBtYXhOYXJyb3dXaWR0aCA9IDA7XG4gICAgICB2YXIgbnVtV2lkZUJhcnMgPSBudW1Db3VudGVycztcbiAgICAgIHZhciB3aWRlQmFyV2lkdGggPSAwO1xuICAgICAgd2hpbGUgKG51bVdpZGVCYXJzID4gMykge1xuICAgICAgICBtYXhOYXJyb3dXaWR0aCA9IHRoaXMuX2ZpbmROZXh0V2lkdGgoY291bnRlcnMsIG1heE5hcnJvd1dpZHRoKTtcbiAgICAgICAgbnVtV2lkZUJhcnMgPSAwO1xuICAgICAgICB2YXIgcGF0dGVybiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA+IG1heE5hcnJvd1dpZHRoKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgcGF0dGVybiB8PSAxIDw8IG51bUNvdW50ZXJzIC0gMSAtIGk7XG4gICAgICAgICAgICBudW1XaWRlQmFycysrO1xuICAgICAgICAgICAgd2lkZUJhcldpZHRoICs9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtV2lkZUJhcnMgPT09IDMpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbnVtQ291bnRlcnMgJiYgbnVtV2lkZUJhcnMgPiAwOyBfaSsrKSB7XG4gICAgICAgICAgICBpZiAoY291bnRlcnNbX2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgbnVtV2lkZUJhcnMtLTtcbiAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW19pXSAqIDIgPj0gd2lkZUJhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kTmV4dFdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kTmV4dFdpZHRoKGNvdW50ZXJzLCBjdXJyZW50KSB7XG4gICAgICB2YXIgbWluV2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY291bnRlcnNbaV0gPCBtaW5XaWR0aCAmJiBjb3VudGVyc1tpXSA+IGN1cnJlbnQpIHtcbiAgICAgICAgICBtaW5XaWR0aCA9IGNvdW50ZXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluV2lkdGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wYXR0ZXJuVG9DaGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZV8zOV9yZWFkZXJfQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY29kZV8zOV9yZWFkZXJfQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVfMzlfcmVhZGVyX0FMUEhBQkVUW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShsYXN0U3RhcnQsIG5leHRTdGFydCwgY291bnRlcnMpIHtcbiAgICAgIHZhciBwYXR0ZXJuU2l6ZSA9IGFycmF5X2hlbHBlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zdW0oY291bnRlcnMpO1xuICAgICAgdmFyIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IG5leHRTdGFydCAtIGxhc3RTdGFydCAtIHBhdHRlcm5TaXplO1xuICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCAqIDMgPj0gcGF0dGVyblNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlY29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGUoKSB7XG4gICAgICB2YXIgY291bnRlcnMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgc3RhcnQuZW5kKTtcbiAgICAgIHZhciBkZWNvZGVkQ2hhcjtcbiAgICAgIHZhciBsYXN0U3RhcnQ7XG4gICAgICBkbyB7XG4gICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKTtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oY291bnRlcnMpO1xuICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICBuZXh0U3RhcnQgKz0gYXJyYXlfaGVscGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1bShjb3VudGVycyk7XG4gICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xuICAgICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgICByZXN1bHQucG9wKCk7XG4gICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShsYXN0U3RhcnQsIG5leHRTdGFydCwgY291bnRlcnMpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvZGUzOVJlYWRlcjtcbn0oYmFyY29kZV9yZWFkZXIpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29kZV8zOV9yZWFkZXIgPSAoY29kZV8zOV9yZWFkZXJfQ29kZTM5UmVhZGVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3JlYWRlci9jb2RlXzMyX3JlYWRlci50c1xuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGNvZGVfMzJfcmVhZGVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBjb2RlXzMyX3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mX2RlZmF1bHQoKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9kZWZhdWx0KCkodGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gY29kZV8zMl9yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIHBhdHRlcm5zID0ge1xuICBBRUlPOiAvW0FFSU9dL2csXG4gIEFaMDk6IC9bQS1aMC05XS9cbn07XG52YXIgY29kZTMyc2V0ID0gJzAxMjM0NTY3ODlCQ0RGR0hKS0xNTlBRUlNUVVZXWFlaJztcbnZhciBjb2RlXzMyX3JlYWRlcl9Db2RlMzJSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db2RlMzlSZWFkZXIpIHtcbiAgaW5oZXJpdHNfZGVmYXVsdCgpKENvZGUzMlJlYWRlciwgX0NvZGUzOVJlYWRlcik7XG4gIHZhciBfc3VwZXIgPSBjb2RlXzMyX3JlYWRlcl9jcmVhdGVTdXBlcihDb2RlMzJSZWFkZXIpO1xuICBmdW5jdGlvbiBDb2RlMzJSZWFkZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIGNsYXNzQ2FsbENoZWNrX2RlZmF1bHQoKSh0aGlzLCBDb2RlMzJSZWFkZXIpO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKShhc3NlcnRUaGlzSW5pdGlhbGl6ZWRfZGVmYXVsdCgpKF90aGlzKSwgXCJGT1JNQVRcIiwgJ2NvZGVfMzJfcmVhZGVyJyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIGNyZWF0ZUNsYXNzX2RlZmF1bHQoKShDb2RlMzJSZWFkZXIsIFt7XG4gICAga2V5OiBcIl9kZWNvZGVDb2RlMzJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY29kZUNvZGUzMihjb2RlKSB7XG4gICAgICBpZiAoL1teMC05QkNERkdISktMTU5QUVJTVFVWV1hZWl0vLnRlc3QoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXMgPSByZXMgKiAzMiArIGNvZGUzMnNldC5pbmRleE9mKGNvZGVbaV0pO1xuICAgICAgfVxuICAgICAgdmFyIGNvZGUzMiA9IFwiXCIuY29uY2F0KHJlcyk7XG4gICAgICBpZiAoY29kZTMyLmxlbmd0aCA8IDkpIHtcbiAgICAgICAgY29kZTMyID0gKCcwMDAwMDAwMDAnICsgY29kZTMyKS5zbGljZSgtOSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ0EnICsgY29kZTMyO1xuICAgIH1cblxuICAgIC8vIFRPRE8gKHRoaXMgd2FzIHRvZG8gaW4gb3JpZ2luYWwgcmVwbywgbm8gdGV4dCB3YXMgdGhlcmUuIHNvcnJ5LilcbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tDaGVja3N1bVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tDaGVja3N1bShjb2RlKSB7XG4gICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdldF9kZWZhdWx0KCkoZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKENvZGUzMlJlYWRlci5wcm90b3R5cGUpLCBcImRlY29kZVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgY29kZSA9IHJlc3VsdC5jb2RlO1xuICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5BRUlPLCAnJyk7XG4gICAgICBpZiAoIXRoaXMuX2NoZWNrQ2hlY2tzdW0oY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgY29kZTMyID0gdGhpcy5fZGVjb2RlQ29kZTMyKGNvZGUpO1xuICAgICAgaWYgKCFjb2RlMzIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXN1bHQuY29kZSA9IGNvZGUzMjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb2RlMzJSZWFkZXI7XG59KGNvZGVfMzlfcmVhZGVyKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvZGVfMzJfcmVhZGVyID0gKGNvZGVfMzJfcmVhZGVyX0NvZGUzMlJlYWRlcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9yZWFkZXIvY29kZV8zOV92aW5fcmVhZGVyLnRzXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gY29kZV8zOV92aW5fcmVhZGVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBjb2RlXzM5X3Zpbl9yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fZGVmYXVsdCgpKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIGNvZGVfMzlfdmluX3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuXG5cbnZhciBjb2RlXzM5X3Zpbl9yZWFkZXJfcGF0dGVybnMgPSB7XG4gIElPUTogL1tJT1FdL2csXG4gIEFaMDk6IC9bQS1aMC05XXsxN30vXG59O1xudmFyIGNvZGVfMzlfdmluX3JlYWRlcl9Db2RlMzlWSU5SZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db2RlMzlSZWFkZXIpIHtcbiAgaW5oZXJpdHNfZGVmYXVsdCgpKENvZGUzOVZJTlJlYWRlciwgX0NvZGUzOVJlYWRlcik7XG4gIHZhciBfc3VwZXIgPSBjb2RlXzM5X3Zpbl9yZWFkZXJfY3JlYXRlU3VwZXIoQ29kZTM5VklOUmVhZGVyKTtcbiAgZnVuY3Rpb24gQ29kZTM5VklOUmVhZGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBjbGFzc0NhbGxDaGVja19kZWZhdWx0KCkodGhpcywgQ29kZTM5VklOUmVhZGVyKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwuYXBwbHkoX3N1cGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiRk9STUFUXCIsICdjb2RlXzM5X3ZpbicpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBjcmVhdGVDbGFzc19kZWZhdWx0KCkoQ29kZTM5VklOUmVhZGVyLCBbe1xuICAgIGtleTogXCJfY2hlY2tDaGVja3N1bVwiLFxuICAgIHZhbHVlOlxuICAgIC8vIFRPRE8gKHRoaXMgd2FzIHRvZG8gaW4gb3JpZ2luYWwgcmVwbywgbm8gdGV4dCB3YXMgdGhlcmUuIHNvcnJ5LilcbiAgICBmdW5jdGlvbiBfY2hlY2tDaGVja3N1bShjb2RlKSB7XG4gICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cblxuICAgIC8vIENyaWJiZWQgZnJvbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi9tYXN0ZXIvY29yZS9zcmMvbWFpbi9qYXZhL2NvbS9nb29nbGUvenhpbmcvY2xpZW50L3Jlc3VsdC9WSU5SZXN1bHRQYXJzZXIuamF2YVxuICB9LCB7XG4gICAga2V5OiBcImRlY29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0X2RlZmF1bHQoKShnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkoQ29kZTM5VklOUmVhZGVyLnByb3RvdHlwZSksIFwiZGVjb2RlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG4gICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb2RlID0gY29kZS5yZXBsYWNlKGNvZGVfMzlfdmluX3JlYWRlcl9wYXR0ZXJucy5JT1EsICcnKTtcbiAgICAgIGlmICghY29kZS5tYXRjaChjb2RlXzM5X3Zpbl9yZWFkZXJfcGF0dGVybnMuQVowOSkpIHtcbiAgICAgICAgaWYgKGZhbHNlKSB7fVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb2RlMzlWSU5SZWFkZXI7XG59KGNvZGVfMzlfcmVhZGVyKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvZGVfMzlfdmluX3JlYWRlciA9IChjb2RlXzM5X3Zpbl9yZWFkZXJfQ29kZTM5VklOUmVhZGVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3JlYWRlci9jb2RlXzkzX3JlYWRlci50c1xuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGNvZGVfOTNfcmVhZGVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBjb2RlXzkzX3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mX2RlZmF1bHQoKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9kZWZhdWx0KCkodGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gY29kZV85M19yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuXG52YXIgY29kZV85M19yZWFkZXJfQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslYWJjZConO1xudmFyIGNvZGVfOTNfcmVhZGVyX0FMUEhBQkVUID0gbmV3IFVpbnQxNkFycmF5KHRvQ29uc3VtYWJsZUFycmF5X2RlZmF1bHQoKShjb2RlXzkzX3JlYWRlcl9BTFBIQUJFVEhfU1RSSU5HKS5tYXAoZnVuY3Rpb24gKF9jaGFyKSB7XG4gIHJldHVybiBfY2hhci5jaGFyQ29kZUF0KDApO1xufSkpO1xudmFyIGNvZGVfOTNfcmVhZGVyX0NIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoWzB4MTE0LCAweDE0OCwgMHgxNDQsIDB4MTQyLCAweDEyOCwgMHgxMjQsIDB4MTIyLCAweDE1MCwgMHgxMTIsIDB4MTBBLCAweDFBOCwgMHgxQTQsIDB4MUEyLCAweDE5NCwgMHgxOTIsIDB4MThBLCAweDE2OCwgMHgxNjQsIDB4MTYyLCAweDEzNCwgMHgxMUEsIDB4MTU4LCAweDE0QywgMHgxNDYsIDB4MTJDLCAweDExNiwgMHgxQjQsIDB4MUIyLCAweDFBQywgMHgxQTYsIDB4MTk2LCAweDE5QSwgMHgxNkMsIDB4MTY2LCAweDEzNiwgMHgxM0EsIDB4MTJFLCAweDFENCwgMHgxRDIsIDB4MUNBLCAweDE2RSwgMHgxNzYsIDB4MUFFLCAweDEyNiwgMHgxREEsIDB4MUQ2LCAweDEzMiwgMHgxNUVdKTtcbnZhciBjb2RlXzkzX3JlYWRlcl9BU1RFUklTSyA9IDB4MTVFO1xudmFyIGNvZGVfOTNfcmVhZGVyX0NvZGU5M1JlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0JhcmNvZGVSZWFkZXIpIHtcbiAgaW5oZXJpdHNfZGVmYXVsdCgpKENvZGU5M1JlYWRlciwgX0JhcmNvZGVSZWFkZXIpO1xuICB2YXIgX3N1cGVyID0gY29kZV85M19yZWFkZXJfY3JlYXRlU3VwZXIoQ29kZTkzUmVhZGVyKTtcbiAgZnVuY3Rpb24gQ29kZTkzUmVhZGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBjbGFzc0NhbGxDaGVja19kZWZhdWx0KCkodGhpcywgQ29kZTkzUmVhZGVyKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwuYXBwbHkoX3N1cGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiRk9STUFUXCIsICdjb2RlXzkzJyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIGNyZWF0ZUNsYXNzX2RlZmF1bHQoKShDb2RlOTNSZWFkZXIsIFt7XG4gICAga2V5OiBcIl9wYXR0ZXJuVG9DaGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZV85M19yZWFkZXJfQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY29kZV85M19yZWFkZXJfQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVfOTNfcmVhZGVyX0FMUEhBQkVUW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90b1BhdHRlcm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RvUGF0dGVybihjb3VudGVycykge1xuICAgICAgdmFyIG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgdmFyIHN1bSA9IGNvdW50ZXJzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgICAgICByZXR1cm4gcHJldiArIG5leHQ7XG4gICAgICB9LCAwKTtcbiAgICAgIHZhciBwYXR0ZXJuID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IE1hdGgucm91bmQoY291bnRlcnNbaV0gKiA5IC8gc3VtKTtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPCAxIHx8IG5vcm1hbGl6ZWQgPiA0KSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaSAmIDEpID09PSAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3JtYWxpemVkOyBqKyspIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuIDw8IDEgfCAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXR0ZXJuIDw8PSBub3JtYWxpemVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZFN0YXJ0KCkge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgIHZhciBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQ7XG4gICAgICB2YXIgY291bnRlciA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgdmFyIGNvdW50ZXJQb3MgPSAwO1xuICAgICAgdmFyIGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgaWYgKHRoaXMuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gY29kZV85M19yZWFkZXJfQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgdmFyIHdoaXRlU3BhY2VNdXN0U3RhcnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtIChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgZW5kOiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJbMF0gKyBjb3VudGVyWzFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdmVyaWZ5RW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92ZXJpZnlFbmQobGFzdFN0YXJ0LCBuZXh0U3RhcnQpIHtcbiAgICAgIGlmIChsYXN0U3RhcnQgPT09IG5leHRTdGFydCB8fCAhdGhpcy5fcm93W25leHRTdGFydF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZWNvZGVFeHRlbmRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjb2RlRXh0ZW5kZWQoY2hhckFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY2hhckFycmF5Lmxlbmd0aDtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9jaGFyMiA9IGNoYXJBcnJheVtpXTtcbiAgICAgICAgaWYgKF9jaGFyMiA+PSAnYScgJiYgX2NoYXIyIDw9ICdkJykge1xuICAgICAgICAgIGlmIChpID4gbGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZXh0Q2hhciA9IGNoYXJBcnJheVsrK2ldO1xuICAgICAgICAgIHZhciBuZXh0Q2hhckNvZGUgPSBuZXh0Q2hhci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIHZhciBkZWNvZGVkQ2hhciA9IHZvaWQgMDtcbiAgICAgICAgICBzd2l0Y2ggKF9jaGFyMikge1xuICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDY0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdFJykge1xuICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzOCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0YnICYmIG5leHRDaGFyIDw9ICdKJykge1xuICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAxMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0snICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAxNik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1AnICYmIG5leHRDaGFyIDw9ICdTJykge1xuICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyA0Myk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1QnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ08nKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDMyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMzIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIGNvZGVfOTNfcmVhZGVyIF9kZWNvZGVFeHRlbmRlZCBoaXQgZGVmYXVsdCBjYXNlLCB0aGlzIG1heSBiZSBhbiBlcnJvcicsIGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChfY2hhcjIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbWF0Y2hDaGVja0NoYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgaW5kZXgsIG1heFdlaWdodCkge1xuICAgICAgdmFyIGFycmF5VG9DaGVjayA9IGNoYXJBcnJheS5zbGljZSgwLCBpbmRleCk7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlUb0NoZWNrLmxlbmd0aDtcbiAgICAgIHZhciB3ZWlnaHRlZFN1bXMgPSBhcnJheVRvQ2hlY2sucmVkdWNlKGZ1bmN0aW9uIChzdW0sIF9jaGFyMywgaSkge1xuICAgICAgICB2YXIgd2VpZ2h0ID0gKGkgKiAtMSArIChsZW5ndGggLSAxKSkgJSBtYXhXZWlnaHQgKyAxO1xuICAgICAgICB2YXIgdmFsdWUgPSBjb2RlXzkzX3JlYWRlcl9BTFBIQUJFVC5pbmRleE9mKF9jaGFyMy5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgcmV0dXJuIHN1bSArIHdlaWdodCAqIHZhbHVlO1xuICAgICAgfSwgMCk7XG4gICAgICB2YXIgY2hlY2tDaGFyID0gY29kZV85M19yZWFkZXJfQUxQSEFCRVRbd2VpZ2h0ZWRTdW1zICUgNDddO1xuICAgICAgcmV0dXJuIGNoZWNrQ2hhciA9PT0gY2hhckFycmF5W2luZGV4XS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdmVyaWZ5Q2hlY2tzdW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92ZXJpZnlDaGVja3N1bXMoY2hhckFycmF5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMiwgMjApICYmIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDEsIDE1KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZShyb3csIHN0YXJ0KSB7XG4gICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjb3VudGVycyA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBzdGFydC5lbmQpO1xuICAgICAgdmFyIGxhc3RTdGFydDtcbiAgICAgIHZhciBkZWNvZGVkQ2hhcjtcbiAgICAgIGRvIHtcbiAgICAgICAgY291bnRlcnMgPSB0aGlzLl90b0NvdW50ZXJzKG5leHRTdGFydCwgY291bnRlcnMpO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihjb3VudGVycyk7XG4gICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgIG5leHRTdGFydCArPSBhcnJheV9oZWxwZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG5leHRTdGFydCk7XG4gICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fdmVyaWZ5RW5kKGxhc3RTdGFydCwgbmV4dFN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q2hlY2tzdW1zKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICAgICAgLy8geWVzLCB0aGlzIGlzIGFuIGFzc2lnbiBpbnNpZGUgYW4gaWYuXG4gICAgICBpZiAoKHJlc3VsdCA9IHRoaXMuX2RlY29kZUV4dGVuZGVkKHJlc3VsdCkpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvZGU5M1JlYWRlcjtcbn0oYmFyY29kZV9yZWFkZXIpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29kZV85M19yZWFkZXIgPSAoY29kZV85M19yZWFkZXJfQ29kZTkzUmVhZGVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLnRzXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gZWFuX3JlYWRlcl9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZWFuX3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mX2RlZmF1bHQoKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9kZWZhdWx0KCkodGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gZWFuX3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5cblxuLy8gY29uc3QgQ09ERV9MX1NUQVJUID0gMDtcbnZhciBDT0RFX0dfU1RBUlQgPSAxMDtcblxudmFyIGVhbl9yZWFkZXJfU1RBUlRfUEFUVEVSTiA9IFsxLCAxLCAxXTtcbnZhciBNSURETEVfUEFUVEVSTiA9IFsxLCAxLCAxLCAxLCAxXTtcblxudmFyIEVYVEVOU0lPTl9TVEFSVF9QQVRURVJOID0gWzEsIDEsIDJdO1xudmFyIGVhbl9yZWFkZXJfQ09ERV9QQVRURVJOID0gW1szLCAyLCAxLCAxXSwgWzIsIDIsIDIsIDFdLCBbMiwgMSwgMiwgMl0sIFsxLCA0LCAxLCAxXSwgWzEsIDEsIDMsIDJdLCBbMSwgMiwgMywgMV0sIFsxLCAxLCAxLCA0XSwgWzEsIDMsIDEsIDJdLCBbMSwgMiwgMSwgM10sIFszLCAxLCAxLCAyXSwgWzEsIDEsIDIsIDNdLCBbMSwgMiwgMiwgMl0sIFsyLCAyLCAxLCAyXSwgWzEsIDEsIDQsIDFdLCBbMiwgMywgMSwgMV0sIFsxLCAzLCAyLCAxXSwgWzQsIDEsIDEsIDFdLCBbMiwgMSwgMywgMV0sIFszLCAxLCAyLCAxXSwgWzIsIDEsIDEsIDNdXTtcbnZhciBDT0RFX0ZSRVFVRU5DWSA9IFswLCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XTtcbi8vIGNvbnN0IFNJTkdMRV9DT0RFX0VSUk9SID0gMC43MDtcbnZhciBBVkdfQ09ERV9FUlJPUiA9IDAuNDg7XG52YXIgZWFuX3JlYWRlcl9FQU5SZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXJjb2RlUmVhZGVyKSB7XG4gIGluaGVyaXRzX2RlZmF1bHQoKShFQU5SZWFkZXIsIF9CYXJjb2RlUmVhZGVyKTtcbiAgdmFyIF9zdXBlciA9IGVhbl9yZWFkZXJfY3JlYXRlU3VwZXIoRUFOUmVhZGVyKTtcbiAgLy8gVE9ETzogZG9lcyB0aGlzIG5lZWQgdG8gYmUgaW4gdGhlIGNsYXNzP1xuXG4gIGZ1bmN0aW9uIEVBTlJlYWRlcihjb25maWcsIHN1cHBsZW1lbnRzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIGNsYXNzQ2FsbENoZWNrX2RlZmF1bHQoKSh0aGlzLCBFQU5SZWFkZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVyZ2VfZGVmYXVsdCgpKHtcbiAgICAgIHN1cHBsZW1lbnRzOiBbXVxuICAgIH0sIGNvbmZpZyksIHN1cHBsZW1lbnRzKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiRk9STUFUXCIsICdlYW5fMTMnKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiU0lOR0xFX0NPREVfRVJST1JcIiwgMC43MCk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIlNUT1BfUEFUVEVSTlwiLCBbMSwgMSwgMV0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBjcmVhdGVDbGFzc19kZWZhdWx0KCkoRUFOUmVhZGVyLCBbe1xuICAgIGtleTogXCJfZmluZFBhdHRlcm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRQYXR0ZXJuKHBhdHRlcm4sIG9mZnNldCwgaXNXaGl0ZSwgdHJ5SGFyZGVyKSB7XG4gICAgICB2YXIgY291bnRlciA9IG5ldyBBcnJheShwYXR0ZXJuLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgIHZhciBiZXN0TWF0Y2ggPSB7XG4gICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiAwXG4gICAgICB9O1xuICAgICAgdmFyIGVwc2lsb24gPSBBVkdfQ09ERV9FUlJPUjtcbiAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kUGF0dGVybicsIHBhdHRlcm4sIG9mZnNldCwgaXNXaGl0ZSwgdHJ5SGFyZGVyLCBlcHNpbG9uKTtcbiAgICAgIHZhciBjb3VudGVyUG9zID0gMDtcbiAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgIH1cbiAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oYCogbG9vcCBpPSR7b2Zmc2V0fSBsZW49JHt0aGlzLl9yb3cubGVuZ3RofSBpc1doaXRlPSR7aXNXaGl0ZX0gY291bnRlclBvcz0ke2NvdW50ZXJQb3N9YCk7XG4gICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogbWF0Y2hQYXR0ZXJuJywgZXJyb3IsIGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbiAmJiBiZXN0TWF0Y2guZXJyb3IgJiYgZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIGNvdW50ZXIucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIHZhbHVlO1xuICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3VuZCA/IGJlc3RNYXRjaCA6IG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogZmluZFBhdHRlcm4gYW5kIGRlY29kZUNvZGUgYXBwZWFyIHRvIHNoYXJlIHF1aXRlIHNpbWlsYXIgY29kZSwgY2FuIGl0IGJlIHJlZHVjZWQ/XG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlY29kZUNvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY29kZUNvZGUoc3RhcnQsIGNvZGVyYW5nZSkge1xuICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUnLCBzdGFydCwgY29kZXJhbmdlKTtcbiAgICAgIHZhciBjb3VudGVyID0gWzAsIDAsIDAsIDBdO1xuICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0O1xuICAgICAgdmFyIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIGNvZGU6IC0xLFxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogc3RhcnRcbiAgICAgIH07XG4gICAgICB2YXIgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xuICAgICAgdmFyIGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XG4gICAgICB2YXIgY291bnRlclBvcyA9IDA7XG4gICAgICBpZiAoIWNvZGVyYW5nZSkge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZSBiZWZvcmUgbGVuZ3RoJyk7XG4gICAgICAgIGNvZGVyYW5nZSA9IGVhbl9yZWFkZXJfQ09ERV9QQVRURVJOLmxlbmd0aDtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUgYWZ0ZXIgbGVuZ3RoJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgY29kZSA9IDA7IGNvZGUgPCBjb2RlcmFuZ2U7IGNvZGUrKykge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgZWFuX3JlYWRlcl9DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3VuZCA/IGJlc3RNYXRjaCA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRTdGFydCgpIHtcbiAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kU3RhcnQnKTtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICB2YXIgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKGVhbl9yZWFkZXJfU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBzdGFydEluZm89JywgSlNPTi5zdHJpbmdpZnkoc3RhcnRJbmZvKSk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSAoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCk7XG4gICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nIHN0YXJ0SW5mbycpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcgbnVsbCcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVGaXJzdERpZ2l0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGaXJzdERpZ2l0KGNvZGVGcmVxdWVuY3kpIHtcbiAgICAgIC8vIGNvbnNvbGUud2FybignKiBjYWxjdWxhdGVGaXJzdERpZ2l0JywgY29kZUZyZXF1ZW5jeSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IENPREVfRlJFUVVFTkNZLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBDT0RFX0ZSRVFVRU5DWVtpXSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCBpKTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlY29kZVBheWxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY29kZVBheWxvYWQoaW5Db2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcykge1xuICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBheWxvYWQnLCBpbkNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgIHZhciBvdXRDb2RlID0gX29iamVjdFNwcmVhZCh7fSwgaW5Db2RlKTtcbiAgICAgIHZhciBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgb3V0Q29kZSA9IHRoaXMuX2RlY29kZUNvZGUob3V0Q29kZS5lbmQpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBvdXRDb2RlKTtcbiAgICAgICAgaWYgKCFvdXRDb2RlKSB7XG4gICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dENvZGUuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICBvdXRDb2RlLmNvZGUgLT0gQ09ERV9HX1NUQVJUO1xuICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCA1IC0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDAgPDwgNSAtIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gob3V0Q29kZS5jb2RlKTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gob3V0Q29kZSk7XG4gICAgICB9XG4gICAgICB2YXIgZmlyc3REaWdpdCA9IHRoaXMuX2NhbGN1bGF0ZUZpcnN0RGlnaXQoY29kZUZyZXF1ZW5jeSk7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJyogZmlyc3REaWdpdD0nLCBmaXJzdERpZ2l0KTtcbiAgICAgIGlmIChmaXJzdERpZ2l0ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC51bnNoaWZ0KGZpcnN0RGlnaXQpO1xuICAgICAgdmFyIG1pZGRsZVBhdHRlcm4gPSB0aGlzLl9maW5kUGF0dGVybihNSURETEVfUEFUVEVSTiwgb3V0Q29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kUGF0dGVybj0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG5cbiAgICAgIGlmIChtaWRkbGVQYXR0ZXJuID09PSBudWxsIHx8ICFtaWRkbGVQYXR0ZXJuLmVuZCkge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBkZWNvZGVkQ29kZXMucHVzaChtaWRkbGVQYXR0ZXJuKTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCA2OyBfaSsrKSB7XG4gICAgICAgIG1pZGRsZVBhdHRlcm4gPSB0aGlzLl9kZWNvZGVDb2RlKG1pZGRsZVBhdHRlcm4uZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG5cbiAgICAgICAgaWYgKCFtaWRkbGVQYXR0ZXJuKSB7XG4gICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gobWlkZGxlUGF0dGVybik7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1pZGRsZVBhdHRlcm4uY29kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgY29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIHJlc3VsdD0nLCBKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlZENvZGVzPScsIGRlY29kZWRDb2Rlcyk7XG4gICAgICByZXR1cm4gbWlkZGxlUGF0dGVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIHtcbiAgICAgIC8vIGNvbnNvbGUud2FybignKiB2ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UnLCBKU09OLnN0cmluZ2lmeShlbmRJbmZvKSk7XG4gICAgICB2YXIgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KTtcbiAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIEpTT04uc3RyaW5naWZ5KGVuZEluZm8pKTtcbiAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRFbmQob2Zmc2V0LCBpc1doaXRlKSB7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZEVuZCcsIG9mZnNldCwgaXNXaGl0ZSk7XG4gICAgICB2YXIgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOLCBvZmZzZXQsIGlzV2hpdGUsIGZhbHNlKTtcbiAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrc3VtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja3N1bShyZXN1bHQpIHtcbiAgICAgIC8vIGNvbnNvbGUud2FybignKiBfY2hlY2tzdW0nLCByZXN1bHQpO1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gcmVzdWx0Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgICB9XG4gICAgICBzdW0gKj0gMztcbiAgICAgIGZvciAodmFyIF9pMiA9IHJlc3VsdC5sZW5ndGggLSAxOyBfaTIgPj0gMDsgX2kyIC09IDIpIHtcbiAgICAgICAgc3VtICs9IHJlc3VsdFtfaTJdO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGNoZWNrc3VtJywgc3VtICUgMTAgPT09IDApO1xuICAgICAgcmV0dXJuIHN1bSAlIDEwID09PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVjb2RlRXh0ZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjb2RlRXh0ZW5zaW9ucyhvZmZzZXQpIHtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgdmFyIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKEVYVEVOU0lPTl9TVEFSVF9QQVRURVJOLCBzdGFydCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVFeHRlbnNpb25zJywgdGhpcy5zdXBwbGVtZW50cyk7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJyogdGhlcmUgYXJlICcsIHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoLCAnIHN1cHBsZW1lbnRzJyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGV4dGVuc2lvbnMgbG9vcCcsIGksIHRoaXMuc3VwcGxlbWVudHNbaV0sIHRoaXMuc3VwcGxlbWVudHNbaV0uX2RlY29kZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc3VwcGxlbWVudHNbaV0uZGVjb2RlKHRoaXMuX3Jvdywgc3RhcnRJbmZvLmVuZCk7XG4gICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZSByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuY29kZSxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgICAgICAgZW5kOiByZXN1bHQuZW5kLFxuICAgICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdC5kZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5zdXBwbGVtZW50c1tpXS5GT1JNQVRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIGRlY29kZUV4dGVuc2lvbnMgZXJyb3IgaW4gJywgdGhpcy5zdXBwbGVtZW50c1tpXSwgJzogJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGRlY29kZUV4dGVuc2lvbnMnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlKHJvdywgc3RhcnQpIHtcbiAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUnLCByb3cpO1xuICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHN0YXJ0KTtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoKTtcbiAgICAgIHZhciBkZWNvZGVkQ29kZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgIHZhciByZXN1bHRJbmZvID0ge307XG4gICAgICB2YXIgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlID0ge1xuICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICBlbmQ6IHN0YXJ0SW5mby5lbmRcbiAgICAgIH07XG4gICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgIGlmICghY29kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvZGUgPSB0aGlzLl9maW5kRW5kKGNvZGUuZW5kLCBmYWxzZSk7XG4gICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgLy8gQ2hlY2tzdW1cbiAgICAgIGlmICghdGhpcy5fY2hlY2tzdW0ocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS53YXJuKCcqIHRoaXMuc3VwcGxlbWVudHM9JywgdGhpcy5zdXBwbGVtZW50cyk7XG4gICAgICBpZiAodGhpcy5zdXBwbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzdXBwbGVtZW50ID0gdGhpcy5fZGVjb2RlRXh0ZW5zaW9ucyhjb2RlLmVuZCk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVFeHRlbnNpb25zIHJldHVybnMnLCBzdXBwbGVtZW50KTtcbiAgICAgICAgaWYgKCFzdXBwbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdXBwbGVtZW50LmRlY29kZWRDb2Rlcykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0Q29kZSA9IHN1cHBsZW1lbnQuZGVjb2RlZENvZGVzW3N1cHBsZW1lbnQuZGVjb2RlZENvZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgZW5kSW5mbyA9IHtcbiAgICAgICAgICBzdGFydDogbGFzdENvZGUuc3RhcnQgKyAoKGxhc3RDb2RlLmVuZCAtIGxhc3RDb2RlLnN0YXJ0KSAvIDIgfCAwKSxcbiAgICAgICAgICBlbmQ6IGxhc3RDb2RlLmVuZFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdEluZm8gPSB7XG4gICAgICAgICAgc3VwcGxlbWVudDogc3VwcGxlbWVudCxcbiAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJykgKyBzdXBwbGVtZW50LmNvZGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgIGVuZDogY29kZS5lbmQsXG4gICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxuICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2Rlc1xuICAgICAgfSwgcmVzdWx0SW5mbyksIHt9LCB7XG4gICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRUFOUmVhZGVyO1xufShiYXJjb2RlX3JlYWRlcik7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBlYW5fcmVhZGVyID0gKGVhbl9yZWFkZXJfRUFOUmVhZGVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3JlYWRlci9lYW5fMl9yZWFkZXIudHNcblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZWFuXzJfcmVhZGVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBlYW5fMl9yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fZGVmYXVsdCgpKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIGVhbl8yX3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgZWFuXzJfcmVhZGVyX0VBTjJSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FQU5SZWFkZXIpIHtcbiAgaW5oZXJpdHNfZGVmYXVsdCgpKEVBTjJSZWFkZXIsIF9FQU5SZWFkZXIpO1xuICB2YXIgX3N1cGVyID0gZWFuXzJfcmVhZGVyX2NyZWF0ZVN1cGVyKEVBTjJSZWFkZXIpO1xuICBmdW5jdGlvbiBFQU4yUmVhZGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBjbGFzc0NhbGxDaGVja19kZWZhdWx0KCkodGhpcywgRUFOMlJlYWRlcik7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIkZPUk1BVFwiLCAnZWFuXzInKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgY3JlYXRlQ2xhc3NfZGVmYXVsdCgpKEVBTjJSZWFkZXIsIFt7XG4gICAga2V5OiBcImRlY29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGUocm93LCBzdGFydCkge1xuICAgICAgaWYgKHJvdykge1xuICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgICB9XG4gICAgICB2YXIgY29kZUZyZXF1ZW5jeSA9IDA7XG4gICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICB2YXIgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgIHZhciBjb2RlID0gbnVsbDtcbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMiAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICUgMTApO1xuICAgICAgICBpZiAoY29kZS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAxIC0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSAhPT0gMSkge1xuICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDIgfHwgcGFyc2VJbnQocmVzdWx0LmpvaW4oJycpKSAlIDQgIT09IGNvZGVGcmVxdWVuY3kpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVBTjJSZWFkZXI7XG59KGVhbl9yZWFkZXIpO1xuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZWFuXzJfcmVhZGVyID0gKGVhbl8yX3JlYWRlcl9FQU4yUmVhZGVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3JlYWRlci9lYW5fNV9yZWFkZXIudHNcblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZWFuXzVfcmVhZGVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBlYW5fNV9yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fZGVmYXVsdCgpKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIGVhbl81X3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgQ0hFQ0tfRElHSVRfRU5DT0RJTkdTID0gWzI0LCAyMCwgMTgsIDE3LCAxMiwgNiwgMywgMTAsIDksIDVdO1xuZnVuY3Rpb24gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBDSEVDS19ESUdJVF9FTkNPRElOR1NbaV0pIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdCkge1xuICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgdmFyIHN1bSA9IDA7XG4gIGZvciAodmFyIGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgIHN1bSArPSByZXN1bHRbaV07XG4gIH1cbiAgc3VtICo9IDM7XG4gIGZvciAodmFyIF9pID0gbGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2kgLT0gMikge1xuICAgIHN1bSArPSByZXN1bHRbX2ldO1xuICB9XG4gIHN1bSAqPSAzO1xuICByZXR1cm4gc3VtICUgMTA7XG59XG52YXIgZWFuXzVfcmVhZGVyX0VBTjVSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FQU5SZWFkZXIpIHtcbiAgaW5oZXJpdHNfZGVmYXVsdCgpKEVBTjVSZWFkZXIsIF9FQU5SZWFkZXIpO1xuICB2YXIgX3N1cGVyID0gZWFuXzVfcmVhZGVyX2NyZWF0ZVN1cGVyKEVBTjVSZWFkZXIpO1xuICBmdW5jdGlvbiBFQU41UmVhZGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBjbGFzc0NhbGxDaGVja19kZWZhdWx0KCkodGhpcywgRUFONVJlYWRlcik7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIkZPUk1BVFwiLCAnZWFuXzUnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgY3JlYXRlQ2xhc3NfZGVmYXVsdCgpKEVBTjVSZWFkZXIsIFt7XG4gICAga2V5OiBcImRlY29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGUocm93LCBzdGFydCkge1xuICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocm93KSB7XG4gICAgICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlRnJlcXVlbmN5ID0gMDtcbiAgICAgIHZhciBvZmZzZXQgPSBzdGFydDtcbiAgICAgIHZhciBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgdmFyIGNvZGUgPSBudWxsO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGRlY29kZWRDb2RlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1ICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XG4gICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8IDQgLSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpICE9PSA0KSB7XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gNSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChleHRlbnNpb25DaGVja3N1bShyZXN1bHQpICE9PSBkZXRlcm1pbmVDaGVja0RpZ2l0KGNvZGVGcmVxdWVuY3kpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcbiAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnRcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFQU41UmVhZGVyO1xufShlYW5fcmVhZGVyKTtcbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGVhbl81X3JlYWRlciA9IChlYW5fNV9yZWFkZXJfRUFONVJlYWRlcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLnRzXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGVhbl84X3JlYWRlcl9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZWFuXzhfcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mX2RlZmF1bHQoKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX2RlZmF1bHQoKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBlYW5fOF9yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIGVhbl84X3JlYWRlcl9FQU44UmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRUFOUmVhZGVyKSB7XG4gIGluaGVyaXRzX2RlZmF1bHQoKShFQU44UmVhZGVyLCBfRUFOUmVhZGVyKTtcbiAgdmFyIF9zdXBlciA9IGVhbl84X3JlYWRlcl9jcmVhdGVTdXBlcihFQU44UmVhZGVyKTtcbiAgZnVuY3Rpb24gRUFOOFJlYWRlcigpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgY2xhc3NDYWxsQ2hlY2tfZGVmYXVsdCgpKHRoaXMsIEVBTjhSZWFkZXIpO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKShhc3NlcnRUaGlzSW5pdGlhbGl6ZWRfZGVmYXVsdCgpKF90aGlzKSwgXCJGT1JNQVRcIiwgJ2Vhbl84Jyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIGNyZWF0ZUNsYXNzX2RlZmF1bHQoKShFQU44UmVhZGVyLCBbe1xuICAgIGtleTogXCJfZGVjb2RlUGF5bG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjb2RlUGF5bG9hZChpbkNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKSB7XG4gICAgICB2YXIgY29kZSA9IGluQ29kZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgIH1cbiAgICAgIGNvZGUgPSB0aGlzLl9maW5kUGF0dGVybihNSURETEVfUEFUVEVSTiwgY29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgNDsgX2krKykge1xuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVBTjhSZWFkZXI7XG59KGVhbl9yZWFkZXIpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZWFuXzhfcmVhZGVyID0gKGVhbl84X3JlYWRlcl9FQU44UmVhZGVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3JlYWRlci9pMm9mNV9yZWFkZXIudHNcblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBpMm9mNV9yZWFkZXJfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGkyb2Y1X3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGdldFByb3RvdHlwZU9mX2RlZmF1bHQoKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9kZWZhdWx0KCkodGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gaTJvZjVfcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG4vLyBUT0RPOiBpMm9mNV9yZWFkZXIgYW5kIDJvZjVfcmVhZGVyIHNoYXJlIHZlcnkgc2ltaWxhciBjb2RlLCBtYWtlIHVzZSBvZiB0aGF0XG5cblxuXG52YXIgaTJvZjVfcmVhZGVyX04gPSAxO1xudmFyIGkyb2Y1X3JlYWRlcl9XID0gMztcbnZhciBpMm9mNV9yZWFkZXJfSTJvZjVSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXJjb2RlUmVhZGVyKSB7XG4gIGluaGVyaXRzX2RlZmF1bHQoKShJMm9mNVJlYWRlciwgX0JhcmNvZGVSZWFkZXIpO1xuICB2YXIgX3N1cGVyID0gaTJvZjVfcmVhZGVyX2NyZWF0ZVN1cGVyKEkyb2Y1UmVhZGVyKTtcbiAgZnVuY3Rpb24gSTJvZjVSZWFkZXIob3B0cykge1xuICAgIHZhciBfdGhpcztcbiAgICBjbGFzc0NhbGxDaGVja19kZWZhdWx0KCkodGhpcywgSTJvZjVSZWFkZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVyZ2VfZGVmYXVsdCgpKHtcbiAgICAgIG5vcm1hbGl6ZUJhclNwYWNlV2lkdGg6IGZhbHNlXG4gICAgfSwgb3B0cykpO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKShhc3NlcnRUaGlzSW5pdGlhbGl6ZWRfZGVmYXVsdCgpKF90aGlzKSwgXCJiYXJTcGFjZVJhdGlvXCIsIFsxLCAxXSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIlNJTkdMRV9DT0RFX0VSUk9SXCIsIDAuNzgpO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKShhc3NlcnRUaGlzSW5pdGlhbGl6ZWRfZGVmYXVsdCgpKF90aGlzKSwgXCJBVkdfQ09ERV9FUlJPUlwiLCAwLjM4KTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiU1RBUlRfUEFUVEVSTlwiLCBbaTJvZjVfcmVhZGVyX04sIGkyb2Y1X3JlYWRlcl9OLCBpMm9mNV9yZWFkZXJfTiwgaTJvZjVfcmVhZGVyX05dKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiU1RPUF9QQVRURVJOXCIsIFtpMm9mNV9yZWFkZXJfTiwgaTJvZjVfcmVhZGVyX04sIGkyb2Y1X3JlYWRlcl9XXSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIkNPREVfUEFUVEVSTlwiLCBbW2kyb2Y1X3JlYWRlcl9OLCBpMm9mNV9yZWFkZXJfTiwgaTJvZjVfcmVhZGVyX1csIGkyb2Y1X3JlYWRlcl9XLCBpMm9mNV9yZWFkZXJfTl0sIFtpMm9mNV9yZWFkZXJfVywgaTJvZjVfcmVhZGVyX04sIGkyb2Y1X3JlYWRlcl9OLCBpMm9mNV9yZWFkZXJfTiwgaTJvZjVfcmVhZGVyX1ddLCBbaTJvZjVfcmVhZGVyX04sIGkyb2Y1X3JlYWRlcl9XLCBpMm9mNV9yZWFkZXJfTiwgaTJvZjVfcmVhZGVyX04sIGkyb2Y1X3JlYWRlcl9XXSwgW2kyb2Y1X3JlYWRlcl9XLCBpMm9mNV9yZWFkZXJfVywgaTJvZjVfcmVhZGVyX04sIGkyb2Y1X3JlYWRlcl9OLCBpMm9mNV9yZWFkZXJfTl0sIFtpMm9mNV9yZWFkZXJfTiwgaTJvZjVfcmVhZGVyX04sIGkyb2Y1X3JlYWRlcl9XLCBpMm9mNV9yZWFkZXJfTiwgaTJvZjVfcmVhZGVyX1ddLCBbaTJvZjVfcmVhZGVyX1csIGkyb2Y1X3JlYWRlcl9OLCBpMm9mNV9yZWFkZXJfVywgaTJvZjVfcmVhZGVyX04sIGkyb2Y1X3JlYWRlcl9OXSwgW2kyb2Y1X3JlYWRlcl9OLCBpMm9mNV9yZWFkZXJfVywgaTJvZjVfcmVhZGVyX1csIGkyb2Y1X3JlYWRlcl9OLCBpMm9mNV9yZWFkZXJfTl0sIFtpMm9mNV9yZWFkZXJfTiwgaTJvZjVfcmVhZGVyX04sIGkyb2Y1X3JlYWRlcl9OLCBpMm9mNV9yZWFkZXJfVywgaTJvZjVfcmVhZGVyX1ddLCBbaTJvZjVfcmVhZGVyX1csIGkyb2Y1X3JlYWRlcl9OLCBpMm9mNV9yZWFkZXJfTiwgaTJvZjVfcmVhZGVyX1csIGkyb2Y1X3JlYWRlcl9OXSwgW2kyb2Y1X3JlYWRlcl9OLCBpMm9mNV9yZWFkZXJfVywgaTJvZjVfcmVhZGVyX04sIGkyb2Y1X3JlYWRlcl9XLCBpMm9mNV9yZWFkZXJfTl1dKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiTUFYX0NPUlJFQ1RJT05fRkFDVE9SXCIsIDUpO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKShhc3NlcnRUaGlzSW5pdGlhbGl6ZWRfZGVmYXVsdCgpKF90aGlzKSwgXCJGT1JNQVRcIiwgJ2kyb2Y1Jyk7XG4gICAgaWYgKG9wdHMubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xuICAgICAgX3RoaXMuU0lOR0xFX0NPREVfRVJST1IgPSAwLjM4O1xuICAgICAgX3RoaXMuQVZHX0NPREVfRVJST1IgPSAwLjA5O1xuICAgIH1cbiAgICBfdGhpcy5jb25maWcgPSBvcHRzO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX2RlZmF1bHQoKShfdGhpcywgYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcykpO1xuICB9XG4gIGNyZWF0ZUNsYXNzX2RlZmF1bHQoKShJMm9mNVJlYWRlciwgW3tcbiAgICBrZXk6IFwiX21hdGNoUGF0dGVyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIGNvZGUpIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5ub3JtYWxpemVCYXJTcGFjZVdpZHRoKSB7XG4gICAgICAgIHZhciBjb3VudGVyU3VtID0gWzAsIDBdO1xuICAgICAgICB2YXIgY29kZVN1bSA9IFswLCAwXTtcbiAgICAgICAgdmFyIGNvcnJlY3Rpb24gPSBbMCwgMF07XG4gICAgICAgIHZhciBjb3JyZWN0aW9uUmF0aW8gPSB0aGlzLk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUjtcbiAgICAgICAgdmFyIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UgPSAxIC8gY29ycmVjdGlvblJhdGlvO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb3VudGVyU3VtW2kgJSAyXSArPSBjb3VudGVyW2ldO1xuICAgICAgICAgIGNvZGVTdW1baSAlIDJdICs9IGNvZGVbaV07XG4gICAgICAgIH1cbiAgICAgICAgY29ycmVjdGlvblswXSA9IGNvZGVTdW1bMF0gLyBjb3VudGVyU3VtWzBdO1xuICAgICAgICBjb3JyZWN0aW9uWzFdID0gY29kZVN1bVsxXSAvIGNvdW50ZXJTdW1bMV07XG4gICAgICAgIGNvcnJlY3Rpb25bMF0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzBdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcbiAgICAgICAgY29ycmVjdGlvblsxXSA9IE1hdGgubWF4KE1hdGgubWluKGNvcnJlY3Rpb25bMV0sIGNvcnJlY3Rpb25SYXRpbyksIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UpO1xuICAgICAgICB0aGlzLmJhclNwYWNlUmF0aW8gPSBjb3JyZWN0aW9uO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY291bnRlci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBjb3VudGVyW19pXSAqPSB0aGlzLmJhclNwYWNlUmF0aW9bX2kgJSAyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdldF9kZWZhdWx0KCkoZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKEkyb2Y1UmVhZGVyLnByb3RvdHlwZSksIFwiX21hdGNoUGF0dGVyblwiLCB0aGlzKS5jYWxsKHRoaXMsIGNvdW50ZXIsIGNvZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZmluZFBhdHRlcm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRQYXR0ZXJuKHBhdHRlcm4sIG9mZnNldCkge1xuICAgICAgdmFyIGlzV2hpdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIHRyeUhhcmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgICB2YXIgY291bnRlciA9IG5ldyBBcnJheShwYXR0ZXJuLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgIHZhciBjb3VudGVyUG9zID0gMDtcbiAgICAgIHZhciBiZXN0TWF0Y2ggPSB7XG4gICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiAwXG4gICAgICB9O1xuICAgICAgdmFyIGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuICAgICAgaXNXaGl0ZSA9IGlzV2hpdGUgfHwgZmFsc2U7XG4gICAgICB0cnlIYXJkZXIgPSB0cnlIYXJkZXIgfHwgZmFsc2U7XG4gICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gY291bnRlci5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBuZXh0O1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZmluZFN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kU3RhcnQoKSB7XG4gICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IDA7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgdmFyIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICB2YXIgbmFycm93QmFyV2lkdGggPSAxO1xuICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBuYXJyb3dCYXJXaWR0aCA9IE1hdGguZmxvb3IoKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpIC8gNCk7XG4gICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSBuYXJyb3dCYXJXaWR0aCAqIDEwO1xuICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykge1xuICAgICAgdmFyIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyO1xuICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kRW5kKCkge1xuICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgIHZhciBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVE9QX1BBVFRFUk4pO1xuICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgIGlmIChlbmRJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICAgIHZhciB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xuICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcbiAgICAgIGVuZEluZm8uZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHRtcDtcbiAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlY29kZVBhaXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY29kZVBhaXIoY291bnRlclBhaXIpIHtcbiAgICAgIHZhciBjb2RlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudGVyUGFpci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY291bnRlclBhaXJbaV0pO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVjb2RlQ29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjb2RlQ29kZShjb3VudGVyKSB7XG4gICAgICB2YXIgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG4gICAgICB2YXIgYmVzdE1hdGNoID0ge1xuICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgY29kZTogLTEsXG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IDBcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBjb2RlID0gMDsgY29kZSA8IHRoaXMuQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVjb2RlUGF5bG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpIHtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgdmFyIGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICB2YXIgY291bnRlclBhaXIgPSBbWzAsIDAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMCwgMF1dO1xuICAgICAgdmFyIGNvZGVzID0gbnVsbDtcbiAgICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgY291bnRlclBhaXJbMF1baV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xuICAgICAgICAgIGNvdW50ZXJQYWlyWzFdW2ldID0gY291bnRlcnNbcG9zICsgMV0gKiB0aGlzLmJhclNwYWNlUmF0aW9bMV07XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXMgPSB0aGlzLl9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyKTtcbiAgICAgICAgaWYgKCFjb2Rlcykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNvZGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICByZXN1bHQucHVzaChjb2Rlc1tfaTJdLmNvZGUgKyAnJyk7XG4gICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZXNbX2kyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3ZlcmlmeUNvdW50ZXJMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpIHtcbiAgICAgIHJldHVybiBjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZShyb3csIHN0YXJ0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KCk7XG4gICAgICB2YXIgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5KCk7XG4gICAgICB2YXIgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG4gICAgICB2YXIgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcbiAgICAgIGlmICghZW5kSW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XG4gICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIgIT09IDAgfHwgcmVzdWx0Lmxlbmd0aCA8IDYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFUXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSTJvZjVSZWFkZXI7XG59KGJhcmNvZGVfcmVhZGVyKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGkyb2Y1X3JlYWRlciA9IChpMm9mNV9yZWFkZXJfSTJvZjVSZWFkZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcmVhZGVyL3VwY19lX3JlYWRlci50c1xuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIHVwY19lX3JlYWRlcl9vd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIHVwY19lX3JlYWRlcl9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gdXBjX2VfcmVhZGVyX293bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiB1cGNfZV9yZWFkZXJfb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gdXBjX2VfcmVhZGVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSB1cGNfZV9yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fZGVmYXVsdCgpKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIHVwY19lX3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgdXBjX2VfcmVhZGVyX1VQQ0VSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FQU5SZWFkZXIpIHtcbiAgaW5oZXJpdHNfZGVmYXVsdCgpKFVQQ0VSZWFkZXIsIF9FQU5SZWFkZXIpO1xuICB2YXIgX3N1cGVyID0gdXBjX2VfcmVhZGVyX2NyZWF0ZVN1cGVyKFVQQ0VSZWFkZXIpO1xuICBmdW5jdGlvbiBVUENFUmVhZGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBjbGFzc0NhbGxDaGVja19kZWZhdWx0KCkodGhpcywgVVBDRVJlYWRlcik7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIkNPREVfRlJFUVVFTkNZXCIsIFtbNTYsIDUyLCA1MCwgNDksIDQ0LCAzOCwgMzUsIDQyLCA0MSwgMzddLCBbNywgMTEsIDEzLCAxNCwgMTksIDI1LCAyOCwgMjEsIDIyLCAyNl1dKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiU1RPUF9QQVRURVJOXCIsIFsxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3XSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcIkZPUk1BVFwiLCAndXBjX2UnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgY3JlYXRlQ2xhc3NfZGVmYXVsdCgpKFVQQ0VSZWFkZXIsIFt7XG4gICAga2V5OiBcIl9kZWNvZGVQYXlsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWNvZGVQYXlsb2FkKGluQ29kZSwgcmVzdWx0LCBkZWNvZGVkQ29kZXMpIHtcbiAgICAgIHZhciBvdXRDb2RlID0gdXBjX2VfcmVhZGVyX29iamVjdFNwcmVhZCh7fSwgaW5Db2RlKTtcbiAgICAgIHZhciBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgb3V0Q29kZSA9IHRoaXMuX2RlY29kZUNvZGUob3V0Q29kZS5lbmQpO1xuICAgICAgICBpZiAoIW91dENvZGUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0Q29kZS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgIG91dENvZGUuY29kZSA9IG91dENvZGUuY29kZSAtIENPREVfR19TVEFSVDtcbiAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgNSAtIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gob3V0Q29kZS5jb2RlKTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gob3V0Q29kZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5LCByZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dENvZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZXRlcm1pbmVQYXJpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5LCByZXN1bHQpIHtcbiAgICAgIGZvciAodmFyIG5yU3lzdGVtID0gMDsgbnJTeXN0ZW0gPCB0aGlzLkNPREVfRlJFUVVFTkNZLmxlbmd0aDsgbnJTeXN0ZW0rKykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dW2ldKSB7XG4gICAgICAgICAgICByZXN1bHQudW5zaGlmdChuclN5c3RlbSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY29udmVydFRvVVBDQVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udmVydFRvVVBDQShyZXN1bHQpIHtcbiAgICAgIHZhciB1cGNhID0gW3Jlc3VsdFswXV07XG4gICAgICB2YXIgbGFzdERpZ2l0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAyXTtcbiAgICAgIGlmIChsYXN0RGlnaXQgPD0gMikge1xuICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDMpKS5jb25jYXQoW2xhc3REaWdpdCwgMCwgMCwgMCwgMF0pLmNvbmNhdChyZXN1bHQuc2xpY2UoMywgNikpO1xuICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDMpIHtcbiAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA0KSkuY29uY2F0KFswLCAwLCAwLCAwLCAwXSkuY29uY2F0KHJlc3VsdC5zbGljZSg0LCA2KSk7XG4gICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNCkge1xuICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDUpKS5jb25jYXQoWzAsIDAsIDAsIDAsIDAsIHJlc3VsdFs1XV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA2KSkuY29uY2F0KFswLCAwLCAwLCAwLCBsYXN0RGlnaXRdKTtcbiAgICAgIH1cbiAgICAgIHVwY2EucHVzaChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdKTtcbiAgICAgIHJldHVybiB1cGNhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tzdW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrc3VtKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIGdldF9kZWZhdWx0KCkoZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKFVQQ0VSZWFkZXIucHJvdG90eXBlKSwgXCJfY2hlY2tzdW1cIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLl9jb252ZXJ0VG9VUENBKHJlc3VsdCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZEVuZChvZmZzZXQsIGlzV2hpdGUpIHtcbiAgICAgIHJldHVybiBnZXRfZGVmYXVsdCgpKGdldFByb3RvdHlwZU9mX2RlZmF1bHQoKShVUENFUmVhZGVyLnByb3RvdHlwZSksIFwiX2ZpbmRFbmRcIiwgdGhpcykuY2FsbCh0aGlzLCBvZmZzZXQsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykge1xuICAgICAgdmFyIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyO1xuICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBVUENFUmVhZGVyO1xufShlYW5fcmVhZGVyKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHVwY19lX3JlYWRlciA9ICh1cGNfZV9yZWFkZXJfVVBDRVJlYWRlcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9yZWFkZXIvdXBjX3JlYWRlci50c1xuXG5cblxuXG5cblxuXG5mdW5jdGlvbiB1cGNfcmVhZGVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSB1cGNfcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGdldFByb3RvdHlwZU9mX2RlZmF1bHQoKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX2RlZmF1bHQoKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiB1cGNfcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciB1cGNfcmVhZGVyX1VQQ1JlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VBTlJlYWRlcikge1xuICBpbmhlcml0c19kZWZhdWx0KCkoVVBDUmVhZGVyLCBfRUFOUmVhZGVyKTtcbiAgdmFyIF9zdXBlciA9IHVwY19yZWFkZXJfY3JlYXRlU3VwZXIoVVBDUmVhZGVyKTtcbiAgZnVuY3Rpb24gVVBDUmVhZGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBjbGFzc0NhbGxDaGVja19kZWZhdWx0KCkodGhpcywgVVBDUmVhZGVyKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwuYXBwbHkoX3N1cGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIFwiRk9STUFUXCIsICd1cGNfYScpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBjcmVhdGVDbGFzc19kZWZhdWx0KCkoVVBDUmVhZGVyLCBbe1xuICAgIGtleTogXCJkZWNvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlKHJvdywgc3RhcnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBlYW5fcmVhZGVyLnByb3RvdHlwZS5kZWNvZGUuY2FsbCh0aGlzKTtcbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmNvZGUgJiYgcmVzdWx0LmNvZGUubGVuZ3RoID09PSAxMyAmJiByZXN1bHQuY29kZS5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICByZXN1bHQuY29kZSA9IHJlc3VsdC5jb2RlLnN1YnN0cmluZygxKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVVBDUmVhZGVyO1xufShlYW5fcmVhZGVyKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHVwY19yZWFkZXIgPSAodXBjX3JlYWRlcl9VUENSZWFkZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZGVjb2Rlci9icmVzZW5oYW0uanNcbnZhciBCcmVzZW5oYW0gPSB7fTtcbnZhciBTbG9wZSA9IHtcbiAgRElSOiB7XG4gICAgVVA6IDEsXG4gICAgRE9XTjogLTFcbiAgfVxufTtcbi8qKlxuICogU2NhbnMgYSBsaW5lIG9mIHRoZSBnaXZlbiBpbWFnZSBmcm9tIHBvaW50IHAxIHRvIHAyIGFuZCByZXR1cm5zIGEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nXG4gKiBncmF5LXNjYWxlIHZhbHVlcyAoMC0yNTUpIG9mIHRoZSB1bmRlcmx5aW5nIHBpeGVscyBpbiBhZGRpdGlvbiB0byB0aGUgbWluXG4gKiBhbmQgbWF4IHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZVdyYXBwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSBUaGUgc3RhcnQgcG9pbnQge3gseX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiBUaGUgZW5kIHBvaW50IHt4LHl9XG4gKiBAcmV0dXJucyB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZSA9IGZ1bmN0aW9uIChpbWFnZVdyYXBwZXIsIHAxLCBwMikge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gIHZhciB4MCA9IHAxLnggfCAwO1xuICB2YXIgeTAgPSBwMS55IHwgMDtcbiAgdmFyIHgxID0gcDIueCB8IDA7XG4gIHZhciB5MSA9IHAyLnkgfCAwO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gIHZhciBzdGVlcCA9IE1hdGguYWJzKHkxIC0geTApID4gTWF0aC5hYnMoeDEgLSB4MCk7XG4gIHZhciBlcnJvcjtcbiAgdmFyIHk7XG4gIHZhciB0bXA7XG4gIHZhciB4O1xuICB2YXIgbGluZSA9IFtdO1xuICB2YXIgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gIHZhciB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gIHZhciB2YWw7XG4gIHZhciBtaW4gPSAyNTU7XG4gIHZhciBtYXggPSAwO1xuICBmdW5jdGlvbiByZWFkKGEsIGIpIHtcbiAgICB2YWwgPSBpbWFnZURhdGFbYiAqIHdpZHRoICsgYV07XG4gICAgbWluID0gdmFsIDwgbWluID8gdmFsIDogbWluO1xuICAgIG1heCA9IHZhbCA+IG1heCA/IHZhbCA6IG1heDtcbiAgICBsaW5lLnB1c2godmFsKTtcbiAgfVxuICBpZiAoc3RlZXApIHtcbiAgICB0bXAgPSB4MDtcbiAgICB4MCA9IHkwO1xuICAgIHkwID0gdG1wO1xuICAgIHRtcCA9IHgxO1xuICAgIHgxID0geTE7XG4gICAgeTEgPSB0bXA7XG4gIH1cbiAgaWYgKHgwID4geDEpIHtcbiAgICB0bXAgPSB4MDtcbiAgICB4MCA9IHgxO1xuICAgIHgxID0gdG1wO1xuICAgIHRtcCA9IHkwO1xuICAgIHkwID0geTE7XG4gICAgeTEgPSB0bXA7XG4gIH1cbiAgdmFyIGRlbHRhWCA9IHgxIC0geDA7XG4gIHZhciBkZWx0YVkgPSBNYXRoLmFicyh5MSAtIHkwKTtcbiAgZXJyb3IgPSBkZWx0YVggLyAyIHwgMDtcbiAgeSA9IHkwO1xuICB2YXIgeVN0ZXAgPSB5MCA8IHkxID8gMSA6IC0xO1xuICBmb3IgKHggPSB4MDsgeCA8IHgxOyB4KyspIHtcbiAgICBpZiAoc3RlZXApIHtcbiAgICAgIHJlYWQoeSwgeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWQoeCwgeSk7XG4gICAgfVxuICAgIGVycm9yIC09IGRlbHRhWTtcbiAgICBpZiAoZXJyb3IgPCAwKSB7XG4gICAgICB5ICs9IHlTdGVwO1xuICAgICAgZXJyb3IgKz0gZGVsdGFYO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGxpbmU6IGxpbmUsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHJlc3VsdCBmcm9tIGdldEJhcmNvZGVMaW5lIGludG8gYSBiaW5hcnkgcmVwcmVzZW50YXRpb25cbiAqIGFsc28gY29uc2lkZXJpbmcgdGhlIGZyZXF1ZW5jeSBhbmQgc2xvcGUgb2YgdGhlIHNpZ25hbCBmb3IgbW9yZSByb2J1c3QgcmVzdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS50b0JpbmFyeUxpbmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHZhciBtaW4gPSByZXN1bHQubWluO1xuICB2YXIgbWF4ID0gcmVzdWx0Lm1heDtcbiAgdmFyIGxpbmUgPSByZXN1bHQubGluZTtcbiAgdmFyIHNsb3BlO1xuICB2YXIgc2xvcGUyO1xuICB2YXIgY2VudGVyID0gbWluICsgKG1heCAtIG1pbikgLyAyO1xuICB2YXIgZXh0cmVtYSA9IFtdO1xuICB2YXIgY3VycmVudERpcjtcbiAgdmFyIGRpcjtcbiAgdmFyIHRocmVzaG9sZCA9IChtYXggLSBtaW4pIC8gMTI7XG4gIHZhciByVGhyZXNob2xkID0gLXRocmVzaG9sZDtcbiAgdmFyIGk7XG4gIHZhciBqO1xuXG4gIC8vIDEuIGZpbmQgZXh0cmVtYVxuICBjdXJyZW50RGlyID0gbGluZVswXSA+IGNlbnRlciA/IFNsb3BlLkRJUi5VUCA6IFNsb3BlLkRJUi5ET1dOO1xuICBleHRyZW1hLnB1c2goe1xuICAgIHBvczogMCxcbiAgICB2YWw6IGxpbmVbMF1cbiAgfSk7XG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDI7IGkrKykge1xuICAgIHNsb3BlID0gbGluZVtpICsgMV0gLSBsaW5lW2ldO1xuICAgIHNsb3BlMiA9IGxpbmVbaSArIDJdIC0gbGluZVtpICsgMV07XG4gICAgaWYgKHNsb3BlICsgc2xvcGUyIDwgclRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA8IGNlbnRlciAqIDEuNSkge1xuICAgICAgZGlyID0gU2xvcGUuRElSLkRPV047XG4gICAgfSBlbHNlIGlmIChzbG9wZSArIHNsb3BlMiA+IHRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA+IGNlbnRlciAqIDAuNSkge1xuICAgICAgZGlyID0gU2xvcGUuRElSLlVQO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXIgPSBjdXJyZW50RGlyO1xuICAgIH1cbiAgICBpZiAoY3VycmVudERpciAhPT0gZGlyKSB7XG4gICAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICBwb3M6IGksXG4gICAgICAgIHZhbDogbGluZVtpXVxuICAgICAgfSk7XG4gICAgICBjdXJyZW50RGlyID0gZGlyO1xuICAgIH1cbiAgfVxuICBleHRyZW1hLnB1c2goe1xuICAgIHBvczogbGluZS5sZW5ndGgsXG4gICAgdmFsOiBsaW5lW2xpbmUubGVuZ3RoIC0gMV1cbiAgfSk7XG4gIGZvciAoaiA9IGV4dHJlbWFbMF0ucG9zOyBqIDwgZXh0cmVtYVsxXS5wb3M7IGorKykge1xuICAgIGxpbmVbal0gPSBsaW5lW2pdID4gY2VudGVyID8gMCA6IDE7XG4gIH1cblxuICAvLyBpdGVyYXRlIG92ZXIgZXh0cmVtYSBhbmQgY29udmVydCB0byBiaW5hcnkgYmFzZWQgb24gYXZnIGJldHdlZW4gbWlubWF4XG4gIGZvciAoaSA9IDE7IGkgPCBleHRyZW1hLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChleHRyZW1hW2kgKyAxXS52YWwgPiBleHRyZW1hW2ldLnZhbCkge1xuICAgICAgdGhyZXNob2xkID0gZXh0cmVtYVtpXS52YWwgKyAoZXh0cmVtYVtpICsgMV0udmFsIC0gZXh0cmVtYVtpXS52YWwpIC8gMyAqIDIgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJlc2hvbGQgPSBleHRyZW1hW2kgKyAxXS52YWwgKyAoZXh0cmVtYVtpXS52YWwgLSBleHRyZW1hW2kgKyAxXS52YWwpIC8gMyB8IDA7XG4gICAgfVxuICAgIGZvciAoaiA9IGV4dHJlbWFbaV0ucG9zOyBqIDwgZXh0cmVtYVtpICsgMV0ucG9zOyBqKyspIHtcbiAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gdGhyZXNob2xkID8gMCA6IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbGluZTogbGluZSxcbiAgICB0aHJlc2hvbGQ6IHRocmVzaG9sZFxuICB9O1xufTtcblxuLyoqXG4gKiBVc2VkIGZvciBkZXZlbG9wbWVudCBvbmx5XG4gKi9cbkJyZXNlbmhhbS5kZWJ1ZyA9IHtcbiAgcHJpbnRGcmVxdWVuY3k6IGZ1bmN0aW9uIHByaW50RnJlcXVlbmN5KGxpbmUsIGNhbnZhcykge1xuICAgIHZhciBpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBjYW52YXMuaGVpZ2h0ID0gMjU2O1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN0eC5tb3ZlVG8oaSwgMjU1KTtcbiAgICAgIGN0eC5saW5lVG8oaSwgMjU1IC0gbGluZVtpXSk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH0sXG4gIHByaW50UGF0dGVybjogZnVuY3Rpb24gcHJpbnRQYXR0ZXJuKGxpbmUsIGNhbnZhcykge1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgaTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xuICAgIGN0eC5maWxsQ29sb3IgPSAnYmxhY2snO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGluZVtpXSA9PT0gMSkge1xuICAgICAgICBjdHguZmlsbFJlY3QoaSwgMCwgMSwgMTAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBicmVzZW5oYW0gPSAoQnJlc2VuaGFtKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyLmpzXG5cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1jeWNsZSAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBSRUFERVJTID0ge1xuICBjb2RlXzEyOF9yZWFkZXI6IGNvZGVfMTI4X3JlYWRlcixcbiAgZWFuX3JlYWRlcjogZWFuX3JlYWRlcixcbiAgZWFuXzVfcmVhZGVyOiBlYW5fNV9yZWFkZXIsXG4gIGVhbl8yX3JlYWRlcjogZWFuXzJfcmVhZGVyLFxuICBlYW5fOF9yZWFkZXI6IGVhbl84X3JlYWRlcixcbiAgY29kZV8zOV9yZWFkZXI6IGNvZGVfMzlfcmVhZGVyLFxuICBjb2RlXzM5X3Zpbl9yZWFkZXI6IGNvZGVfMzlfdmluX3JlYWRlcixcbiAgY29kYWJhcl9yZWFkZXI6IGNvZGFiYXJfcmVhZGVyLFxuICB1cGNfcmVhZGVyOiB1cGNfcmVhZGVyLFxuICB1cGNfZV9yZWFkZXI6IHVwY19lX3JlYWRlcixcbiAgaTJvZjVfcmVhZGVyOiBpMm9mNV9yZWFkZXIsXG4gICcyb2Y1X3JlYWRlcic6IF8yb2Y1X3JlYWRlcixcbiAgY29kZV85M19yZWFkZXI6IGNvZGVfOTNfcmVhZGVyLFxuICBjb2RlXzMyX3JlYWRlcjogY29kZV8zMl9yZWFkZXJcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBiYXJjb2RlX2RlY29kZXIgPSAoe1xuICByZWdpc3RlclJlYWRlcjogZnVuY3Rpb24gcmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKSB7XG4gICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcbiAgfSxcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoY29uZmlnLCBpbnB1dEltYWdlV3JhcHBlcikge1xuICAgIHZhciBfY2FudmFzID0ge1xuICAgICAgY3R4OiB7XG4gICAgICAgIGZyZXF1ZW5jeTogbnVsbCxcbiAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgb3ZlcmxheTogbnVsbFxuICAgICAgfSxcbiAgICAgIGRvbToge1xuICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICAgIG92ZXJsYXk6IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBfYmFyY29kZVJlYWRlcnMgPSBbXTtcbiAgICBpbml0Q2FudmFzKCk7XG4gICAgaW5pdFJlYWRlcnMoKTtcbiAgICBpbml0Q29uZmlnKCk7XG4gICAgZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICAgIGlmIChmYWxzZSkgeyB2YXIgJGRlYnVnOyB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRSZWFkZXJzKCkge1xuICAgICAgY29uZmlnLnJlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVhZGVyQ29uZmlnKSB7XG4gICAgICAgIHZhciByZWFkZXI7XG4gICAgICAgIHZhciBjb25maWd1cmF0aW9uID0ge307XG4gICAgICAgIHZhciBzdXBwbGVtZW50cyA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mX2RlZmF1bHQoKShyZWFkZXJDb25maWcpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZy5mb3JtYXQ7XG4gICAgICAgICAgY29uZmlndXJhdGlvbiA9IHJlYWRlckNvbmZpZy5jb25maWc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRlckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZWFkZXIgPSByZWFkZXJDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhbHNlKSB7fVxuICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5zdXBwbGVtZW50cykge1xuICAgICAgICAgIHN1cHBsZW1lbnRzID0gY29uZmlndXJhdGlvbi5zdXBwbGVtZW50cy5tYXAoZnVuY3Rpb24gKHN1cHBsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUkVBREVSU1tzdXBwbGVtZW50XSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHJlYWRlck9iaiA9IG5ldyBSRUFERVJTW3JlYWRlcl0oY29uZmlndXJhdGlvbiwgc3VwcGxlbWVudHMpO1xuICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5wdXNoKHJlYWRlck9iaik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyogRXJyb3IgY29uc3RydWN0aW5nIHJlYWRlciAnLCByZWFkZXIsIGVycik7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChmYWxzZSkge31cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdENvbmZpZygpIHtcbiAgICAgIGlmIChmYWxzZSkgeyB2YXIgdmlzLCBpOyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZXh0ZW5kIHRoZSBsaW5lIG9uIGJvdGggZW5kc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRFeHRlbmRlZExpbmUobGluZSwgYW5nbGUsIGV4dCkge1xuICAgICAgZnVuY3Rpb24gZXh0ZW5kTGluZShhbW91bnQpIHtcbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHtcbiAgICAgICAgICB5OiBhbW91bnQgKiBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgeDogYW1vdW50ICogTWF0aC5jb3MoYW5nbGUpXG4gICAgICAgIH07XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgIGxpbmVbMF0ueSAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi54O1xuICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLnk7XG4gICAgICAgIGxpbmVbMV0ueCArPSBleHRlbnNpb24ueDtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiBpbnNpZGUgaW1hZ2VcbiAgICAgIGV4dGVuZExpbmUoZXh0KTtcbiAgICAgIHdoaWxlIChleHQgPiAxICYmICghaW5wdXRJbWFnZVdyYXBwZXIuaW5JbWFnZVdpdGhCb3JkZXIobGluZVswXSkgfHwgIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMV0pKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgZXh0IC09IE1hdGguY2VpbChleHQgLyAyKTtcbiAgICAgICAgZXh0ZW5kTGluZSgtZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMaW5lKGJveCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHg6IChib3hbMV1bMF0gLSBib3hbMF1bMF0pIC8gMiArIGJveFswXVswXSxcbiAgICAgICAgeTogKGJveFsxXVsxXSAtIGJveFswXVsxXSkgLyAyICsgYm94WzBdWzFdXG4gICAgICB9LCB7XG4gICAgICAgIHg6IChib3hbM11bMF0gLSBib3hbMl1bMF0pIC8gMiArIGJveFsyXVswXSxcbiAgICAgICAgeTogKGJveFszXVsxXSAtIGJveFsyXVsxXSkgLyAyICsgYm94WzJdWzFdXG4gICAgICB9XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJ5RGVjb2RlKGxpbmUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgYmFyY29kZUxpbmUgPSBicmVzZW5oYW0uZ2V0QmFyY29kZUxpbmUoaW5wdXRJbWFnZVdyYXBwZXIsIGxpbmVbMF0sIGxpbmVbMV0pO1xuICAgICAgaWYgKGZhbHNlKSB7fVxuICAgICAgYnJlc2VuaGFtLnRvQmluYXJ5TGluZShiYXJjb2RlTGluZSk7XG4gICAgICBpZiAoZmFsc2UpIHt9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCAmJiByZXN1bHQgPT09IG51bGw7IGkrKykge1xuICAgICAgICByZXN1bHQgPSBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlUGF0dGVybihiYXJjb2RlTGluZS5saW5lKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQsXG4gICAgICAgIGJhcmNvZGVMaW5lOiBiYXJjb2RlTGluZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzbGljZXMgdGhlIGdpdmVuIGFyZWEgYXBhcnQgYW5kIHRyaWVzIHRvIGRldGVjdCBhIGJhcmNvZGUtcGF0dGVyblxuICAgICAqIGZvciBlYWNoIHNsaWNlLiBJdCByZXR1cm5zIHRoZSBkZWNvZGVkIGJhcmNvZGUsIG9yIG51bGwgaWYgbm90aGluZyB3YXMgZm91bmRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBib3hcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVBbmdsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyeURlY29kZUJydXRlRm9yY2UoYm94LCBsaW5lLCBsaW5lQW5nbGUpIHtcbiAgICAgIHZhciBzaWRlTGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KGJveFsxXVswXSAtIGJveFswXVswXSwgMikgKyBNYXRoLnBvdyhib3hbMV1bMV0gLSBib3hbMF1bMV0sIDIpKTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHNsaWNlcyA9IDE2O1xuICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICB2YXIgZGlyO1xuICAgICAgdmFyIGV4dGVuc2lvbjtcbiAgICAgIHZhciB4ZGlyID0gTWF0aC5zaW4obGluZUFuZ2xlKTtcbiAgICAgIHZhciB5ZGlyID0gTWF0aC5jb3MobGluZUFuZ2xlKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBzbGljZXMgJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgLy8gbW92ZSBsaW5lIHBlcnBlbmRpY3VsYXIgdG8gYW5nbGVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xuICAgICAgICBkaXIgPSBzaWRlTGVuZ3RoIC8gc2xpY2VzICogaSAqIChpICUgMiA9PT0gMCA/IC0xIDogMSk7XG4gICAgICAgIGV4dGVuc2lvbiA9IHtcbiAgICAgICAgICB5OiBkaXIgKiB4ZGlyLFxuICAgICAgICAgIHg6IGRpciAqIHlkaXJcbiAgICAgICAgfTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgbGluZVswXS55ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgIGxpbmVbMV0ueSArPSBleHRlbnNpb24ueDtcbiAgICAgICAgbGluZVsxXS54IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbiAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlKGxpbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TGluZUxlbmd0aChsaW5lKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSksIDIpICsgTWF0aC5wb3coTWF0aC5hYnMobGluZVsxXS54IC0gbGluZVswXS54KSwgMikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZGVjb2RlRnJvbUltYWdlMihfeCkge1xuICAgICAgcmV0dXJuIF9kZWNvZGVGcm9tSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2l0aCB0aGUgaGVscCBvZiB0aGUgY29uZmlndXJlZCByZWFkZXJzIChDb2RlMTI4IG9yIEVBTikgdGhpcyBmdW5jdGlvbiB0cmllcyB0byBkZXRlY3QgYVxuICAgICAqIHZhbGlkIGJhcmNvZGUgcGF0dGVybiB3aXRoaW4gdGhlIGdpdmVuIGFyZWEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJveCBUaGUgYXJlYSB0byBzZWFyY2ggaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcmVzdWx0IHtjb2RlUmVzdWx0LCBsaW5lLCBhbmdsZSwgcGF0dGVybiwgdGhyZXNob2xkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9kZWNvZGVGcm9tSW1hZ2UoKSB7XG4gICAgICBfZGVjb2RlRnJvbUltYWdlID0gYXN5bmNUb0dlbmVyYXRvcl9kZWZhdWx0KCkoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvcl9kZWZhdWx0LmEubWFyayhmdW5jdGlvbiBfY2FsbGVlMihpbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgX2l0ZXJhdG9yLCBfc3RlcCwgcmVhZGVyO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JfZGVmYXVsdC5hLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX2JhcmNvZGVSZWFkZXJzKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyO1xuICAgICAgICAgICAgICBfaXRlcmF0b3IucygpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBpZiAoKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVhZGVyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmICghcmVhZGVyLmRlY29kZUltYWdlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICAgIHJldHVybiByZWFkZXIuZGVjb2RlSW1hZ2UoaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcImJyZWFrXCIsIDE0KTtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTY7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDIpO1xuICAgICAgICAgICAgICBfaXRlcmF0b3IuZShfY29udGV4dDIudDApO1xuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxOTtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMTkpO1xuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMiwgMTYsIDE5LCAyMl1dKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBfZGVjb2RlRnJvbUltYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB7XG4gICAgICB2YXIgbGluZTtcbiAgICAgIHZhciBjdHggPSBfY2FudmFzLmN0eC5vdmVybGF5O1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmIChmYWxzZSkge31cbiAgICAgIGxpbmUgPSBnZXRMaW5lKGJveCk7XG4gICAgICB2YXIgbGluZUxlbmd0aCA9IGdldExpbmVMZW5ndGgobGluZSk7XG4gICAgICB2YXIgbGluZUFuZ2xlID0gTWF0aC5hdGFuMihsaW5lWzFdLnkgLSBsaW5lWzBdLnksIGxpbmVbMV0ueCAtIGxpbmVbMF0ueCk7XG4gICAgICBsaW5lID0gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGxpbmVBbmdsZSwgTWF0aC5mbG9vcihsaW5lTGVuZ3RoICogMC4xKSk7XG4gICAgICBpZiAobGluZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGZhbHNlKSB7fVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29kZVJlc3VsdDogcmVzdWx0LmNvZGVSZXN1bHQsXG4gICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgIGFuZ2xlOiBsaW5lQW5nbGUsXG4gICAgICAgIHBhdHRlcm46IHJlc3VsdC5iYXJjb2RlTGluZS5saW5lLFxuICAgICAgICB0aHJlc2hvbGQ6IHJlc3VsdC5iYXJjb2RlTGluZS50aHJlc2hvbGRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3g6IGZ1bmN0aW9uIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KTtcbiAgICAgIH0sXG4gICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3hlczogZnVuY3Rpb24gZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMoYm94ZXMpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBiYXJjb2RlcyA9IFtdO1xuICAgICAgICB2YXIgbXVsdGlwbGUgPSBjb25maWcubXVsdGlwbGU7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICByZXN1bHQgPSBfZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkgfHwge307XG4gICAgICAgICAgcmVzdWx0LmJveCA9IGJveDtcbiAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGJhcmNvZGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5jb2RlUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJhcmNvZGVzOiBiYXJjb2Rlc1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRlY29kZUZyb21JbWFnZTogZnVuY3Rpb24gZGVjb2RlRnJvbUltYWdlKGltYWdlV3JhcHBlckluKSB7XG4gICAgICAgIHJldHVybiBhc3luY1RvR2VuZXJhdG9yX2RlZmF1bHQoKSggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yX2RlZmF1bHQuYS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JfZGVmYXVsdC5hLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2RlY29kZUZyb21JbWFnZTIoaW1hZ2VXcmFwcGVySW4pO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgIH0pKSgpO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVhZGVyOiBmdW5jdGlvbiByZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgaWYgKFJFQURFUlNbbmFtZV0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWdpc3RlciBleGlzdGluZyByZWFkZXInLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBSRUFERVJTW25hbWVdID0gcmVhZGVyO1xuICAgICAgfSxcbiAgICAgIHNldFJlYWRlcnM6IGZ1bmN0aW9uIHNldFJlYWRlcnMocmVhZGVycykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY29uZmlnLnJlYWRlcnMgPSByZWFkZXJzO1xuICAgICAgICBfYmFyY29kZVJlYWRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgaW5pdFJlYWRlcnMoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3JlYWRlci9pbmRleC50c1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21tb24vZXZlbnRzLnRzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBldmVudHMgPSAoKGZ1bmN0aW9uIEV2ZW50SW50ZXJmYWNlKCkge1xuICB2YXIgZXZlbnRzID0ge307XG4gIGZ1bmN0aW9uIGdldEV2ZW50KGV2ZW50TmFtZSkge1xuICAgIGlmICghZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIGV2ZW50c1tldmVudE5hbWVdID0ge1xuICAgICAgICBzdWJzY3JpYmVyczogW11cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBldmVudHNbZXZlbnROYW1lXTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhckV2ZW50cygpIHtcbiAgICBldmVudHMgPSB7fTtcbiAgfVxuICBmdW5jdGlvbiBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgZGF0YSkge1xuICAgIGlmIChzdWJzY3JpcHRpb24uYXN5bmMpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XG4gICAgICB9LCA0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgYXN5bmMpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBhc3luYzogYXN5bmNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnNjcmlwdGlvbiA9IGNhbGxiYWNrO1xuICAgICAgaWYgKCFzdWJzY3JpcHRpb24uY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayB3YXMgbm90IHNwZWNpZmllZCBvbiBvcHRpb25zJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldEV2ZW50KGV2ZW50KS5zdWJzY3JpYmVycy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShldmVudCwgY2FsbGJhY2ssIGFzeW5jKSB7XG4gICAgICByZXR1cm4gX3N1YnNjcmliZShldmVudCwgY2FsbGJhY2ssIGFzeW5jKTtcbiAgICB9LFxuICAgIHB1Ymxpc2g6IGZ1bmN0aW9uIHB1Ymxpc2goZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICB2YXIgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gZXZlbnQuc3Vic2NyaWJlcnM7XG5cbiAgICAgIC8vIFB1Ymxpc2ggb25lLXRpbWUgc3Vic2NyaXB0aW9uc1xuICAgICAgc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiAhIXN1YnNjcmliZXIub25jZTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZW1vdmUgdGhlbSBmcm9tIHRoZSBzdWJzY3JpYmVyXG4gICAgICBldmVudC5zdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmZpbHRlcihmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gIXN1YnNjcmliZXIub25jZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwdWJsaXNoIHRoZSByZXN0XG4gICAgICBldmVudC5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaWJlciwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgYXN5bmMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgX3N1YnNjcmliZShldmVudCwge1xuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGFzeW5jOiBhc3luYyxcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgX2V2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKF9ldmVudCAmJiBjYWxsYmFjaykge1xuICAgICAgICAgIF9ldmVudC5zdWJzY3JpYmVycyA9IF9ldmVudC5zdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmNhbGxiYWNrICE9PSBjYWxsYmFjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZXZlbnQuc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJFdmVudHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KSgpKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoL3BpY2suanNcbnZhciBwaWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XG52YXIgcGlja19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihwaWNrKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qc1xudmFyIHdyYXBOYXRpdmVTdXBlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xudmFyIHdyYXBOYXRpdmVTdXBlcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih3cmFwTmF0aXZlU3VwZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9xdWFnZ2EvRXhjZXB0aW9uLnRzXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gRXhjZXB0aW9uX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBFeGNlcHRpb25faXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZ2V0UHJvdG90eXBlT2ZfZGVmYXVsdCgpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBnZXRQcm90b3R5cGVPZl9kZWZhdWx0KCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fZGVmYXVsdCgpKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIEV4Y2VwdGlvbl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxudmFyIEV4Y2VwdGlvbl9FeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBpbmhlcml0c19kZWZhdWx0KCkoRXhjZXB0aW9uLCBfRXJyb3IpO1xuICB2YXIgX3N1cGVyID0gRXhjZXB0aW9uX2NyZWF0ZVN1cGVyKEV4Y2VwdGlvbik7XG4gIGZ1bmN0aW9uIEV4Y2VwdGlvbihtLCBjb2RlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIGNsYXNzQ2FsbENoZWNrX2RlZmF1bHQoKSh0aGlzLCBFeGNlcHRpb24pO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKGFzc2VydFRoaXNJbml0aWFsaXplZF9kZWZhdWx0KCkoX3RoaXMpLCBcImNvZGVcIiwgdm9pZCAwKTtcbiAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXNzZXJ0VGhpc0luaXRpYWxpemVkX2RlZmF1bHQoKShfdGhpcyksIEV4Y2VwdGlvbi5wcm90b3R5cGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2xhc3NfZGVmYXVsdCgpKEV4Y2VwdGlvbik7XG59KCAvKiNfX1BVUkVfXyovd3JhcE5hdGl2ZVN1cGVyX2RlZmF1bHQoKShFcnJvcikpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21tb24vbWVkaWFEZXZpY2VzLnRzXG5cbnZhciBFUlJPUl9ERVNDID0gJ1RoaXMgbWF5IG1lYW4gdGhhdCB0aGUgdXNlciBoYXMgZGVjbGluZWQgY2FtZXJhIGFjY2Vzcywgb3IgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtZWRpYSBBUElzLiBJZiB5b3UgYXJlIHJ1bm5pbmcgaW4gaU9TLCB5b3UgbXVzdCB1c2UgU2FmYXJpLic7XG5mdW5jdGlvbiBlbnVtZXJhdGVEZXZpY2VzKCkge1xuICB0cnkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEV4Y2VwdGlvbl9FeGNlcHRpb24oXCJlbnVtZXJhdGVEZXZpY2VzIGlzIG5vdCBkZWZpbmVkLiBcIi5jb25jYXQoRVJST1JfREVTQyksIC0xKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXhjZXB0aW9uX0V4Y2VwdGlvbihcImdldFVzZXJNZWRpYSBpcyBub3QgZGVmaW5lZC4gXCIuY29uY2F0KEVSUk9SX0RFU0MpLCAtMSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvaW5wdXQvY2FtZXJhX2FjY2Vzcy50c1xuXG5cbi8vIFRPRE86IHdoZW4gdGhpcyBmaWxlIHdhcyB3cml0dGVuIHllYXJzIGFnbywgSFRNTE1lZGlhRWxlbWVudC5wbGF5KCkgZGlkIG5vdCByZXR1cm4gYSB1c2VmdWwgdmFsdWVcbi8vIHRvIGxldCB1cyBrbm93IHdoZW4gdGhlIHZpZGVvIHN0YXJ0ZWQgcGxheWluZy4gIE5vdywgaXQgZG9lcy4gIFNvLCB3ZSBzaG91bGRuJ3QgbmVlZCB0byBydW4gdGhpc1xuLy8gb2RkIHdhaXRGb3JWaWRlbygpIGZ1bmN0aW9uIHRoYXQgcG9sbHMgdG8gc2VlIGlmIHRoZSB2aWRlbyBoYXMgc3RhcnRlZC5cblxuXG5cbnZhciBzdHJlYW1SZWY7XG5mdW5jdGlvbiB3YWl0Rm9yVmlkZW8odmlkZW8pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgYXR0ZW1wdHMgPSAxMDtcbiAgICBmdW5jdGlvbiBjaGVja1ZpZGVvKCkge1xuICAgICAgaWYgKGF0dGVtcHRzID4gMCkge1xuICAgICAgICBpZiAodmlkZW8udmlkZW9XaWR0aCA+IDEwICYmIHZpZGVvLnZpZGVvSGVpZ2h0ID4gMTApIHtcbiAgICAgICAgICBpZiAoZmFsc2UpIHt9XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNoZWNrVmlkZW8sIDUwMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChuZXcgRXhjZXB0aW9uX0V4Y2VwdGlvbignVW5hYmxlIHRvIHBsYXkgdmlkZW8gc3RyZWFtLiBJcyB3ZWJjYW0gd29ya2luZz8nLCAtMSkpOyAvLyBUT0RPOiBhZGQgZXJyb3IgY29kZVxuICAgICAgfVxuXG4gICAgICBhdHRlbXB0cy0tO1xuICAgIH1cbiAgICBjaGVja1ZpZGVvKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRyaWVzIHRvIGF0dGFjaCB0aGUgY2FtZXJhLXN0cmVhbSB0byBhIGdpdmVuIHZpZGVvLWVsZW1lbnRcbiAqIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgY29udGVudCBpcyByZWFkeVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gdmlkZW9cbiAqL1xuZnVuY3Rpb24gaW5pdENhbWVyYShfeCwgX3gyKSB7XG4gIHJldHVybiBfaW5pdENhbWVyYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2luaXRDYW1lcmEoKSB7XG4gIF9pbml0Q2FtZXJhID0gYXN5bmNUb0dlbmVyYXRvcl9kZWZhdWx0KCkoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvcl9kZWZhdWx0LmEubWFyayhmdW5jdGlvbiBfY2FsbGVlNCh2aWRlbywgY29uc3RyYWludHMpIHtcbiAgICB2YXIgc3RyZWFtO1xuICAgIHJldHVybiByZWdlbmVyYXRvcl9kZWZhdWx0LmEud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgcmV0dXJuIGdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzdHJlYW0gPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICBzdHJlYW1SZWYgPSBzdHJlYW07XG4gICAgICAgICAgaWYgKCF2aWRlbykge1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgJ3RydWUnKTtcbiAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ211dGVkJywgJ3RydWUnKTtcbiAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgJ3RydWUnKTsgLy8gbm90IGxpc3RlZCBvbiBNRE4uLi5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2aWRlby5wbGF5KClbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignKiBFcnJvciB3aGlsZSB0cnlpbmcgdG8gcGxheSB2aWRlbyBzdHJlYW06JywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHdhaXRGb3JWaWRlbyh2aWRlbykpO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xuICByZXR1cm4gX2luaXRDYW1lcmEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKSB7XG4gIHZhciBub3JtYWxpemVkID0gcGlja19kZWZhdWx0KCkodmlkZW9Db25zdHJhaW50cywgWyd3aWR0aCcsICdoZWlnaHQnLCAnZmFjaW5nTW9kZScsICdhc3BlY3RSYXRpbycsICdkZXZpY2VJZCddKTtcbiAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvICE9PSAndW5kZWZpbmVkJyAmJiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvID4gMCkge1xuICAgIG5vcm1hbGl6ZWQuYXNwZWN0UmF0aW8gPSB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvO1xuICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ21pbkFzcGVjdFJhdGlvXFwnIGlzIGRlcHJlY2F0ZWQ7IFVzZSBcXCdhc3BlY3RSYXRpb1xcJyBpbnN0ZWFkJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBub3JtYWxpemVkLmZhY2luZ01vZGUgPSB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZztcbiAgICBjb25zb2xlLmxvZygnV0FSTklORzogQ29uc3RyYWludCBcXCdmYWNpbmdcXCcgaXMgZGVwcmVjYXRlZC4gVXNlIFxcJ2ZhY2luZ01vZGVcXCcgaW5zdGVhZFxcJycpO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vLyBUT0RPOiAjMTkyIEkgZG9uJ3QgdGhpbmsgdGhlcmUncyBhbnkgZ29vZCByZWFzb24gcGlja0NvbnN0cmFpbnRzIHNob3VsZCByZXR1cm4gYSBQcm9taXNlLFxuLy8gSSB0aGluayBpdCB3YXMganVzdCB0aGF0IHdheSBzbyBpdCBjb3VsZCBiZSBjaGFpbmVkIHRvIG90aGVyIGZ1bmN0aW9ucyB0aGF0IGRpZCByZXR1cm4gYSBQcm9taXNlLlxuLy8gVGhhdCdzIG5vdCBuZWNlc3Nhcnkgd2l0aCBhc3luYyBmdW5jdGlvbnMgYmVpbmcgYSB0aGluZywgc28gdGhhdCBzaG91bGQgYmUgZml4ZWQuXG5mdW5jdGlvbiBwaWNrQ29uc3RyYWludHMoKSB7XG4gIHZhciB2aWRlb0NvbnN0cmFpbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIHZpZGVvID0gZGVwcmVjYXRlZENvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHMpO1xuICBpZiAodmlkZW8gJiYgdmlkZW8uZGV2aWNlSWQgJiYgdmlkZW8uZmFjaW5nTW9kZSkge1xuICAgIGRlbGV0ZSB2aWRlby5mYWNpbmdNb2RlO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgIGF1ZGlvOiBmYWxzZSxcbiAgICB2aWRlbzogdmlkZW9cbiAgfSk7XG59XG5mdW5jdGlvbiBlbnVtZXJhdGVWaWRlb0RldmljZXMoKSB7XG4gIHJldHVybiBfZW51bWVyYXRlVmlkZW9EZXZpY2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZW51bWVyYXRlVmlkZW9EZXZpY2VzKCkge1xuICBfZW51bWVyYXRlVmlkZW9EZXZpY2VzID0gYXN5bmNUb0dlbmVyYXRvcl9kZWZhdWx0KCkoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvcl9kZWZhdWx0LmEubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICB2YXIgZGV2aWNlcztcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JfZGVmYXVsdC5hLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyO1xuICAgICAgICAgIHJldHVybiBlbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBkZXZpY2VzID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgZGV2aWNlcy5maWx0ZXIoZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCc7XG4gICAgICAgICAgfSkpO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9lbnVtZXJhdGVWaWRlb0RldmljZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZVRyYWNrKCkge1xuICBpZiAoIXN0cmVhbVJlZikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciB0cmFja3MgPSBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgcmV0dXJuIHRyYWNrcyAmJiB0cmFja3MgIT09IG51bGwgJiYgdHJhY2tzICE9PSB2b2lkIDAgJiYgdHJhY2tzLmxlbmd0aCA/IHRyYWNrc1swXSA6IG51bGw7XG59XG5cbi8qKlxuICogVXNlZCBmb3IgYWNjZXNzaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhY3RpdmUgc3RyZWFtIHRyYWNrIGFuZCBhdmFpbGFibGUgdmlkZW8gZGV2aWNlcy5cbiAqL1xudmFyIFF1YWdnYUpTQ2FtZXJhQWNjZXNzID0ge1xuICByZXF1ZXN0ZWRWaWRlb0VsZW1lbnQ6IG51bGwsXG4gIHJlcXVlc3Q6IGZ1bmN0aW9uIHJlcXVlc3QodmlkZW8sIHZpZGVvQ29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gYXN5bmNUb0dlbmVyYXRvcl9kZWZhdWx0KCkoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvcl9kZWZhdWx0LmEubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgdmFyIG5ld0NvbnN0cmFpbnRzO1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yX2RlZmF1bHQuYS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ID0gdmlkZW87XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiBwaWNrQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cyk7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgbmV3Q29uc3RyYWludHMgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBpbml0Q2FtZXJhKHZpZGVvLCBuZXdDb25zdHJhaW50cykpO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlKTtcbiAgICB9KSkoKTtcbiAgfSxcbiAgcmVsZWFzZTogZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICB2YXIgdHJhY2tzID0gc3RyZWFtUmVmICYmIHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xuICAgIGlmIChRdWFnZ2FKU0NhbWVyYUFjY2Vzcy5yZXF1ZXN0ZWRWaWRlb0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIFF1YWdnYUpTQ2FtZXJhQWNjZXNzLnJlcXVlc3RlZFZpZGVvRWxlbWVudC5wYXVzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHJhY2tzICYmIHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtUmVmID0gbnVsbDtcbiAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwgMCk7XG4gICAgfSk7XG4gIH0sXG4gIGVudW1lcmF0ZVZpZGVvRGV2aWNlczogZW51bWVyYXRlVmlkZW9EZXZpY2VzLFxuICBnZXRBY3RpdmVTdHJlYW1MYWJlbDogZnVuY3Rpb24gZ2V0QWN0aXZlU3RyZWFtTGFiZWwoKSB7XG4gICAgdmFyIHRyYWNrID0gZ2V0QWN0aXZlVHJhY2soKTtcbiAgICByZXR1cm4gdHJhY2sgPyB0cmFjay5sYWJlbCA6ICcnO1xuICB9LFxuICBnZXRBY3RpdmVUcmFjazogZ2V0QWN0aXZlVHJhY2ssXG4gIGRpc2FibGVUb3JjaDogZnVuY3Rpb24gZGlzYWJsZVRvcmNoKCkge1xuICAgIHJldHVybiBhc3luY1RvR2VuZXJhdG9yX2RlZmF1bHQoKSggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yX2RlZmF1bHQuYS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgdmFyIHRyYWNrO1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yX2RlZmF1bHQuYS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRyYWNrID0gZ2V0QWN0aXZlVHJhY2soKTsgLy8gVE9ETzogc2hvdWxkIHdlIGFjcXVpcmUgY2FtZXJhIGFjY2VzcyBldmVuIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCBjYW1lcmEgb3Blbj9cbiAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgaGFwcGVucyBvbiBpT1Mgb3IgYW5vdGhlciBkZXZpY2Ugd2hlcmUgdG9yY2ggaXNuJ3Qgc3VwcG9ydGVkIGF0IGFsbD8gU2hvdWxkIHdlIHRocm93IGFuIGVycm9yP1xuICAgICAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB0cmFjay5hcHBseUNvbnN0cmFpbnRzKHtcbiAgICAgICAgICAgICAgYWR2YW5jZWQ6IFt7XG4gICAgICAgICAgICAgICAgdG9yY2g6IGZhbHNlXG4gICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDExO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA3O1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICBpZiAoX2NvbnRleHQyLnQwIGluc3RhbmNlb2YgT3ZlcmNvbnN0cmFpbmVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdxdWFnZ2EyL0NhbWVyYUFjY2VzczogVG9yY2ggbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQyLnQwO1xuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzIsIDddXSk7XG4gICAgfSkpKCk7XG4gIH0sXG4gIGVuYWJsZVRvcmNoOiBmdW5jdGlvbiBlbmFibGVUb3JjaCgpIHtcbiAgICByZXR1cm4gYXN5bmNUb0dlbmVyYXRvcl9kZWZhdWx0KCkoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvcl9kZWZhdWx0LmEubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgIHZhciB0cmFjaztcbiAgICAgIHJldHVybiByZWdlbmVyYXRvcl9kZWZhdWx0LmEud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7IC8vIFRPRE86IHNob3VsZCB3ZSBhY3F1aXJlIGNhbWVyYSBhY2Nlc3MgZXZlbiBpZiB0aGVyZSdzIG5vIGN1cnJlbnQgY2FtZXJhIG9wZW4/XG4gICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGhhcHBlbnMgb24gaU9TIG9yIGFub3RoZXIgZGV2aWNlIHdoZXJlIHRvcmNoIGlzbid0IHN1cHBvcnRlZCBhdCBhbGw/IFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgICAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDI7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2suYXBwbHlDb25zdHJhaW50cyh7XG4gICAgICAgICAgICAgIGFkdmFuY2VkOiBbe1xuICAgICAgICAgICAgICAgIHRvcmNoOiB0cnVlXG4gICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDExO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSA3O1xuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICBpZiAoX2NvbnRleHQzLnQwIGluc3RhbmNlb2YgT3ZlcmNvbnN0cmFpbmVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdxdWFnZ2EyL0NhbWVyYUFjY2VzczogVG9yY2ggbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQzLnQwO1xuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUzLCBudWxsLCBbWzIsIDddXSk7XG4gICAgfSkpKCk7XG4gIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjYW1lcmFfYWNjZXNzID0gKFF1YWdnYUpTQ2FtZXJhQWNjZXNzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FuYWx5dGljcy9yZXN1bHRfY29sbGVjdG9yLnRzXG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGNvZGVSZXN1bHQsIGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QgJiYgbGlzdC5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhpdGVtKTtcbiAgICByZXR1cm4ga2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gaXRlbVtrZXldID09PSBjb2RlUmVzdWx0W2tleV07XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFzc2VzRmlsdGVyKGNvZGVSZXN1bHQsIGZpbHRlcikge1xuICByZXR1cm4gdHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IGZpbHRlcihjb2RlUmVzdWx0KSA6IHRydWU7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciByZXN1bHRfY29sbGVjdG9yID0gKHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoY29uZmlnKSB7XG4gICAgdmFyIF9jb25maWckY2FwYWNpdHk7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEhY29uZmlnLndpbGxSZWFkRnJlcXVlbnRseVxuICAgIH0pO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIGNhcGFjaXR5ID0gKF9jb25maWckY2FwYWNpdHkgPSBjb25maWcuY2FwYWNpdHkpICE9PSBudWxsICYmIF9jb25maWckY2FwYWNpdHkgIT09IHZvaWQgMCA/IF9jb25maWckY2FwYWNpdHkgOiAyMDtcbiAgICB2YXIgY2FwdHVyZSA9IGNvbmZpZy5jYXB0dXJlID09PSB0cnVlO1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0KSB7XG4gICAgICByZXR1cm4gISFjYXBhY2l0eSAmJiBjb2RlUmVzdWx0ICYmICFjb250YWlucyhjb2RlUmVzdWx0LCBjb25maWcuYmxhY2tsaXN0KSAmJiBwYXNzZXNGaWx0ZXIoY29kZVJlc3VsdCwgY29uZmlnLmZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhZGRSZXN1bHQ6IGZ1bmN0aW9uIGFkZFJlc3VsdChkYXRhLCBpbWFnZVNpemUsIGNvZGVSZXN1bHQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9OyAvLyB0aGlzIGlzICdhbnknIHRvIGF2b2lkIGhhdmluZyB0byBjb25zdHJ1Y3QgYSB3aG9sZSBRdWFnZ2FKU0NvZGVSZXN1bHQgOnxcbiAgICAgICAgaWYgKG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0KSkge1xuICAgICAgICAgIGNhcGFjaXR5LS07XG4gICAgICAgICAgcmVzdWx0LmNvZGVSZXN1bHQgPSBjb2RlUmVzdWx0O1xuICAgICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZVNpemUueDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZVNpemUueTtcbiAgICAgICAgICAgIGltYWdlX2RlYnVnW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRyYXdJbWFnZShkYXRhLCBpbWFnZVNpemUsIGN0eCk7XG4gICAgICAgICAgICByZXN1bHQuZnJhbWUgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0UmVzdWx0czogZnVuY3Rpb24gZ2V0UmVzdWx0cygpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb25maWcvY29uZmlnLmRldi50c1xudmFyIERldkNvbmZpZyA9IHtcbiAgaW5wdXRTdHJlYW06IHtcbiAgICBuYW1lOiAnTGl2ZScsXG4gICAgdHlwZTogJ0xpdmVTdHJlYW0nLFxuICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICB3aWR0aDogNjQwLFxuICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICAvLyBhc3BlY3RSYXRpbzogNjQwLzQ4MCwgLy8gb3B0aW9uYWxcbiAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcgLy8gb3IgdXNlclxuICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxuICAgIH0sXG5cbiAgICBhcmVhOiB7XG4gICAgICB0b3A6ICcwJScsXG4gICAgICByaWdodDogJzAlJyxcbiAgICAgIGxlZnQ6ICcwJScsXG4gICAgICBib3R0b206ICcwJSdcbiAgICB9LFxuICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgfSxcblxuICBsb2NhdGU6IHRydWUsXG4gIG51bU9mV29ya2VyczogMCxcbiAgZGVjb2Rlcjoge1xuICAgIHJlYWRlcnM6IFsnY29kZV8xMjhfcmVhZGVyJ10sXG4gICAgZGVidWc6IHtcbiAgICAgIGRyYXdCb3VuZGluZ0JveDogZmFsc2UsXG4gICAgICBzaG93RnJlcXVlbmN5OiBmYWxzZSxcbiAgICAgIGRyYXdTY2FubGluZTogZmFsc2UsXG4gICAgICBzaG93UGF0dGVybjogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGxvY2F0b3I6IHtcbiAgICBoYWxmU2FtcGxlOiB0cnVlLFxuICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsXG4gICAgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICBkZWJ1Zzoge1xuICAgICAgc2hvd0NhbnZhczogZmFsc2UsXG4gICAgICBzaG93UGF0Y2hlczogZmFsc2UsXG4gICAgICBzaG93Rm91bmRQYXRjaGVzOiBmYWxzZSxcbiAgICAgIHNob3dTa2VsZXRvbjogZmFsc2UsXG4gICAgICBzaG93TGFiZWxzOiBmYWxzZSxcbiAgICAgIHNob3dQYXRjaExhYmVsczogZmFsc2UsXG4gICAgICBzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHM6IGZhbHNlLFxuICAgICAgYm94RnJvbVBhdGNoZXM6IHtcbiAgICAgICAgc2hvd1RyYW5zZm9ybWVkOiBmYWxzZSxcbiAgICAgICAgc2hvd1RyYW5zZm9ybWVkQm94OiBmYWxzZSxcbiAgICAgICAgc2hvd0JCOiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbmZpZ19kZXYgPSAoRGV2Q29uZmlnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbmZpZy9jb25maWcubm9kZS50c1xudmFyIE5vZGVDb25maWcgPSB7XG4gIGlucHV0U3RyZWFtOiB7XG4gICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcbiAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgc2l6ZTogODAwLFxuICAgIGFyZWE6IHtcbiAgICAgIHRvcDogJzAlJyxcbiAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgbGVmdDogJzAlJyxcbiAgICAgIGJvdHRvbTogJzAlJ1xuICAgIH0sXG4gICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICB9LFxuXG4gIGxvY2F0ZTogdHJ1ZSxcbiAgbnVtT2ZXb3JrZXJzOiAwLFxuICBkZWNvZGVyOiB7XG4gICAgcmVhZGVyczogWydjb2RlXzEyOF9yZWFkZXInXVxuICB9LFxuICBsb2NhdG9yOiB7XG4gICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICBwYXRjaFNpemU6ICdtZWRpdW0nIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbmZpZ19ub2RlID0gKE5vZGVDb25maWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29uZmlnL2NvbmZpZy5wcm9kLnRzXG52YXIgUHJvZENvbmZpZyA9IHtcbiAgaW5wdXRTdHJlYW06IHtcbiAgICBuYW1lOiAnTGl2ZScsXG4gICAgdHlwZTogJ0xpdmVTdHJlYW0nLFxuICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICB3aWR0aDogNjQwLFxuICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICAvLyBhc3BlY3RSYXRpbzogNjQwLzQ4MCwgLy8gb3B0aW9uYWxcbiAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcgLy8gb3IgdXNlclxuICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxuICAgIH0sXG5cbiAgICBhcmVhOiB7XG4gICAgICB0b3A6ICcwJScsXG4gICAgICByaWdodDogJzAlJyxcbiAgICAgIGxlZnQ6ICcwJScsXG4gICAgICBib3R0b206ICcwJSdcbiAgICB9LFxuICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgfSxcblxuICBsb2NhdGU6IHRydWUsXG4gIG51bU9mV29ya2VyczogNCxcbiAgZGVjb2Rlcjoge1xuICAgIHJlYWRlcnM6IFsnY29kZV8xMjhfcmVhZGVyJ11cbiAgfSxcbiAgbG9jYXRvcjoge1xuICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgcGF0Y2hTaXplOiAnbWVkaXVtJyAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxuICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb25maWdfcHJvZCA9IChQcm9kQ29uZmlnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbmZpZy9jb25maWcudHNcblxuXG5cbnZhciBFeHBvcnRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBRdWFnZ2FDb25maWc7XG4gIGlmIChmYWxzZSkge30gZWxzZSBpZiAodHJ1ZSkge1xuICAgIFF1YWdnYUNvbmZpZyA9IGNvbmZpZ19ub2RlO1xuICB9IGVsc2Uge31cbiAgcmV0dXJuIFF1YWdnYUNvbmZpZztcbn0oKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbmZpZ19jb25maWcgPSAoRXhwb3J0Q29uZmlnKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJnbC1tYXRyaXhcIlxudmFyIGV4dGVybmFsX2dsX21hdHJpeF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2lucHV0L2ZyYW1lX2dyYWJiZXIuanNcbnZhciBmcmFtZV9ncmFiYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG52YXIgZnJhbWVfZ3JhYmJlcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihmcmFtZV9ncmFiYmVyKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanNcbnZhciBzbGljZWRUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgc2xpY2VkVG9BcnJheV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihzbGljZWRUb0FycmF5KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImdldC1waXhlbHNcIlxudmFyIGV4dGVybmFsX2dldF9waXhlbHNfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG52YXIgZXh0ZXJuYWxfZ2V0X3BpeGVsc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihleHRlcm5hbF9nZXRfcGl4ZWxzXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW0udHNcblxuLy8gVE9ETzogSXQncyBwcmV0dHkgbGlrZWx5IHRoYXQgdGhpcyBzaGFyZXMgY29kZSB3aXRoIHRoZSBicm93c2VyIHZlcnNpb24sIGludmVzdGlnYXRlIHRoYXRcbi8vIEZPUiBBTllPTkUgSU4gSEVSRSBJTiBUSEUgRlVUVVJFOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGlucHV0X3N0cmVhbSBtb2R1bGUgdXNlZCBmb3IgdGhlIE5vZGUgYnVuZGxlLlxuLy8gd2VicGFjay5jb25maWcuanMgKnJlcGxhY2VzKiB0aGlzIHdpdGggaW5wdXRfc3RyZWFtX2Jyb3dzZXIudHMgd2hlbiB0aGUgYnVuZGxlIGlzIGJlaW5nIGJ1aWx0IGZvciBicm93c2VyLlxuXG5cbnZhciBpbnB1dFN0cmVhbUZhY3RvcnkgPSB7XG4gIGNyZWF0ZVZpZGVvU3RyZWFtOiBmdW5jdGlvbiBjcmVhdGVWaWRlb1N0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVZpZGVvU3RyZWFtIG5vdCBhdmFpbGFibGUnKTtcbiAgfSxcbiAgY3JlYXRlTGl2ZVN0cmVhbTogZnVuY3Rpb24gY3JlYXRlTGl2ZVN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZUxpdmVTdHJlYW0gbm90IGF2YWlsYWJsZScpO1xuICB9LFxuICBjcmVhdGVJbWFnZVN0cmVhbTogZnVuY3Rpb24gY3JlYXRlSW1hZ2VTdHJlYW0oKSB7XG4gICAgLy8gY29uc29sZS53YXJuKCcqIElucHV0U3RyZWFtTm9kZSBjcmVhdGVJbWFnZVN0cmVhbScpO1xuICAgIHZhciBfY29uZmlnID0gbnVsbDtcbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIHZhciBoZWlnaHQgPSAwO1xuICAgIHZhciBsb2FkZWQgPSBmYWxzZTtcbiAgICAvLyBUT0RPOiBmcmFtZSBzaG91bGQgYmUgYSB0eXBlIE5kQXJyYXksIGJ1dCBOZEFycmF5IGRvZXNuJ3QgaGF2ZSB0cyBkZWZpbml0aW9uc1xuICAgIC8vIFRPRE86IHRoZXJlIGlzIGEgdHMtbmRhcnJheSB0aGF0IG1pZ2h0IHdvcmssIHRob3VnaFxuICAgIHZhciBmcmFtZSA9IG51bGw7XG4gICAgdmFyIGJhc2VVcmw7XG4gICAgdmFyIF9lbmRlZCA9IGZhbHNlO1xuICAgIHZhciBjYWxjdWxhdGVkV2lkdGg7XG4gICAgdmFyIGNhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgdmFyIF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICB2YXIgX2V2ZW50SGFuZGxlcnMgPSB7fTtcbiAgICB2YXIgX3RvcFJpZ2h0ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB0eXBlOiAnUG9pbnQnXG4gICAgfTtcbiAgICB2YXIgX2NhbnZhc1NpemUgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHR5cGU6ICdYWVNpemUnXG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqLyAvLyBmYWxzZSBlc2xpbnQgZXJyb3JzPyB3ZWlyZC5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFyIHNpemUgPSAwO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YXIgZnJhbWVJZHggPSAwO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gICAgZnVuY3Rpb24gbG9hZEltYWdlcygpIHtcbiAgICAgIHZhciBfY29uZmlnMjtcbiAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuICAgICAgZXh0ZXJuYWxfZ2V0X3BpeGVsc19kZWZhdWx0KCkoYmFzZVVybCwgKF9jb25maWcyID0gX2NvbmZpZykgPT09IG51bGwgfHwgX2NvbmZpZzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb25maWcyLm1pbWUsIGZ1bmN0aW9uIChlcnIsIHBpeGVscykge1xuICAgICAgICB2YXIgX2NvbmZpZzMsIF9jb25maWc0O1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignKioqKiBxdWFnZ2EgbG9hZEltYWdlcyBlcnJvcjonLCBlcnIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3IgZGVjb2RpbmcgcGl4ZWxzIGluIGxvYWRJbWFnZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZmFsc2UpIHt9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgZnJhbWUgPSBwaXhlbHM7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICB2YXIgX3BpeGVscyRzaGFwZSA9IHNsaWNlZFRvQXJyYXlfZGVmYXVsdCgpKHBpeGVscy5zaGFwZSwgMik7XG4gICAgICAgIHdpZHRoID0gX3BpeGVscyRzaGFwZVswXTtcbiAgICAgICAgaGVpZ2h0ID0gX3BpeGVscyRzaGFwZVsxXTtcbiAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gKF9jb25maWczID0gX2NvbmZpZykgIT09IG51bGwgJiYgX2NvbmZpZzMgIT09IHZvaWQgMCAmJiBfY29uZmlnMy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gX2NvbmZpZy5zaXplIDogTWF0aC5mbG9vcih3aWR0aCAvIGhlaWdodCAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSAoX2NvbmZpZzQgPSBfY29uZmlnKSAhPT0gbnVsbCAmJiBfY29uZmlnNCAhPT0gdm9pZCAwICYmIF9jb25maWc0LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBNYXRoLmZsb29yKGhlaWdodCAvIHdpZHRoICogX2NvbmZpZy5zaXplKSA6IF9jb25maWcuc2l6ZSA6IGhlaWdodDtcbiAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZSwgYXJncykge1xuICAgICAgdmFyIGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhcix2YXJzLW9uLXRvcFxuICAgIHZhciBpbnB1dFN0cmVhbSA9IHtcbiAgICAgIHRyaWdnZXI6IHB1Ymxpc2hFdmVudCxcbiAgICAgIGdldFdpZHRoOiBmdW5jdGlvbiBnZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgIH0sXG4gICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uIGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICB9LFxuICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uIHNldFdpZHRoKHcpIHtcbiAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gdztcbiAgICAgIH0sXG4gICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uIHNldEhlaWdodChoKSB7XG4gICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBoO1xuICAgICAgfSxcbiAgICAgIGdldFJlYWxXaWR0aDogZnVuY3Rpb24gZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICB9LFxuICAgICAgZ2V0UmVhbEhlaWdodDogZnVuY3Rpb24gZ2V0UmVhbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgIH0sXG4gICAgICBzZXRJbnB1dFN0cmVhbTogZnVuY3Rpb24gc2V0SW5wdXRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIHZhciBfY29uZmlnNTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICBfY29uZmlnID0gc3RyZWFtO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICBiYXNlVXJsID0gKF9jb25maWc1ID0gX2NvbmZpZykgPT09IG51bGwgfHwgX2NvbmZpZzUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb25maWc1LnNyYztcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgIGxvYWRJbWFnZXMoKTtcbiAgICAgIH0sXG4gICAgICBlbmRlZDogZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgICAgIHJldHVybiBfZW5kZWQ7XG4gICAgICB9LFxuICAgICAgc2V0QXR0cmlidXRlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUoKSB7fSxcbiAgICAgIGdldENvbmZpZzogZnVuY3Rpb24gZ2V0Q29uZmlnKCkge1xuICAgICAgICByZXR1cm4gX2NvbmZpZztcbiAgICAgIH0sXG4gICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICB9LFxuICAgICAgcGxheTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgc2V0Q3VycmVudFRpbWU6IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKHRpbWUpIHtcbiAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgICAgfSxcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYpIHtcbiAgICAgICAgaWYgKF9ldmVudE5hbWVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xuICAgICAgICAgIGlmICghX2V2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goZik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGVhckV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoX2V2ZW50SGFuZGxlcnMpLmZvckVhY2goZnVuY3Rpb24gKGluZCkge1xuICAgICAgICAgIHJldHVybiBkZWxldGUgX2V2ZW50SGFuZGxlcnNbaW5kXTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2V0VG9wUmlnaHQ6IGZ1bmN0aW9uIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XG4gICAgICAgIF90b3BSaWdodC54ID0gdG9wUmlnaHQueDtcbiAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgICAgfSxcbiAgICAgIGdldFRvcFJpZ2h0OiBmdW5jdGlvbiBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIF90b3BSaWdodDtcbiAgICAgIH0sXG4gICAgICBzZXRDYW52YXNTaXplOiBmdW5jdGlvbiBzZXRDYW52YXNTaXplKHN6KSB7XG4gICAgICAgIF9jYW52YXNTaXplLnggPSBzei54O1xuICAgICAgICBfY2FudmFzU2l6ZS55ID0gc3oueTtcbiAgICAgIH0sXG4gICAgICBnZXRDYW52YXNTaXplOiBmdW5jdGlvbiBnZXRDYW52YXNTaXplKCkge1xuICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XG4gICAgICB9LFxuICAgICAgZ2V0RnJhbWU6IGZ1bmN0aW9uIGdldEZyYW1lKCkge1xuICAgICAgICBpZiAoIWxvYWRlZCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpbnB1dF9zdHJlYW0gPSAoaW5wdXRTdHJlYW1GYWN0b3J5KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvbG9jYXRvci9iYXJjb2RlX2xvY2F0b3IuanNcbnZhciBiYXJjb2RlX2xvY2F0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvUXVhZ2dhQ29udGV4dC50c1xuXG5cblxudmFyIFF1YWdnYUNvbnRleHRfUXVhZ2dhQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDbGFzc19kZWZhdWx0KCkoZnVuY3Rpb24gUXVhZ2dhQ29udGV4dCgpIHtcbiAgY2xhc3NDYWxsQ2hlY2tfZGVmYXVsdCgpKHRoaXMsIFF1YWdnYUNvbnRleHQpO1xuICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkodGhpcywgXCJjb25maWdcIiwgdm9pZCAwKTtcbiAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKHRoaXMsIFwiaW5wdXRTdHJlYW1cIiwgdm9pZCAwKTtcbiAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKHRoaXMsIFwiZnJhbWVncmFiYmVyXCIsIHZvaWQgMCk7XG4gIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcImlucHV0SW1hZ2VXcmFwcGVyXCIsIHZvaWQgMCk7XG4gIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcInN0b3BwZWRcIiwgZmFsc2UpO1xuICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkodGhpcywgXCJib3hTaXplXCIsIHZvaWQgMCk7XG4gIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcInJlc3VsdENvbGxlY3RvclwiLCB2b2lkIDApO1xuICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkodGhpcywgXCJkZWNvZGVyXCIsIHZvaWQgMCk7XG4gIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcIndvcmtlclBvb2xcIiwgW10pO1xuICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkodGhpcywgXCJvblVJVGhyZWFkXCIsIHRydWUpO1xuICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkodGhpcywgXCJjYW52YXNDb250YWluZXJcIiwgbmV3IFF1YWdnYUNvbnRleHRfQ2FudmFzQ29udGFpbmVyKCkpO1xufSk7XG52YXIgUXVhZ2dhQ29udGV4dF9DYW52YXNJbmZvID0gLyojX19QVVJFX18qL2NyZWF0ZUNsYXNzX2RlZmF1bHQoKShmdW5jdGlvbiBDYW52YXNJbmZvKCkge1xuICBjbGFzc0NhbGxDaGVja19kZWZhdWx0KCkodGhpcywgQ2FudmFzSW5mbyk7XG4gIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcImltYWdlXCIsIHZvaWQgMCk7XG4gIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcIm92ZXJsYXlcIiwgdm9pZCAwKTtcbn0pO1xudmFyIFF1YWdnYUNvbnRleHRfQ2FudmFzQ29udGFpbmVyID0gLyojX19QVVJFX18qL2NyZWF0ZUNsYXNzX2RlZmF1bHQoKShmdW5jdGlvbiBDYW52YXNDb250YWluZXIoKSB7XG4gIGNsYXNzQ2FsbENoZWNrX2RlZmF1bHQoKSh0aGlzLCBDYW52YXNDb250YWluZXIpO1xuICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkodGhpcywgXCJjdHhcIiwgdm9pZCAwKTtcbiAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKHRoaXMsIFwiZG9tXCIsIHZvaWQgMCk7XG4gIHRoaXMuY3R4ID0gbmV3IFF1YWdnYUNvbnRleHRfQ2FudmFzSW5mbygpO1xuICB0aGlzLmRvbSA9IG5ldyBRdWFnZ2FDb250ZXh0X0NhbnZhc0luZm8oKTtcbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcXVhZ2dhL2dldFZpZXdQb3J0LnRzXG5mdW5jdGlvbiBnZXRWaWV3UG9ydF9nZXRWaWV3UG9ydCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhbHJlYWR5IGEgRE9NIGVsZW1lbnRcbiAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRhcmdldC5ub2RlTmFtZSAmJiB0YXJnZXQubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIC8vIFVzZSAnI2ludGVyYWN0aXZlLnZpZXdwb3J0JyBhcyBhIGZhbGxiYWNrIHNlbGVjdG9yIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgdmFyIHNlbGVjdG9yID0gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyB0YXJnZXQgOiAnI2ludGVyYWN0aXZlLnZpZXdwb3J0JztcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcXVhZ2dhL2luaXRCdWZmZXJzLnRzXG5cblxuXG5leHRlcm5hbF9nbF9tYXRyaXhfW1wiZ2xNYXRyaXhcIl0uc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtcblxuLy8gVE9ETzogbmVlZCB0eXBlc2NyaXB0IGRlZiBmb3IgQmFyY29kZUxvY2F0b3JcbmZ1bmN0aW9uIGluaXRCdWZmZXJzX2luaXRCdWZmZXJzKGlucHV0U3RyZWFtLCBpbWFnZVdyYXBwZXIsIGxvY2F0b3IpIHtcbiAgdmFyIGlucHV0SW1hZ2VXcmFwcGVyID0gaW1hZ2VXcmFwcGVyIHx8IG5ldyBpbWFnZV93cmFwcGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHtcbiAgICB4OiBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLFxuICAgIHk6IGlucHV0U3RyZWFtLmdldEhlaWdodCgpLFxuICAgIHR5cGU6ICdYWVNpemUnXG4gIH0pO1xuICBpZiAoZmFsc2UpIHt9XG4gIHZhciBib3hTaXplID0gW2V4dGVybmFsX2dsX21hdHJpeF9bXCJ2ZWMyXCJdLmNsb25lKFswLCAwXSksIGV4dGVybmFsX2dsX21hdHJpeF9bXCJ2ZWMyXCJdLmNsb25lKFswLCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSwgZXh0ZXJuYWxfZ2xfbWF0cml4X1tcInZlYzJcIl0uY2xvbmUoW2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55XSksIGV4dGVybmFsX2dsX21hdHJpeF9bXCJ2ZWMyXCJdLmNsb25lKFtpbnB1dEltYWdlV3JhcHBlci5zaXplLngsIDBdKV07XG4gIGJhcmNvZGVfbG9jYXRvcltcImFcIiAvKiBkZWZhdWx0ICovXS5pbml0KGlucHV0SW1hZ2VXcmFwcGVyLCBsb2NhdG9yKTtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dEltYWdlV3JhcHBlcjogaW5wdXRJbWFnZVdyYXBwZXIsXG4gICAgYm94U2l6ZTogYm94U2l6ZVxuICB9O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcXVhZ2dhL2luaXRDYW52YXMudHNcblxuZnVuY3Rpb24gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yLCBjbGFzc05hbWUpIHtcbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICBpZiAoIWNhbnZhcykge1xuICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gIH1cbiAgcmV0dXJuIGNhbnZhcztcbn1cbmZ1bmN0aW9uIGdldENhbnZhc0FuZENvbnRleHQoc2VsZWN0b3IsIGNsYXNzTmFtZSwgb3B0aW9ucykge1xuICB2YXIgY2FudmFzID0gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yLCBjbGFzc05hbWUpO1xuICBjb25zb2xlLndhcm4oJyogaW5pdENhbnZhcyBnZXRDYW52YXNBbmRDb250ZXh0Jyk7XG4gIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJywge1xuICAgIHdpbGxSZWFkRnJlcXVlbnRseTogb3B0aW9ucy53aWxsUmVhZEZyZXF1ZW50bHlcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9O1xufVxuZnVuY3Rpb24gaW5pdENhbnZhc2VzKGNhbnZhc1NpemUsIF9yZWYpIHtcbiAgdmFyIHdpbGxSZWFkRnJlcXVlbnRseSA9IF9yZWYud2lsbFJlYWRGcmVxdWVudGx5O1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBpbWFnZSA9IGdldENhbnZhc0FuZENvbnRleHQoJ2NhbnZhcy5pbWdCdWZmZXInLCAnaW1nQnVmZmVyJywge1xuICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB3aWxsUmVhZEZyZXF1ZW50bHlcbiAgICB9KTtcbiAgICB2YXIgb3ZlcmxheSA9IGdldENhbnZhc0FuZENvbnRleHQoJ2NhbnZhcy5kcmF3aW5nQnVmZmVyJywgJ2RyYXdpbmdCdWZmZXInLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHdpbGxSZWFkRnJlcXVlbnRseVxuICAgIH0pO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgIGltYWdlLmNhbnZhcy53aWR0aCA9IG92ZXJsYXkuY2FudmFzLndpZHRoID0gY2FudmFzU2l6ZS54O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICBpbWFnZS5jYW52YXMuaGVpZ2h0ID0gb3ZlcmxheS5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xuICAgIHJldHVybiB7XG4gICAgICBkb206IHtcbiAgICAgICAgaW1hZ2U6IGltYWdlLmNhbnZhcyxcbiAgICAgICAgb3ZlcmxheTogb3ZlcmxheS5jYW52YXNcbiAgICAgIH0sXG4gICAgICBjdHg6IHtcbiAgICAgICAgaW1hZ2U6IGltYWdlLmNvbnRleHQsXG4gICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY29udGV4dFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpbml0Q2FudmFzX2luaXRDYW52YXMoY29udGV4dCkge1xuICB2YXIgX2NvbnRleHQkY29uZmlnLCBfY29udGV4dCRjb25maWckaW5wdXQsIF9jb250ZXh0JGNvbmZpZzIsIF9jb250ZXh0JGNvbmZpZzIkaW5wdSwgX2NvbnRleHQkY29uZmlnMywgX2NvbnRleHQkY29uZmlnMyRpbnB1O1xuICB2YXIgdmlld3BvcnQgPSBnZXRWaWV3UG9ydF9nZXRWaWV3UG9ydChjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfY29udGV4dCRjb25maWcgPSBjb250ZXh0LmNvbmZpZykgPT09IG51bGwgfHwgX2NvbnRleHQkY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2NvbnRleHQkY29uZmlnJGlucHV0ID0gX2NvbnRleHQkY29uZmlnLmlucHV0U3RyZWFtKSA9PT0gbnVsbCB8fCBfY29udGV4dCRjb25maWckaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb250ZXh0JGNvbmZpZyRpbnB1dC50YXJnZXQpO1xuICB2YXIgdHlwZSA9IGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9jb250ZXh0JGNvbmZpZzIgPSBjb250ZXh0LmNvbmZpZykgPT09IG51bGwgfHwgX2NvbnRleHQkY29uZmlnMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9jb250ZXh0JGNvbmZpZzIkaW5wdSA9IF9jb250ZXh0JGNvbmZpZzIuaW5wdXRTdHJlYW0pID09PSBudWxsIHx8IF9jb250ZXh0JGNvbmZpZzIkaW5wdSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbnRleHQkY29uZmlnMiRpbnB1LnR5cGU7XG4gIGlmICghdHlwZSkgcmV0dXJuIG51bGw7XG4gIHZhciBjb250YWluZXIgPSBpbml0Q2FudmFzZXMoY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCksIHtcbiAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICEhKGNvbnRleHQgIT09IG51bGwgJiYgY29udGV4dCAhPT0gdm9pZCAwICYmIChfY29udGV4dCRjb25maWczID0gY29udGV4dC5jb25maWcpICE9PSBudWxsICYmIF9jb250ZXh0JGNvbmZpZzMgIT09IHZvaWQgMCAmJiAoX2NvbnRleHQkY29uZmlnMyRpbnB1ID0gX2NvbnRleHQkY29uZmlnMy5pbnB1dFN0cmVhbSkgIT09IG51bGwgJiYgX2NvbnRleHQkY29uZmlnMyRpbnB1ICE9PSB2b2lkIDAgJiYgX2NvbnRleHQkY29uZmlnMyRpbnB1LndpbGxSZWFkRnJlcXVlbnRseSlcbiAgfSk7XG4gIGlmICghY29udGFpbmVyKSByZXR1cm4ge1xuICAgIGRvbToge1xuICAgICAgaW1hZ2U6IG51bGwsXG4gICAgICBvdmVybGF5OiBudWxsXG4gICAgfSxcbiAgICBjdHg6IHtcbiAgICAgIGltYWdlOiBudWxsLFxuICAgICAgb3ZlcmxheTogbnVsbFxuICAgIH1cbiAgfTtcbiAgdmFyIGRvbSA9IGNvbnRhaW5lci5kb207XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ0ltYWdlU3RyZWFtJyAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLmltYWdlKSkge1xuICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZChkb20uaW1hZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKCF2aWV3cG9ydC5jb250YWlucyhkb20ub3ZlcmxheSkpIHtcbiAgICAgICAgdmlld3BvcnQuYXBwZW5kQ2hpbGQoZG9tLm92ZXJsYXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29udGFpbmVyO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcXVhZ2dhL3F3b3JrZXIudHNcblxuZnVuY3Rpb24gcXdvcmtlcl9vd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIHF3b3JrZXJfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IHF3b3JrZXJfb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IHF3b3JrZXJfb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLyogV29ya2VyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlIHN0cmFpZ2h0IGZyb20gdGhlIG9yaWdpbmFsIHF1YWdnYS5qcyBmaWxlLlxuICogTm90IHByZXNlbnRseSB1c2VkLCBhcyB3b3JrZXIgc3VwcG9ydCBpcyBub24tZnVuY3Rpb25hbC4gIEtlZXBpbmcgdGhlbSBhcm91bmQgdGVtcG9yYXJpbHlcbiAqIHRvIHJlZmVyIHRvIHVudGlsIGl0IGlzIHJlLWltcGxlbWVudGVkLiBXZSBtYXkgYmUgYWJsZSB0byBmaXgvdXNlIHNvbWUgb2YgdGhpcy5cbiAqL1xuXG4vLyBUT0RPOiBuZWVkIGEgdHlwZXNjcmlwdCBpbnRlcmZhY2UgZm9yIEZyYW1lR3JhYmJlclxuXG52YXIgd29ya2VyUG9vbCA9IFtdO1xuZnVuY3Rpb24gdXBkYXRlV29ya2VycyhmcmFtZUdyYWJiZXIpIHtcbiAgdmFyIGF2YWlsYWJsZVdvcmtlcjtcbiAgaWYgKHdvcmtlclBvb2wubGVuZ3RoKSB7XG4gICAgYXZhaWxhYmxlV29ya2VyID0gd29ya2VyUG9vbC5maWx0ZXIoZnVuY3Rpb24gKHdvcmtlclRocmVhZCkge1xuICAgICAgcmV0dXJuICF3b3JrZXJUaHJlYWQuYnVzeTtcbiAgICB9KVswXTtcbiAgICBpZiAoYXZhaWxhYmxlV29ya2VyKSB7XG4gICAgICBmcmFtZUdyYWJiZXIuYXR0YWNoRGF0YShhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhKTtcbiAgICAgIGlmIChmcmFtZUdyYWJiZXIuZ3JhYigpKSB7XG4gICAgICAgIGF2YWlsYWJsZVdvcmtlci5idXN5ID0gdHJ1ZTtcbiAgICAgICAgYXZhaWxhYmxlV29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgY21kOiAncHJvY2VzcycsXG4gICAgICAgICAgaW1hZ2VEYXRhOiBhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhXG4gICAgICAgIH0sIFthdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb25maWdGb3JXb3JrZXIoY29uZmlnKSB7XG4gIHJldHVybiBxd29ya2VyX29iamVjdFNwcmVhZChxd29ya2VyX29iamVjdFNwcmVhZCh7fSwgY29uZmlnKSwge30sIHtcbiAgICBpbnB1dFN0cmVhbTogcXdvcmtlcl9vYmplY3RTcHJlYWQocXdvcmtlcl9vYmplY3RTcHJlYWQoe30sIGNvbmZpZy5pbnB1dFN0cmVhbSksIHt9LCB7XG4gICAgICB0YXJnZXQ6IG51bGxcbiAgICB9KVxuICB9KTtcbn1cblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gd29ya2VySW50ZXJmYWNlKGZhY3RvcnkpIHtcbiAgaWYgKGZhY3RvcnkpIHtcbiAgICB2YXIgUXVhZ2dhID0gZmFjdG9yeSgpW1wiZGVmYXVsdFwiXTtcbiAgICBpZiAoIVF1YWdnYSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICdldmVudCc6ICdlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdRdWFnZ2EgY291bGQgbm90IGJlIGNyZWF0ZWQnXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICB2YXIgaW1hZ2VXcmFwcGVyO1xuXG4gIC8vIEB0cy1pZ25vcmVcbiAgZnVuY3Rpb24gb25Qcm9jZXNzZWQocmVzdWx0KSB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAnZXZlbnQnOiAncHJvY2Vzc2VkJyxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgIH0sIFtpbWFnZVdyYXBwZXIuZGF0YS5idWZmZXJdKTtcbiAgfVxuICBmdW5jdGlvbiB3b3JrZXJJbnRlcmZhY2VSZWFkeSgpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICdldmVudCc6ICdpbml0aWFsaXplZCcsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xuICB9XG5cbiAgLy8gQHRzLWlnbm9yZVxuICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUuZGF0YS5jbWQgPT09ICdpbml0Jykge1xuICAgICAgdmFyIGNvbmZpZyA9IGUuZGF0YS5jb25maWc7XG4gICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgIGltYWdlV3JhcHBlciA9IG5ldyBRdWFnZ2EuSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgeDogZS5kYXRhLnNpemUueCxcbiAgICAgICAgeTogZS5kYXRhLnNpemUueVxuICAgICAgfSwgbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSkpO1xuICAgICAgUXVhZ2dhLmluaXQoY29uZmlnLCB3b3JrZXJJbnRlcmZhY2VSZWFkeSwgaW1hZ2VXcmFwcGVyKTtcbiAgICAgIFF1YWdnYS5vblByb2Nlc3NlZChvblByb2Nlc3NlZCk7XG4gICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAncHJvY2VzcycpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGltYWdlV3JhcHBlci5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICBRdWFnZ2Euc3RhcnQoKTtcbiAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdzZXRSZWFkZXJzJykge1xuICAgICAgUXVhZ2dhLnNldFJlYWRlcnMoZS5kYXRhLnJlYWRlcnMpO1xuICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3JlZ2lzdGVyUmVhZGVyJykge1xuICAgICAgUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyKGUuZGF0YS5uYW1lLCBlLmRhdGEucmVhZGVyKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVdvcmtlckJsb2IoKSB7XG4gIHZhciBibG9iLCBmYWN0b3J5U291cmNlO1xuXG4gIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAodHlwZW9mIF9fZmFjdG9yeVNvdXJjZV9fICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmYWN0b3J5U291cmNlID0gX19mYWN0b3J5U291cmNlX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgfVxuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gIGJsb2IgPSBuZXcgQmxvYihbJygnICsgd29ya2VySW50ZXJmYWNlLnRvU3RyaW5nKCkgKyAnKSgnICsgZmFjdG9yeVNvdXJjZSArICcpOyddLCB7XG4gICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCdcbiAgfSk7XG4gIHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cbmZ1bmN0aW9uIGluaXRXb3JrZXIoY29uZmlnLCBpbnB1dFN0cmVhbSwgY2IpIHtcbiAgdmFyIGJsb2JVUkwgPSBnZW5lcmF0ZVdvcmtlckJsb2IoKTtcbiAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVSTCk7XG4gIHZhciB3b3JrZXJUaHJlYWQgPSB7XG4gICAgd29ya2VyOiB3b3JrZXIsXG4gICAgaW1hZ2VEYXRhOiBuZXcgVWludDhBcnJheShpbnB1dFN0cmVhbS5nZXRXaWR0aCgpICogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkpLFxuICAgIGJ1c3k6IHRydWVcbiAgfTtcbiAgd29ya2VyVGhyZWFkLndvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmRhdGEuZXZlbnQgPT09ICdpbml0aWFsaXplZCcpIHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XG4gICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xuICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgaWYgKGZhbHNlKSB7fVxuICAgICAgY2Iod29ya2VyVGhyZWFkKTtcbiAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ3Byb2Nlc3NlZCcpIHtcbiAgICAgIHdvcmtlclRocmVhZC5pbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XG4gICAgICAvLyBUT0RPOiBob3cgdG8gdGhyZWFkIHB1Ymxpc2hSZXN1bHQgaW50byBoZXJlPyBUeXBlU2NyaXB0IHNheXMgaXQncyBub3QgaGVyZS4gaHR0cHM6Ly9naXRodWIuY29tL2VyaWNibGFkZS9xdWFnZ2EyL2lzc3Vlcy80NjYjaXNzdWVjb21tZW50LTE3MjQyNDgwODAgc2F5cyBpdCdzIG5lY2Vzc2FyeT9cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmICh0eXBlb2YgcHVibGlzaFJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwdWJsaXNoUmVzdWx0KGUuZGF0YS5yZXN1bHQsIHdvcmtlclRocmVhZC5pbWFnZURhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICBpZiAoZmFsc2UpIHt9XG4gICAgfVxuICB9O1xuICB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICBjbWQ6ICdpbml0JyxcbiAgICBzaXplOiB7XG4gICAgICB4OiBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLFxuICAgICAgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KClcbiAgICB9LFxuICAgIGltYWdlRGF0YTogd29ya2VyVGhyZWFkLmltYWdlRGF0YSxcbiAgICBjb25maWc6IGNvbmZpZ0Zvcldvcmtlcihjb25maWcpXG4gIH0sIFt3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xufVxuZnVuY3Rpb24gYWRqdXN0V29ya2VyUG9vbChjYXBhY2l0eSwgY29uZmlnLCBpbnB1dFN0cmVhbSwgY2IpIHtcbiAgdmFyIGluY3JlYXNlQnkgPSBjYXBhY2l0eSAtIHdvcmtlclBvb2wubGVuZ3RoO1xuICBpZiAoaW5jcmVhc2VCeSA9PT0gMCAmJiBjYikge1xuICAgIGNiKCk7XG4gIH0gZWxzZSBpZiAoaW5jcmVhc2VCeSA8IDApIHtcbiAgICB2YXIgd29ya2Vyc1RvVGVybWluYXRlID0gd29ya2VyUG9vbC5zbGljZShpbmNyZWFzZUJ5KTtcbiAgICB3b3JrZXJzVG9UZXJtaW5hdGUuZm9yRWFjaChmdW5jdGlvbiAod29ya2VyVGhyZWFkKSB7XG4gICAgICB3b3JrZXJUaHJlYWQud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgaWYgKGZhbHNlKSB7fVxuICAgIH0pO1xuICAgIHdvcmtlclBvb2wgPSB3b3JrZXJQb29sLnNsaWNlKDAsIGluY3JlYXNlQnkpO1xuICAgIGlmIChjYikge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdvcmtlckluaXRpYWxpemVkID0gZnVuY3Rpb24gd29ya2VySW5pdGlhbGl6ZWQod29ya2VyVGhyZWFkKSB7XG4gICAgICB3b3JrZXJQb29sLnB1c2god29ya2VyVGhyZWFkKTtcbiAgICAgIGlmICh3b3JrZXJQb29sLmxlbmd0aCA+PSBjYXBhY2l0eSAmJiBjYikge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNyZWFzZUJ5OyBpKyspIHtcbiAgICAgICAgaW5pdFdvcmtlcihjb25maWcsIGlucHV0U3RyZWFtLCB3b3JrZXJJbml0aWFsaXplZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBxd29ya2VyX3NldFJlYWRlcnMocmVhZGVycykge1xuICB3b3JrZXJQb29sLmZvckVhY2goZnVuY3Rpb24gKHdvcmtlclRocmVhZCkge1xuICAgIHJldHVybiB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgIGNtZDogJ3NldFJlYWRlcnMnLFxuICAgICAgcmVhZGVyczogcmVhZGVyc1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHF3b3JrZXJfcmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKSB7XG4gIHdvcmtlclBvb2wuZm9yRWFjaChmdW5jdGlvbiAod29ya2VyVGhyZWFkKSB7XG4gICAgcmV0dXJuIHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgY21kOiAncmVnaXN0ZXJSZWFkZXInLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHJlYWRlcjogcmVhZGVyXG4gICAgfSk7XG4gIH0pO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcXVhZ2dhL3NldHVwSW5wdXRTdHJlYW0udHNcbi8vIFRPRE86IG5lZWQgdG8gY3JlYXRlIGFuIElucHV0U3RyZWFtIHR5cGVzY3JpcHQgaW50ZXJmYWNlLCBzbyB3ZSBkb24ndCBoYXZlIGFuIFwiYW55XCIgaW4gdGhlIG5leHQgbGluZVxuZnVuY3Rpb24gc2V0dXBJbnB1dFN0cmVhbSgpIHtcbiAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdMaXZlU3RyZWFtJztcbiAgdmFyIHZpZXdwb3J0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBpbnB1dFN0cmVhbUZhY3RvcnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnVmlkZW9TdHJlYW0nOlxuICAgICAge1xuICAgICAgICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZpZGVvOiB2aWRlbyxcbiAgICAgICAgICBpbnB1dFN0cmVhbTogaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ0ltYWdlU3RyZWFtJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0U3RyZWFtOiBpbnB1dFN0cmVhbUZhY3RvcnkuY3JlYXRlSW1hZ2VTdHJlYW0oKVxuICAgICAgfTtcbiAgICBjYXNlICdMaXZlU3RyZWFtJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF92aWRlbyA9IG51bGw7XG4gICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgIF92aWRlbyA9IHZpZXdwb3J0LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgICAgICAgaWYgKCFfdmlkZW8pIHtcbiAgICAgICAgICAgIF92aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZChfdmlkZW8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZpZGVvOiBfdmlkZW8sXG4gICAgICAgICAgaW5wdXRTdHJlYW06IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVMaXZlU3RyZWFtKF92aWRlbylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgY29uc29sZS5lcnJvcihcIiogc2V0dXBJbnB1dFN0cmVhbSBpbnZhbGlkIHR5cGUgXCIuY29uY2F0KHR5cGUpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZpZGVvOiBudWxsLFxuICAgICAgICBpbnB1dFN0cmVhbTogbnVsbFxuICAgICAgfTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcXVhZ2dhL3RyYW5zZm9ybS50c1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuZnVuY3Rpb24gbW92ZUJveChib3gsIHhPZmZzZXQsIHlPZmZzZXQpIHtcbiAgdmFyIGNvcm5lciA9IGJveC5sZW5ndGg7XG4gIHdoaWxlIChjb3JuZXItLSkge1xuICAgIGJveFtjb3JuZXJdWzBdICs9IHhPZmZzZXQ7XG4gICAgYm94W2Nvcm5lcl1bMV0gKz0geU9mZnNldDtcbiAgfVxufVxuZnVuY3Rpb24gbW92ZUxpbmUobGluZSwgeE9mZnNldCwgeU9mZnNldCkge1xuICBsaW5lWzBdLnggKz0geE9mZnNldDtcbiAgbGluZVswXS55ICs9IHlPZmZzZXQ7XG4gIGxpbmVbMV0ueCArPSB4T2Zmc2V0O1xuICBsaW5lWzFdLnkgKz0geU9mZnNldDtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3F1YWdnYS9xdWFnZ2EudHNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZXh0ZXJuYWxfZ2xfbWF0cml4X1tcImdsTWF0cml4XCJdLnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7XG52YXIgcXVhZ2dhX1F1YWdnYSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFF1YWdnYSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGNsYXNzQ2FsbENoZWNrX2RlZmF1bHQoKSh0aGlzLCBRdWFnZ2EpO1xuICAgIGRlZmluZVByb3BlcnR5X2RlZmF1bHQoKSh0aGlzLCBcImNvbnRleHRcIiwgbmV3IFF1YWdnYUNvbnRleHRfUXVhZ2dhQ29udGV4dCgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0eV9kZWZhdWx0KCkodGhpcywgXCJjYW5SZWNvcmRcIiwgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMkY29udGV4dCRjb25maWc7XG4gICAgICBpZiAoIV90aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJhcmNvZGVfbG9jYXRvcltcImFcIiAvKiBkZWZhdWx0ICovXS5jaGVja0ltYWdlQ29uc3RyYWludHMoX3RoaXMuY29udGV4dC5pbnB1dFN0cmVhbSwgKF90aGlzJGNvbnRleHQkY29uZmlnID0gX3RoaXMuY29udGV4dC5jb25maWcpID09PSBudWxsIHx8IF90aGlzJGNvbnRleHQkY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRjb250ZXh0JGNvbmZpZy5sb2NhdG9yKTtcbiAgICAgIF90aGlzLmluaXRDYW52YXMoKTtcbiAgICAgIF90aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyID0gZnJhbWVfZ3JhYmJlcl9kZWZhdWx0LmEuY3JlYXRlKF90aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sIF90aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSk7XG4gICAgICBpZiAoX3RoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3RoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgIH1cbiAgICAgIGFkanVzdFdvcmtlclBvb2woX3RoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzLCBfdGhpcy5jb250ZXh0LmNvbmZpZywgX3RoaXMuY29udGV4dC5pbnB1dFN0cmVhbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMkY29udGV4dCRjb25maWcyO1xuICAgICAgICBpZiAoKChfdGhpcyRjb250ZXh0JGNvbmZpZzIgPSBfdGhpcy5jb250ZXh0LmNvbmZpZykgPT09IG51bGwgfHwgX3RoaXMkY29udGV4dCRjb25maWcyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRjb250ZXh0JGNvbmZpZzIubnVtT2ZXb3JrZXJzKSA9PT0gMCkge1xuICAgICAgICAgIF90aGlzLmluaXRpYWxpemVEYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMucmVhZHkoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZGVmaW5lUHJvcGVydHlfZGVmYXVsdCgpKHRoaXMsIFwidXBkYXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQpIHtcbiAgICAgICAgdmFyIHdvcmtlcnNVcGRhdGVkID0gdXBkYXRlV29ya2VycyhfdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlcik7XG4gICAgICAgIGlmICghd29ya2Vyc1VwZGF0ZWQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkY29udGV4dCRpbnB1dEltO1xuICAgICAgICAgIF90aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmF0dGFjaERhdGEoKF90aGlzJGNvbnRleHQkaW5wdXRJbSA9IF90aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIpID09PSBudWxsIHx8IF90aGlzJGNvbnRleHQkaW5wdXRJbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkY29udGV4dCRpbnB1dEltLmRhdGEpO1xuICAgICAgICAgIGlmIChfdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgIGlmICghd29ya2Vyc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXMubG9jYXRlQW5kRGVjb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3RoaXMkY29udGV4dCRpbnB1dEltMjtcbiAgICAgICAgX3RoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YSgoX3RoaXMkY29udGV4dCRpbnB1dEltMiA9IF90aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIpID09PSBudWxsIHx8IF90aGlzJGNvbnRleHQkaW5wdXRJbTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGNvbnRleHQkaW5wdXRJbTIuZGF0YSk7XG4gICAgICAgIF90aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmdyYWIoKTtcbiAgICAgICAgX3RoaXMubG9jYXRlQW5kRGVjb2RlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQ2xhc3NfZGVmYXVsdCgpKFF1YWdnYSwgW3tcbiAgICBrZXk6IFwiaW5pdEJ1ZmZlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIF9pbml0QnVmZmVyczIgPSBpbml0QnVmZmVyc19pbml0QnVmZmVycyh0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sIGltYWdlV3JhcHBlciwgdGhpcy5jb250ZXh0LmNvbmZpZy5sb2NhdG9yKSxcbiAgICAgICAgaW5wdXRJbWFnZVdyYXBwZXIgPSBfaW5pdEJ1ZmZlcnMyLmlucHV0SW1hZ2VXcmFwcGVyLFxuICAgICAgICBib3hTaXplID0gX2luaXRCdWZmZXJzMi5ib3hTaXplO1xuICAgICAgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyID0gaW5wdXRJbWFnZVdyYXBwZXI7XG4gICAgICB0aGlzLmNvbnRleHQuYm94U2l6ZSA9IGJveFNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxpemVEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcikge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyKTtcbiAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyID0gYmFyY29kZV9kZWNvZGVyLmNyZWF0ZSh0aGlzLmNvbnRleHQuY29uZmlnLmRlY29kZXIsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZpZXdQb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdQb3J0KCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnIHx8ICF0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0udGFyZ2V0O1xuICAgICAgcmV0dXJuIGdldFZpZXdQb3J0X2dldFZpZXdQb3J0KHRhcmdldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlYWR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0ucGxheSgpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdENhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGluaXRDYW52YXNfaW5pdENhbnZhcyh0aGlzLmNvbnRleHQpO1xuICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGN0eCA9IGNvbnRhaW5lci5jdHgsXG4gICAgICAgIGRvbSA9IGNvbnRhaW5lci5kb207XG4gICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvbS5pbWFnZTtcbiAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkgPSBkb20ub3ZlcmxheTtcbiAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuY3R4LmltYWdlID0gY3R4LmltYWdlO1xuICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHgub3ZlcmxheSA9IGN0eC5vdmVybGF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0SW5wdXRTdHJlYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdElucHV0U3RyZWFtKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcgfHwgIXRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIF90aGlzJGNvbnRleHQkY29uZmlnJCA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0sXG4gICAgICAgIGlucHV0VHlwZSA9IF90aGlzJGNvbnRleHQkY29uZmlnJC50eXBlLFxuICAgICAgICBjb25zdHJhaW50cyA9IF90aGlzJGNvbnRleHQkY29uZmlnJC5jb25zdHJhaW50cztcbiAgICAgIHZhciBfc2V0dXBJbnB1dFN0cmVhbSA9IHNldHVwSW5wdXRTdHJlYW0oaW5wdXRUeXBlLCB0aGlzLmdldFZpZXdQb3J0KCksIGlucHV0X3N0cmVhbSksXG4gICAgICAgIHZpZGVvID0gX3NldHVwSW5wdXRTdHJlYW0udmlkZW8sXG4gICAgICAgIGlucHV0U3RyZWFtID0gX3NldHVwSW5wdXRTdHJlYW0uaW5wdXRTdHJlYW07XG4gICAgICBpZiAoaW5wdXRUeXBlID09PSAnTGl2ZVN0cmVhbScgJiYgdmlkZW8pIHtcbiAgICAgICAgY2FtZXJhX2FjY2Vzcy5yZXF1ZXN0KHZpZGVvLCBjb25zdHJhaW50cykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtLnRyaWdnZXIoJ2NhbnJlY29yZCcpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0QXR0cmlidXRlKCdwcmVsb2FkJywgJ2F1dG8nKTtcbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0SW5wdXRTdHJlYW0odGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSk7XG4gICAgICAgIGlucHV0U3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnJlY29yZCcsIHRoaXMuY2FuUmVjb3JkLmJpbmQodW5kZWZpbmVkLCBjYWxsYmFjaykpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtID0gaW5wdXRTdHJlYW07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvdW5kaW5nQm94ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3hlcygpIHtcbiAgICAgIHZhciBfdGhpcyRjb250ZXh0JGNvbmZpZzM7XG4gICAgICByZXR1cm4gKF90aGlzJGNvbnRleHQkY29uZmlnMyA9IHRoaXMuY29udGV4dC5jb25maWcpICE9PSBudWxsICYmIF90aGlzJGNvbnRleHQkY29uZmlnMyAhPT0gdm9pZCAwICYmIF90aGlzJGNvbnRleHQkY29uZmlnMy5sb2NhdGUgPyBiYXJjb2RlX2xvY2F0b3JbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9jYXRlKCkgOiBbW2V4dGVybmFsX2dsX21hdHJpeF9bXCJ2ZWMyXCJdLmNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzBdKSwgZXh0ZXJuYWxfZ2xfbWF0cml4X1tcInZlYzJcIl0uY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMV0pLCBleHRlcm5hbF9nbF9tYXRyaXhfW1widmVjMlwiXS5jbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsyXSksIGV4dGVybmFsX2dsX21hdHJpeF9bXCJ2ZWMyXCJdLmNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzNdKV1dO1xuICAgIH1cblxuICAgIC8vIFRPRE86IG5lZWQgYSB0eXBlc2NyaXB0IHR5cGUgZm9yIHJlc3VsdCBoZXJlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtUmVzdWx0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybVJlc3VsdChyZXN1bHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHRvcFJpZ2h0ID0gdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XG4gICAgICB2YXIgeE9mZnNldCA9IHRvcFJpZ2h0Lng7XG4gICAgICB2YXIgeU9mZnNldCA9IHRvcFJpZ2h0Lnk7XG4gICAgICBpZiAoeE9mZnNldCA9PT0gMCAmJiB5T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgLy8gVE9ETzogQmFyY29kZUluZm8gbWF5IG5vdCBiZSB0aGUgcmlnaHQgdHlwZSBoZXJlLlxuICAgICAgICByZXN1bHQuYmFyY29kZXMuZm9yRWFjaChmdW5jdGlvbiAoYmFyY29kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIudHJhbnNmb3JtUmVzdWx0KGJhcmNvZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQubGluZSAmJiByZXN1bHQubGluZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgbW92ZUxpbmUocmVzdWx0LmxpbmUsIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5ib3gpIHtcbiAgICAgICAgbW92ZUJveChyZXN1bHQuYm94LCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuYm94ZXMgJiYgcmVzdWx0LmJveGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtb3ZlQm94KHJlc3VsdC5ib3hlc1tpXSwgeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUmVzdWx0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJlc3VsdChyZXN1bHQsIGltYWdlRGF0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBpZiAoIWltYWdlRGF0YSB8fCAhdGhpcy5jb250ZXh0LnJlc3VsdENvbGxlY3Rvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBkYXRhIHN0cnVjdHVyZSBob2xkcyBhIFwiYmFyY29kZXNcIiByZXN1bHQsIGlmIGFueS4uLlxuICAgICAgaWYgKHJlc3VsdC5iYXJjb2Rlcykge1xuICAgICAgICByZXN1bHQuYmFyY29kZXMuZmlsdGVyKGZ1bmN0aW9uIChiYXJjb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhcmNvZGUuY29kZVJlc3VsdDtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoYmFyY29kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuYWRkUmVzdWx0KGJhcmNvZGUsIGltYWdlRGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQuY29kZVJlc3VsdCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVzdWx0Q29sbGVjdG9yLmFkZFJlc3VsdChpbWFnZURhdGEsIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCksIHJlc3VsdC5jb2RlUmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICB9LCB7XG4gICAga2V5OiBcImhhc0NvZGVSZXN1bHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQ29kZVJlc3VsdChyZXN1bHQpIHtcbiAgICAgIHJldHVybiAhIShyZXN1bHQgJiYgKHJlc3VsdC5iYXJjb2RlcyA/IHJlc3VsdC5iYXJjb2Rlcy5zb21lKGZ1bmN0aW9uIChiYXJjb2RlKSB7XG4gICAgICAgIHJldHVybiBiYXJjb2RlLmNvZGVSZXN1bHQ7XG4gICAgICB9KSA6IHJlc3VsdC5jb2RlUmVzdWx0KSk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoUmVzdWx0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hSZXN1bHQoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHJlc3VsdFRvUHVibGlzaCA9IHJlc3VsdDtcbiAgICAgIGlmIChyZXN1bHQgJiYgdGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQpIHtcbiAgICAgICAgdmFyIF9yZXN1bHQkYmFyY29kZXM7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgIHRoaXMuYWRkUmVzdWx0KHJlc3VsdCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXN1bHRUb1B1Ymxpc2ggPSAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9yZXN1bHQkYmFyY29kZXMgPSByZXN1bHQuYmFyY29kZXMpID09PSBudWxsIHx8IF9yZXN1bHQkYmFyY29kZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXN1bHQkYmFyY29kZXMubGVuZ3RoKSA+IDAgPyByZXN1bHQuYmFyY29kZXMgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBldmVudHMucHVibGlzaCgncHJvY2Vzc2VkJywgcmVzdWx0VG9QdWJsaXNoKTtcbiAgICAgIGlmICh0aGlzLmhhc0NvZGVSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBldmVudHMucHVibGlzaCgnZGV0ZWN0ZWQnLCByZXN1bHRUb1B1Ymxpc2gpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2NhdGVBbmREZWNvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9sb2NhdGVBbmREZWNvZGUgPSBhc3luY1RvR2VuZXJhdG9yX2RlZmF1bHQoKSggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yX2RlZmF1bHQuYS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBib3hlcywgX3RoaXMkY29udGV4dCRpbnB1dEltMywgZGVjb2RlUmVzdWx0LCBpbWFnZVJlc3VsdCwgX3RoaXMkY29udGV4dCRpbnB1dEltNDtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yX2RlZmF1bHQuYS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYm94ZXMgPSB0aGlzLmdldEJvdW5kaW5nQm94ZXMoKTtcbiAgICAgICAgICAgICAgaWYgKCFib3hlcykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5kZWNvZGVyLmRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBpZiAoX2NvbnRleHQudDApIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IHt9O1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBkZWNvZGVSZXN1bHQgPSBfY29udGV4dC50MDtcbiAgICAgICAgICAgICAgZGVjb2RlUmVzdWx0LmJveGVzID0gYm94ZXM7XG4gICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdChkZWNvZGVSZXN1bHQsIChfdGhpcyRjb250ZXh0JGlucHV0SW0zID0gdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKSA9PT0gbnVsbCB8fCBfdGhpcyRjb250ZXh0JGlucHV0SW0zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRjb250ZXh0JGlucHV0SW0zLmRhdGEpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmRlY29kZXIuZGVjb2RlRnJvbUltYWdlKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBpbWFnZVJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIGlmIChpbWFnZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdChpbWFnZVJlc3VsdCwgKF90aGlzJGNvbnRleHQkaW5wdXRJbTQgPSB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIpID09PSBudWxsIHx8IF90aGlzJGNvbnRleHQkaW5wdXRJbTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGNvbnRleHQkaW5wdXRJbTQuZGF0YSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGxvY2F0ZUFuZERlY29kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9sb2NhdGVBbmREZWNvZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2NhdGVBbmREZWNvZGU7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRDb250aW51b3VzVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0Q29udGludW91c1VwZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpcyRjb250ZXh0JGNvbmZpZzQsXG4gICAgICAgIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgbmV4dCA9IG51bGw7XG4gICAgICB2YXIgZGVsYXkgPSAxMDAwIC8gKCgoX3RoaXMkY29udGV4dCRjb25maWc0ID0gdGhpcy5jb250ZXh0LmNvbmZpZykgPT09IG51bGwgfHwgX3RoaXMkY29udGV4dCRjb25maWc0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRjb250ZXh0JGNvbmZpZzQuZnJlcXVlbmN5KSB8fCA2MCk7XG4gICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgbmV3RnJhbWUgPSBmdW5jdGlvbiBuZXdGcmFtZSh0aW1lc3RhbXApIHtcbiAgICAgICAgbmV4dCA9IG5leHQgfHwgdGltZXN0YW1wO1xuICAgICAgICBpZiAoIWNvbnRleHQuc3RvcHBlZCkge1xuICAgICAgICAgIGlmICh0aW1lc3RhbXAgPj0gbmV4dCkge1xuICAgICAgICAgICAgbmV4dCArPSBkZWxheTtcbiAgICAgICAgICAgIF90aGlzNC51cGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuZXdGcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBuZXdGcmFtZShwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzJGNvbnRleHQkY29uZmlnNSwgX3RoaXMkY29udGV4dCRjb25maWc2O1xuICAgICAgaWYgKHRoaXMuY29udGV4dC5vblVJVGhyZWFkICYmICgoX3RoaXMkY29udGV4dCRjb25maWc1ID0gdGhpcy5jb250ZXh0LmNvbmZpZykgPT09IG51bGwgfHwgX3RoaXMkY29udGV4dCRjb25maWc1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXMkY29udGV4dCRjb25maWc2ID0gX3RoaXMkY29udGV4dCRjb25maWc1LmlucHV0U3RyZWFtKSA9PT0gbnVsbCB8fCBfdGhpcyRjb250ZXh0JGNvbmZpZzYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGNvbnRleHQkY29uZmlnNi50eXBlKSA9PT0gJ0xpdmVTdHJlYW0nKSB7XG4gICAgICAgIHRoaXMuc3RhcnRDb250aW51b3VzVXBkYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc3RvcCA9IGFzeW5jVG9HZW5lcmF0b3JfZGVmYXVsdCgpKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JfZGVmYXVsdC5hLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBfdGhpcyRjb250ZXh0JGNvbmZpZzc7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvcl9kZWZhdWx0LmEud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGFkanVzdFdvcmtlclBvb2woMCk7XG4gICAgICAgICAgICAgIGlmICghKChfdGhpcyRjb250ZXh0JGNvbmZpZzcgPSB0aGlzLmNvbnRleHQuY29uZmlnKSAhPT0gbnVsbCAmJiBfdGhpcyRjb250ZXh0JGNvbmZpZzcgIT09IHZvaWQgMCAmJiBfdGhpcyRjb250ZXh0JGNvbmZpZzcuaW5wdXRTdHJlYW0gJiYgdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbS50eXBlID09PSAnTGl2ZVN0cmVhbScpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbWVyYV9hY2Nlc3MucmVsZWFzZSgpO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RvcDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJzZXRSZWFkZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJlYWRlcnMocmVhZGVycykge1xuICAgICAgaWYgKHRoaXMuY29udGV4dC5kZWNvZGVyKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyLnNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgICB9XG4gICAgICBxd29ya2VyX3NldFJlYWRlcnMocmVhZGVycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyUmVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcikge1xuICAgICAgYmFyY29kZV9kZWNvZGVyLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgICBpZiAodGhpcy5jb250ZXh0LmRlY29kZXIpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICAgIH1cbiAgICAgIHF3b3JrZXJfcmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFF1YWdnYTtcbn0oKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcXVhZ2dhLmpzXG5cblxuIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXG5cblxuXG5cblxuXG5cbnZhciBpbnN0YW5jZSA9IG5ldyBxdWFnZ2FfUXVhZ2dhKCk7XG52YXIgX2NvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xudmFyIFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0KGNvbmZpZywgY2IsIGltYWdlV3JhcHBlcikge1xuICAgIHZhciBxdWFnZ2FJbnN0YW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogaW5zdGFuY2U7XG4gICAgdmFyIHByb21pc2U7XG4gICAgaWYgKCFjYikge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgY2IgPSBmdW5jdGlvbiBjYihlcnIpIHtcbiAgICAgICAgICBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNvbmZpZyA9IG1lcmdlX2RlZmF1bHQoKSh7fSwgY29uZmlnX2NvbmZpZywgY29uZmlnKTtcbiAgICAvLyBUT0RPICMxNzk6IHBlbmRpbmcgcmVzdHJ1Y3R1cmUgaW4gSXNzdWUgIzE3OSwgd2UgYXJlIHRlbXAgZGlzYWJsaW5nIHdvcmtlcnNcbiAgICBpZiAocXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID4gMCkge1xuICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICB9XG4gICAgaWYgKGltYWdlV3JhcHBlcikge1xuICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5vblVJVGhyZWFkID0gZmFsc2U7XG4gICAgICBxdWFnZ2FJbnN0YW5jZS5pbml0aWFsaXplRGF0YShpbWFnZVdyYXBwZXIpO1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRJbnB1dFN0cmVhbShjYik7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xuICB9LFxuICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnN0YXJ0KCk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnN0b3AoKTtcbiAgfSxcbiAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIF9jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xuICB9LFxuICBvbkRldGVjdGVkOiBmdW5jdGlvbiBvbkRldGVjdGVkKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZl9kZWZhdWx0KCkoY2FsbGJhY2spICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSB7XG4gICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5vbkRldGVjdGVkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50cy5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICB9LFxuICBvZmZEZXRlY3RlZDogZnVuY3Rpb24gb2ZmRGV0ZWN0ZWQoY2FsbGJhY2spIHtcbiAgICBldmVudHMudW5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICB9LFxuICBvblByb2Nlc3NlZDogZnVuY3Rpb24gb25Qcm9jZXNzZWQoY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mX2RlZmF1bHQoKShjYWxsYmFjaykgIT09ICdvYmplY3QnIHx8ICFjYWxsYmFjay5jYWxsYmFjaykpIHtcbiAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLm9uUHJvY2Vzc2VkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50cy5zdWJzY3JpYmUoJ3Byb2Nlc3NlZCcsIGNhbGxiYWNrKTtcbiAgfSxcbiAgb2ZmUHJvY2Vzc2VkOiBmdW5jdGlvbiBvZmZQcm9jZXNzZWQoY2FsbGJhY2spIHtcbiAgICBldmVudHMudW5zdWJzY3JpYmUoJ3Byb2Nlc3NlZCcsIGNhbGxiYWNrKTtcbiAgfSxcbiAgc2V0UmVhZGVyczogZnVuY3Rpb24gc2V0UmVhZGVycyhyZWFkZXJzKSB7XG4gICAgaWYgKCFyZWFkZXJzKSB7XG4gICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5zZXRSZWFkZXJzIGNhbGxlZCB3aXRoIG5vIHJlYWRlcnMsIGlnbm9yaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc3RhbmNlLnNldFJlYWRlcnMocmVhZGVycyk7XG4gIH0sXG4gIHJlZ2lzdGVyUmVhZGVyOiBmdW5jdGlvbiByZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyIGNhbGxlZCB3aXRoIG5vIG5hbWUsIGlnbm9yaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcmVhZGVyKSB7XG4gICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyByZWFkZXIsIGlnbm9yaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc3RhbmNlLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gIH0sXG4gIHJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yOiBmdW5jdGlvbiByZWdpc3RlclJlc3VsdENvbGxlY3RvcihyZXN1bHRDb2xsZWN0b3IpIHtcbiAgICBpZiAocmVzdWx0Q29sbGVjdG9yICYmIHR5cGVvZiByZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfY29udGV4dC5yZXN1bHRDb2xsZWN0b3IgPSByZXN1bHRDb2xsZWN0b3I7XG4gICAgfVxuICB9LFxuICBnZXQgY2FudmFzKCkge1xuICAgIHJldHVybiBfY29udGV4dC5jYW52YXNDb250YWluZXI7XG4gIH0sXG4gIGRlY29kZVNpbmdsZTogZnVuY3Rpb24gZGVjb2RlU2luZ2xlKGNvbmZpZywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBxdWFnZ2FJbnN0YW5jZSA9IG5ldyBxdWFnZ2FfUXVhZ2dhKCk7XG4gICAgY29uZmlnID0gbWVyZ2VfZGVmYXVsdCgpKHtcbiAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIHR5cGU6ICdJbWFnZVN0cmVhbScsXG4gICAgICAgIHNlcXVlbmNlOiBmYWxzZSxcbiAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICBzcmM6IGNvbmZpZy5zcmNcbiAgICAgIH0sXG4gICAgICBudW1PZldvcmtlcnM6ICBmYWxzZSA/IHVuZGVmaW5lZCA6IDEsXG4gICAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IGZhbHNlXG4gICAgICB9XG4gICAgfSwgY29uZmlnKTtcbiAgICAvLyBUT0RPICMxNzU6IHJlc3RydWN0dXJlIHdvcmtlciBzdXBwb3J0IHNvIHRoYXQgaXQgd2lsbCB3b3JrIHdpdGggdHlwZXNjcmlwdCB1c2luZyB3b3JrZXItbG9hZGVyXG4gICAgLy8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9sb2FkZXJzL3dvcmtlci1sb2FkZXIvXG4gICAgaWYgKGNvbmZpZy5udW1PZldvcmtlcnMgPiAwKSB7XG4gICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICB9XG4gICAgLy8gd29ya2VycyByZXF1aXJlIFdvcmtlciBhbmQgQmxvYiBzdXBwb3J0IHByZXNlbnRseSwgc28gaWYgbm8gQmxvYiBvciBXb3JrZXIgdGhlbiBzZXRcbiAgICAvLyB3b3JrZXJzIHRvIDAuXG4gICAgaWYgKGNvbmZpZy5udW1PZldvcmtlcnMgPiAwICYmICh0eXBlb2YgQmxvYiA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIFdvcmtlciA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJyogbm8gV29ya2VyIGFuZC9vciBCbG9iIHN1cHBvcnQgLSBmb3JjaW5nIG51bU9mV29ya2VycyB0byAwJyk7XG4gICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIF90aGlzLmluaXQoY29uZmlnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZXZlbnRzLm9uY2UoJ3Byb2Nlc3NlZCcsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLnN0b3AoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRDYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjay5jYWxsKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RhcnQoKTtcbiAgICAgICAgfSwgbnVsbCwgcXVhZ2dhSW5zdGFuY2UpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvLyBhZGQgdGhlIHVzdWFsbHkgZXhwZWN0ZWQgXCJkZWZhdWx0XCIgZm9yIHVzZSB3aXRoIHJlcXVpcmUsIGJ1aWxkIHN0ZXAgd29uJ3QgYWxsb3cgdXMgdG9cbiAgLy8gd3JpdGUgdG8gbW9kdWxlLmV4cG9ydHMgc28gZG8gaXQgaGVyZS5cbiAgZ2V0IGRlZmF1bHQoKSB7XG4gICAgcmV0dXJuIFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlO1xuICB9LFxuICBSZWFkZXJzOiByZWFkZXJfbmFtZXNwYWNlT2JqZWN0LFxuICBDYW1lcmFBY2Nlc3M6IGNhbWVyYV9hY2Nlc3MsXG4gIEltYWdlRGVidWc6IGltYWdlX2RlYnVnW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBJbWFnZVdyYXBwZXI6IGltYWdlX3dyYXBwZXJbXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIFJlc3VsdENvbGxlY3RvcjogcmVzdWx0X2NvbGxlY3RvclxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHF1YWdnYSA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlKTtcbi8vIGV4cG9ydCBCYXJjb2RlUmVhZGVyIGFuZCBvdGhlciB1dGlsaXRpZXMgZm9yIGV4dGVybmFsIHBsdWdpbnNcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlbXCJkZWZhdWx0XCJdKSk7Il0sIm5hbWVzIjpbImUiLCJhIiwiaSIsImV4cG9ydHMiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsIm1vZHVsZSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsInRvUHJvcGVydHlLZXkiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfZ2V0UHJvdG90eXBlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicmVxdWlyZSIsIl90eXBlb2YiLCJhc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNvbnN0cnVjdG9yIiwicnVudGltZSIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwiZ2xvYmFsVGhpcyIsIkZ1bmN0aW9uIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImluaXQiLCJhcnIiLCJ2YWwiLCJmaWxsIiwic2h1ZmZsZSIsImoiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJfcmVmIiwidG9Qb2ludExpc3QiLCJyb3dzIiwicmVkdWNlIiwicm93IiwiY29uY2F0Iiwiam9pbiIsInB1c2giLCJ0aHJlc2hvbGQiLCJfdGhyZXNob2xkIiwic2NvcmVGdW5jIiwicXVldWUiLCJwcmV2IiwibmV4dCIsImFwcGx5IiwibWF4SW5kZXgiLCJtYXgiLCJzdW0iLCJfYmFiZWxfcnVudGltZV9oZWxwZXJzX3NsaWNlZFRvQXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsIl9iYWJlbF9ydW50aW1lX2hlbHBlcnNfc2xpY2VkVG9BcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NsYXNzQ2FsbENoZWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJfYmFiZWxfcnVudGltZV9oZWxwZXJzX2NsYXNzQ2FsbENoZWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCIsIl9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY3JlYXRlQ2xhc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsIl9iYWJlbF9ydW50aW1lX2hlbHBlcnNfY3JlYXRlQ2xhc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0IiwiX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwiX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQiLCJnbF9tYXRyaXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyIsImdsX21hdHJpeF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQiLCJfYXJyYXlfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18iLCJfY3ZfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyIsInNldE1hdHJpeEFycmF5VHlwZSIsIkFycmF5IiwiYXNzZXJ0TnVtYmVyUG9zaXRpdmUiLCJFcnJvciIsIkltYWdlV3JhcHBlciIsInNpemUiLCJkYXRhIiwiQXJyYXlUeXBlIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiVWludDhBcnJheSIsImluaXRpYWxpemUiLCJ4IiwieSIsImluSW1hZ2VXaXRoQm9yZGVyIiwiaW1nUmVmIiwiYm9yZGVyIiwic3ViSW1hZ2VBc0NvcHkiLCJpbWFnZVdyYXBwZXIiLCJmcm9tIiwiX2ltYWdlV3JhcHBlciRzaXplIiwic2l6ZVgiLCJzaXplWSIsImdldFNhZmUiLCJpbmRleE1hcHBpbmciLCJfaSIsInNldCIsInplcm9Cb3JkZXIiLCJfdGhpcyRzaXplIiwid2lkdGgiLCJoZWlnaHQiLCJfaTIiLCJtb21lbnRzIiwibGFiZWxDb3VudCIsInlzcSIsImxhYmVsU3VtIiwibGFiZWwiLCJtdTExIiwibXUwMiIsIm11MjAiLCJ4XyIsInlfIiwidG1wIiwicmVzdWx0IiwiUEkiLCJQSV80IiwibTAwIiwibTAxIiwibTEwIiwibTExIiwibTAyIiwibTIwIiwidGhldGEiLCJyYWQiLCJpc05hTiIsImF0YW4iLCJ2ZWMiLCJjbG9uZSIsImNvcyIsInNpbiIsImdldEFzUkdCQSIsInNjYWxlIiwicmV0IiwiVWludDhDbGFtcGVkQXJyYXkiLCJwaXhlbCIsImN1cnJlbnQiLCJzaG93IiwiY2FudmFzIiwiY29uc29sZSIsIndhcm4iLCJjdHgiLCJnZXRDb250ZXh0IiwiZnJhbWUiLCJnZXRJbWFnZURhdGEiLCJuZXdGcmFtZSIsIkltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsIm92ZXJsYXkiLCJpblNjYWxlIiwiYWRqdXN0ZWRTY2FsZSIsImhzdiIsInJnYiIsIndoaXRlUmdiIiwiYmxhY2tSZ2IiLCJwb3MiLCJfcmVzdWx0IiwiX3Jlc3VsdDIiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiX25leHQiLCJfdGhyb3ciLCJhcmciLCJpbmZvIiwiZXJyb3IiLCJkb25lIiwiUHJvbWlzZSIsInRoZW4iLCJfYXN5bmNUb0dlbmVyYXRvciIsImZuIiwiYXJncyIsImVyciIsImltYWdlUmVmIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiY29tcHV0ZUludGVncmFsSW1hZ2UiLCJ0aHJlc2hvbGRJbWFnZSIsImNvbXB1dGVIaXN0b2dyYW0iLCJzaGFycGVuTGluZSIsImRldGVybWluZU90c3VUaHJlc2hvbGQiLCJvdHN1VGhyZXNob2xkIiwiY29tcHV0ZUJpbmFyeUltYWdlIiwiY3ZfdXRpbHNfY2x1c3RlciIsIlRyYWNlciIsIkRJTEFURSIsIkVST0RFIiwiZGlsYXRlIiwiZXJvZGUiLCJzdWJ0cmFjdCIsImJpdHdpc2VPciIsImNvdW50Tm9uWmVybyIsInRvcEdlbmVyaWMiLCJncmF5QXJyYXlGcm9tSW1hZ2UiLCJncmF5QXJyYXlGcm9tQ29udGV4dCIsImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEiLCJjb21wdXRlR3JheSIsImxvYWRJbWFnZUFycmF5IiwiaGFsZlNhbXBsZSIsImhzdjJyZ2IiLCJfY29tcHV0ZURpdmlzb3JzIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwiX2RpbWVuc2lvbnNDb252ZXJ0ZXJzIiwiY29tcHV0ZUltYWdlQXJlYSIsImV4dGVybmFsX2dsX21hdHJpeF8iLCJhcnJheV9oZWxwZXIiLCJjbHVzdGVyIiwicG9pbnQiLCJwb2ludHMiLCJjZW50ZXIiLCJwb2ludE1hcCIsIl9hZGQiLCJwb2ludFRvQWRkIiwiaWQiLCJ1cGRhdGVDZW50ZXIiLCJhZGQiLCJmaXRzIiwib3RoZXJQb2ludCIsInNpbWlsYXJpdHkiLCJhYnMiLCJkb3QiLCJnZXRQb2ludHMiLCJnZXRDZW50ZXIiLCJjcmVhdGVQb2ludCIsIm5ld1BvaW50IiwidGhhdCIsInRvVmVjMiIsInRvVmVjMyIsInJvdW5kIiwiaW50ZWdyYWxXcmFwcGVyIiwiaW1hZ2VEYXRhIiwiaW50ZWdyYWxJbWFnZURhdGEiLCJwb3NBIiwicG9zQiIsInBvc0MiLCJwb3NEIiwidiIsInUiLCJ0YXJnZXRXcmFwcGVyIiwidGFyZ2V0RGF0YSIsImJpdHNQZXJQaXhlbCIsImJpdFNoaWZ0IiwiYnVja2V0Q250IiwiaGlzdCIsIkludDMyQXJyYXkiLCJsaW5lIiwibGVmdCIsInJpZ2h0IiwicHgiLCJlbmQiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJtMSIsIm0yIiwibTEyIiwiayIsImtlcm5lbCIsIkEiLCJCIiwiQyIsIkQiLCJhdmciLCJ0aGlzQ2x1c3RlciIsImNsdXN0ZXJzIiwiYWRkVG9DbHVzdGVyIiwiZm91bmQiLCJ0cmFjZSIsIml0ZXJhdGlvbiIsIm1heEl0ZXJhdGlvbnMiLCJ0b3AiLCJjZW50ZXJQb3MiLCJjdXJyZW50UG9zIiwiaWR4IiwiZm9yd2FyZCIsInRvIiwidG9JZHgiLCJwcmVkaWN0ZWRQb3MiLCJ0aHJlc2hvbGRYIiwidGhyZXNob2xkWSIsIm1hdGNoIiwicHJlZGljdGVkIiwiaW5JbWFnZVdyYXBwZXIiLCJvdXRJbWFnZVdyYXBwZXIiLCJpbkltYWdlRGF0YSIsIm91dEltYWdlRGF0YSIsInlTdGFydDEiLCJ5U3RhcnQyIiwieFN0YXJ0MSIsInhTdGFydDIiLCJhSW1hZ2VXcmFwcGVyIiwiYkltYWdlV3JhcHBlciIsInJlc3VsdEltYWdlV3JhcHBlciIsImFJbWFnZURhdGEiLCJiSW1hZ2VEYXRhIiwiY0ltYWdlRGF0YSIsImxpc3QiLCJtaW5JZHgiLCJtaW4iLCJzY29yZSIsImhpdCIsIml0ZW0iLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJodG1sSW1hZ2UiLCJvZmZzZXRYIiwiYXJyYXkiLCJkcmF3SW1hZ2UiLCJjdHhEYXRhIiwib2Zmc2V0IiwiY2FudmFzRGF0YSIsIm91dEFycmF5IiwidG9wUm93SWR4IiwiYm90dG9tUm93SWR4IiwiZW5kSWR4Iiwib3V0V2lkdGgiLCJvdXRJbWdJZHgiLCJpbldpZHRoIiwiY29uZmlnIiwic2luZ2xlQ2hhbm5lbCIsInNyYyIsImNhbGxiYWNrIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJfY3R4JGdldEltYWdlRGF0YSIsImluSW1nV3JhcHBlciIsIm91dEltZ1dyYXBwZXIiLCJpbkltZyIsIm91dEltZyIsImgiLCJnIiwiYiIsImxhcmdlRGl2aXNvcnMiLCJkaXZpc29ycyIsInNxcnQiLCJ1bnNoaWZ0IiwiX2NvbXB1dGVJbnRlcnNlY3Rpb24iLCJhcnIxIiwiYXJyMiIsInBhdGNoU2l6ZSIsImltZ1NpemUiLCJkaXZpc29yc1giLCJkaXZpc29yc1kiLCJ3aWRlU2lkZSIsImNvbW1vbiIsIm5yT2ZQYXRjaGVzTGlzdCIsIm5yT2ZQYXRjaGVzTWFwIiwic21hbGwiLCJtZWRpdW0iLCJsYXJnZSIsIm5yT2ZQYXRjaGVzSWR4IiwibnJPZlBhdGNoZXMiLCJkZXNpcmVkUGF0Y2hTaXplIiwib3B0aW1hbFBhdGNoU2l6ZSIsImZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyIsImRpbWVuc2lvbiIsInBhcnNlRmxvYXQiLCJ1bml0IiwiaW5kZXhPZiIsImNvbnRleHQiLCJib3R0b20iLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJhcmVhIiwicGFyc2VkQXJlYSIsImtleXMiLCJwYXJzZWQiLCJjYWxjdWxhdGVkIiwic3giLCJzeSIsInN3Iiwic2giLCJpdGVyYXRvciIsInN1cGVyUHJvcEJhc2UiLCJfZ2V0IiwiUmVmbGVjdCIsInJlY2VpdmVyIiwiYmFzZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc09iamVjdCIsInR5cGUiLCJpc0FycmF5IiwiZHJhd1JlY3QiLCJzdHlsZSIsInN0cm9rZVN0eWxlIiwiY29sb3IiLCJmaWxsU3R5bGUiLCJsaW5lV2lkdGgiLCJiZWdpblBhdGgiLCJzdHJva2VSZWN0IiwiZHJhd1BhdGgiLCJwYXRoIiwiZGVmIiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwic3Ryb2tlIiwiY2FudmFzRGF0YVBvcyIsImltYWdlRGF0YVBvcyIsImJhc2VNZXJnZSIsImNyZWF0ZUFzc2lnbmVyIiwibWVyZ2UiLCJzb3VyY2UiLCJzcmNJbmRleCIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QiLCJpc09iamVjdExpa2UiLCJzZWFyY2hEaXJlY3Rpb25zIiwibGFiZWxXcmFwcGVyIiwibGFiZWxEYXRhIiwiX3RyYWNlIiwiZWRnZWxhYmVsIiwiY3kiLCJkaXIiLCJjeCIsInZlcnRleDJEIiwiX2NvbnRvdXJUcmFjaW5nIiwiRnYiLCJDdiIsIlAiLCJsZGlyIiwidG90YWxQaXhlbENvdW50IiwicGl4ZWxDb3VudGVyIiwiY29udG91clRyYWNpbmciLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJzeW1Ub1N0cmluZ1RhZyIsImJhc2VHZXRUYWciLCJnbG9iYWwiLCJnbF9tYXRyaXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsImdsX21hdHJpeF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJfY29tbW9uX2ltYWdlX3dyYXBwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsIl9jb21tb25fY3ZfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsIl9jb21tb25fYXJyYXlfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJfY29tbW9uX2ltYWdlX2RlYnVnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18iLCJfcmFzdGVyaXplcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fIiwiX3RyYWNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fIiwiX3NrZWxldG9uaXplcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fIiwiX2NvbmZpZyIsIl9jdXJyZW50SW1hZ2VXcmFwcGVyIiwiX3NrZWxJbWFnZVdyYXBwZXIiLCJfc3ViSW1hZ2VXcmFwcGVyIiwiX2xhYmVsSW1hZ2VXcmFwcGVyIiwiX3BhdGNoR3JpZCIsIl9wYXRjaExhYmVsR3JpZCIsIl9pbWFnZVRvUGF0Y2hHcmlkIiwiX2JpbmFyeUltYWdlV3JhcHBlciIsIl9wYXRjaFNpemUiLCJfY2FudmFzQ29udGFpbmVyIiwiYmluYXJ5IiwiZG9tIiwiX251bVBhdGNoZXMiLCJfaW5wdXRJbWFnZVdyYXBwZXIiLCJfc2tlbGV0b25pemVyIiwiaW5pdEJ1ZmZlcnMiLCJza2VsZXRvbkltYWdlRGF0YSIsIkFycmF5QnVmZmVyIiwid2luZG93IiwiaW5pdENhbnZhcyIsInVzZVdvcmtlciIsImNsYXNzTmFtZSIsIndpbGxSZWFkRnJlcXVlbnRseSIsImJveEZyb21QYXRjaGVzIiwicGF0Y2hlcyIsIm92ZXJBdmciLCJwYXRjaCIsInRyYW5zTWF0IiwibWlueCIsIm1pbnkiLCJtYXh4IiwibWF4eSIsImJveCIsImNvcHkiLCJ0cmFuc2Zvcm1NYXQyIiwiaW52ZXJ0IiwiYmluYXJpemVJbWFnZSIsImZpbmRQYXRjaGVzIiwicGF0Y2hlc0ZvdW5kIiwicmFzdGVyaXplciIsInJhc3RlclJlc3VsdCIsInNrZWxldG9uaXplIiwicmFzdGVyaXplIiwiY291bnQiLCJkZXNjcmliZVBhdGNoIiwiZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyIsIm1heExhYmVsIiwibGFiZWxIaXN0IiwidG9wTGFiZWxzIiwibWFwIiwic29ydCIsImZpbHRlciIsImVsIiwiZmluZEJveGVzIiwiYm94ZXMiLCJzaW1pbGFyTW9tZW50cyIsInRvcENsdXN0ZXIiLCJwYXRjaFBvcyIsImVsaWdpYmxlTW9tZW50cyIsIm1hdGNoaW5nTW9tZW50cyIsIm1pbkNvbXBvbmVudFdlaWdodCIsImNlaWwiLCJfbWF0Y2hpbmdNb21lbnRzJGskcmEiLCJfbWF0Y2hpbmdNb21lbnRzJGsiLCJpbmRleCIsInJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5IiwiY3VycklkeCIsIm5vdFlldFByb2Nlc3NlZCIsImN1cnJlbnRJZHgiLCJjdXJyZW50UGF0Y2giLCJpbnB1dEltYWdlV3JhcHBlciIsImxvY2F0ZSIsImNoZWNrSW1hZ2VDb25zdHJhaW50cyIsImlucHV0U3RyZWFtIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJ0aGlzSGFsZlNhbXBsZSIsImdldENvbmZpZyIsInNldFRvcFJpZ2h0Iiwic2V0Q2FudmFzU2l6ZSIsInNldFdpZHRoIiwic2V0SGVpZ2h0IiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJlbnRyaWVzIiwiY2xlYXIiLCJlbnRyeSIsImhhcyIsImVxIiwiYXNzb2NJbmRleE9mIiwib3RoZXIiLCJnZXROYXRpdmUiLCJuYXRpdmVDcmVhdGUiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwiX19kYXRhX18iLCJiYXNlSXNBcmd1bWVudHMiLCJvYmplY3RQcm90byIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJpc0luZGV4IiwidGVzdCIsImlzS2V5Iiwic3RyaW5nVG9QYXRoIiwidG9TdHJpbmciLCJjYXN0UGF0aCIsImFycmF5V2l0aEhvbGVzIiwiaXRlcmFibGVUb0FycmF5TGltaXQiLCJ1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm5vbkl0ZXJhYmxlUmVzdCIsIl9zbGljZWRUb0FycmF5IiwiYXJyYXlXaXRob3V0SG9sZXMiLCJpdGVyYWJsZVRvQXJyYXkiLCJub25JdGVyYWJsZVNwcmVhZCIsIl90b0NvbnN1bWFibGVBcnJheSIsImJhc2VJc05hdGl2ZSIsImdldFZhbHVlIiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwidGFnIiwiYmFzZUFzc2lnblZhbHVlIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0aHMiLCJjaGlsZHJlbiIsImlzTGVuZ3RoIiwiaXNBcnJheUxpa2UiLCJfc2V0UHJvdG90eXBlT2YiLCJzeW1ib2xUYWciLCJpc1N5bWJvbCIsIklORklOSVRZIiwidG9LZXkiLCJNYXAiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSIsImFzc2lnbk1lcmdlVmFsdWUiLCJmdW5jIiwib3ZlckFyZyIsImdldFByb3RvdHlwZSIsImlzUHJvdG90eXBlIiwiQ3RvciIsInByb3RvIiwic3R1YkZhbHNlIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwibmF0aXZlSXNCdWZmZXIiLCJpc0J1ZmZlciIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkiLCJub2RlVXRpbCIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJzYWZlR2V0IiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImFycmF5TGlrZUtleXMiLCJiYXNlS2V5c0luIiwia2V5c0luIiwiaWRlbnRpdHkiLCJuYXRpdmVNYXgiLCJvdmVyUmVzdCIsInN0YXJ0IiwidHJhbnNmb3JtIiwib3RoZXJBcmdzIiwiYmFzZVNldFRvU3RyaW5nIiwic2hvcnRPdXQiLCJzZXRUb1N0cmluZyIsImFycmF5TGlrZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJtaW5MZW4iLCJzbGljZSIsIl9hcnJheUxpa2VUb0FycmF5IiwibGVuIiwidG9QcmltaXRpdmUiLCJfdG9Qcm9wZXJ0eUtleSIsIlN0cmluZyIsImJhc2VQaWNrIiwiZmxhdFJlc3QiLCJwaWNrIiwiaXNOYXRpdmVGdW5jdGlvbiIsImNvbnN0cnVjdCIsIl93cmFwTmF0aXZlU3VwZXIiLCJDbGFzcyIsIl9jYWNoZSIsIldyYXBwZXIiLCJDVlV0aWxzIiwiTmRhcnJheSIsIkludGVycDJEIiwiZDIiLCJGcmFtZUdyYWJiZXIiLCJfdGhhdCIsIl92aWRlb1NpemUiLCJnZXRSZWFsV2lkdGgiLCJnZXRSZWFsSGVpZ2h0IiwiX2NhbnZhc1NpemUiLCJnZXRDYW52YXNTaXplIiwiX3NpemUiLCJfdG9wUmlnaHQiLCJnZXRUb3BSaWdodCIsIl9kYXRhIiwiX2dyYXlEYXRhIiwiX2NhbnZhc0RhdGEiLCJfZ3JheUltYWdlQXJyYXkiLCJ0cmFuc3Bvc2UiLCJfY2FudmFzSW1hZ2VBcnJheSIsIl90YXJnZXRJbWFnZUFycmF5IiwiaGkiLCJsbyIsIl9zdGVwU2l6ZVgiLCJfc3RlcFNpemVZIiwiYXR0YWNoRGF0YSIsImdldERhdGEiLCJncmFiIiwiZ2V0RnJhbWUiLCJzY2FsZUFuZENyb3AiLCJzaGFwZSIsIl95IiwiX3giLCJnZXRTaXplIiwiX3RyYWNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiUmFzdGVyaXplciIsImNyZWF0ZUNvbnRvdXIyRCIsImZpcnN0VmVydGV4IiwiaW5zaWRlQ29udG91cnMiLCJuZXh0cGVlciIsInByZXZwZWVyIiwiQ09OVE9VUl9ESVIiLCJDV19ESVIiLCJDQ1dfRElSIiwiVU5LTk9XTl9ESVIiLCJESVIiLCJPVVRTSURFX0VER0UiLCJJTlNJREVfRURHRSIsInRyYWNlciIsImRlcHRobGFiZWwiLCJiYyIsImxjIiwibGFiZWxpbmRleCIsImNvbG9yTWFwIiwidmVydGV4IiwiY2MiLCJzYyIsImNvbm5lY3RlZENvdW50IiwiZGVidWciLCJkcmF3Q29udG91ciIsImZpcnN0Q29udG91ciIsInBxIiwiaXEiLCJxIiwiU2tlbGV0b25pemVyIiwic3RkbGliIiwiZm9yZWlnbiIsImJ1ZmZlciIsImltYWdlcyIsImltdWwiLCJpbkltYWdlUHRyIiwib3V0SW1hZ2VQdHIiLCJhSW1hZ2VQdHIiLCJiSW1hZ2VQdHIiLCJpbWFnZVB0ciIsIm1lbWNweSIsInNyY0ltYWdlUHRyIiwiZHN0SW1hZ2VQdHIiLCJzdWJJbWFnZVB0ciIsImVyb2RlZEltYWdlUHRyIiwidGVtcEltYWdlUHRyIiwic2tlbEltYWdlUHRyIiwiU3RhY2siLCJiYXNlRm9yIiwiYmFzZU1lcmdlRGVlcCIsImN1c3RvbWl6ZXIiLCJzdGFjayIsInNyY1ZhbHVlIiwibmV3VmFsdWUiLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJhcnJheVByb3RvIiwic3BsaWNlIiwibGFzdEluZGV4IiwicG9wIiwiTEFSR0VfQVJSQVlfU0laRSIsInBhaXJzIiwiaXNNYXNrZWQiLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJSZWdFeHAiLCJyZXBsYWNlIiwicGF0dGVybiIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwiaXNPd24iLCJ1bm1hc2tlZCIsImNvcmVKc0RhdGEiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsIklFX1BST1RPIiwiSGFzaCIsImhhc2hDbGVhciIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJIQVNIX1VOREVGSU5FRCIsImNyZWF0ZUJhc2VGb3IiLCJmcm9tUmlnaHQiLCJpdGVyYXRlZSIsImtleXNGdW5jIiwiaXRlcmFibGUiLCJjbG9uZUJ1ZmZlciIsImNsb25lVHlwZWRBcnJheSIsImNvcHlBcnJheSIsImluaXRDbG9uZU9iamVjdCIsImlzQXJyYXlMaWtlT2JqZWN0IiwiaXNQbGFpbk9iamVjdCIsInRvUGxhaW5PYmplY3QiLCJtZXJnZUZ1bmMiLCJzdGFja2VkIiwiaXNDb21tb24iLCJpc0FyciIsImlzQnVmZiIsImlzVHlwZWQiLCJhbGxvY1Vuc2FmZSIsImlzRGVlcCIsImNsb25lQXJyYXlCdWZmZXIiLCJ0eXBlZEFycmF5IiwiYnl0ZU9mZnNldCIsImFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImJhc2VDcmVhdGUiLCJvYmplY3RDcmVhdGUiLCJhcmdzVGFnIiwib2JqZWN0VGFnIiwib2JqZWN0Q3RvclN0cmluZyIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJmcmVlUHJvY2VzcyIsInByb2Nlc3MiLCJ0eXBlcyIsImJpbmRpbmciLCJjb3B5T2JqZWN0IiwiaXNOZXciLCJiYXNlVGltZXMiLCJpbmhlcml0ZWQiLCJpc0FyZyIsImlzVHlwZSIsInNraXBJbmRleGVzIiwibmF0aXZlS2V5c0luIiwiaXNQcm90byIsImJhc2VSZXN0IiwiaXNJdGVyYXRlZUNhbGwiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsInRoaXNBcmciLCJjb25zdGFudCIsInN0cmluZyIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93IiwiRGF0ZSIsIm5vdyIsImxhc3RDYWxsZWQiLCJzdGFtcCIsInJlbWFpbmluZyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJhaCIsImFsIiwiYmgiLCJibCIsImFzc2lnbiIsIm5leHRTb3VyY2UiLCJuZXh0S2V5IiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiZiIsIl9ub25JdGVyYWJsZVJlc3QiLCJfdG9QcmltaXRpdmUiLCJpbnB1dCIsImhpbnQiLCJwcmltIiwicmVzIiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsImFzeW5jSXRlcmF0b3IiLCJkZWZpbmUiLCJ3cmFwIiwiR2VuZXJhdG9yIiwiQ29udGV4dCIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJ2YWx1ZXMiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJmb3JFYWNoIiwiX2ludm9rZSIsIkFzeW5jSXRlcmF0b3IiLCJpbnZva2UiLCJfX2F3YWl0IiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJtZXRob2QiLCJkZWxlZ2F0ZSIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsInJlc3VsdE5hbWUiLCJuZXh0TG9jIiwicHVzaFRyeUVudHJ5IiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsImRpc3BsYXlOYW1lIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsIm1hcmsiLCJhd3JhcCIsImFzeW5jIiwicmV2ZXJzZSIsImNoYXJBdCIsInN0b3AiLCJydmFsIiwiaGFuZGxlIiwiY29tcGxldGUiLCJmaW5pc2giLCJfY2F0Y2giLCJkZWxlZ2F0ZVlpZWxkIiwiX3N1cGVyUHJvcEJhc2UiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiaXRlciIsIl9ub25JdGVyYWJsZVNwcmVhZCIsImJhc2VQaWNrQnkiLCJoYXNJbiIsImJhc2VHZXQiLCJiYXNlU2V0IiwicHJlZGljYXRlIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsIm1lbW9pemVDYXBwZWQiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwiY2hhckNvZGVBdCIsIm51bWJlciIsInF1b3RlIiwic3ViU3RyaW5nIiwibWVtb2l6ZSIsIk1BWF9NRU1PSVpFX1NJWkUiLCJjYWNoZSIsIkZVTkNfRVJST1JfVEVYVCIsInJlc29sdmVyIiwibWVtb2l6ZWQiLCJDYWNoZSIsImJhc2VUb1N0cmluZyIsImFycmF5TWFwIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsIm5lc3RlZCIsImJhc2VIYXNJbiIsImhhc1BhdGgiLCJoYXNGdW5jIiwiZmxhdHRlbiIsImJhc2VGbGF0dGVuIiwiYXJyYXlQdXNoIiwiaXNGbGF0dGVuYWJsZSIsImRlcHRoIiwiaXNTdHJpY3QiLCJzcHJlYWRhYmxlU3ltYm9sIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwiX2lzTmF0aXZlRnVuY3Rpb24iLCJpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY29uc3RydWN0IiwiUGFyZW50IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwiYmFyY29kZV9kZWNvZGVyIiwicmVhZGVyX25hbWVzcGFjZU9iamVjdCIsImNhbWVyYV9hY2Nlc3MiLCJpbWFnZV9kZWJ1ZyIsImltYWdlX3dyYXBwZXIiLCJyZXN1bHRfY29sbGVjdG9yIiwiYmFyY29kZV9yZWFkZXIiLCJfMm9mNV9yZWFkZXIiLCJjb2RhYmFyX3JlYWRlciIsImNvZGVfMTI4X3JlYWRlciIsImNvZGVfMzJfcmVhZGVyIiwiY29kZV8zOV9yZWFkZXIiLCJjb2RlXzM5X3Zpbl9yZWFkZXIiLCJjb2RlXzkzX3JlYWRlciIsImVhbl8yX3JlYWRlciIsImVhbl81X3JlYWRlciIsImVhbl84X3JlYWRlciIsImVhbl9yZWFkZXIiLCJpMm9mNV9yZWFkZXIiLCJ1cGNfZV9yZWFkZXIiLCJ1cGNfcmVhZGVyIiwiaGVscGVyc190eXBlb2YiLCJ0eXBlb2ZfZGVmYXVsdCIsIm1lcmdlX2RlZmF1bHQiLCJ0eXBlZGVmcyIsImFzeW5jVG9HZW5lcmF0b3IiLCJhc3luY1RvR2VuZXJhdG9yX2RlZmF1bHQiLCJyZWdlbmVyYXRvciIsInJlZ2VuZXJhdG9yX2RlZmF1bHQiLCJjbGFzc0NhbGxDaGVjayIsImNsYXNzQ2FsbENoZWNrX2RlZmF1bHQiLCJjcmVhdGVDbGFzcyIsImNyZWF0ZUNsYXNzX2RlZmF1bHQiLCJhc3NlcnRUaGlzSW5pdGlhbGl6ZWRfZGVmYXVsdCIsImluaGVyaXRzIiwiaW5oZXJpdHNfZGVmYXVsdCIsInBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX2RlZmF1bHQiLCJnZXRQcm90b3R5cGVPZl9kZWZhdWx0IiwiZGVmaW5lUHJvcGVydHlfZGVmYXVsdCIsIkJhcmNvZGVEaXJlY3Rpb24iLCJiYXJjb2RlX3JlYWRlcl9CYXJjb2RlUmVhZGVyIiwiQmFyY29kZVJlYWRlciIsInN1cHBsZW1lbnRzIiwiX3JvdyIsIl9uZXh0VW5zZXQiLCJfbWF0Y2hQYXR0ZXJuIiwiY291bnRlciIsImNvZGUiLCJtYXhTaW5nbGVFcnJvciIsIlNJTkdMRV9DT0RFX0VSUk9SIiwic2luZ2xlRXJyb3IiLCJtb2R1bG8iLCJiYXJXaWR0aCIsInNjYWxlZCIsIl9uZXh0U2V0IiwiX2NvcnJlY3RCYXJzIiwiY29ycmVjdGlvbiIsImluZGljZXMiLCJkZWNvZGVQYXR0ZXJuIiwiZGVjb2RlIiwiZGlyZWN0aW9uIiwiUmV2ZXJzZSIsIkZvcndhcmQiLCJmb3JtYXQiLCJGT1JNQVQiLCJfbWF0Y2hSYW5nZSIsIl9maWxsQ291bnRlcnMiLCJpc1doaXRlIiwiY291bnRlcnMiLCJjb3VudGVyUG9zIiwiX3RvQ291bnRlcnMiLCJudW1Db3VudGVycyIsImRlY29kZUltYWdlIiwiU3RhcnROb3RGb3VuZEV4Y2VwdGlvbiIsIkNvZGVOb3RGb3VuZEV4Y2VwdGlvbiIsIlBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbiIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsIk5ld1RhcmdldCIsIk4iLCJXIiwiU1RBUlRfUEFUVEVSTiIsIlNUT1BfUEFUVEVSTiIsIkNPREVfUEFUVEVSTiIsIlNUQVJUX1BBVFRFUk5fTEVOR1RIIiwiXzJvZjVfcmVhZGVyX1R3b09mRml2ZVJlYWRlciIsIl9CYXJjb2RlUmVhZGVyIiwiVHdvT2ZGaXZlUmVhZGVyIiwiX3N1cGVyIiwiX3RoaXMiLCJfbGVuIiwiX2tleSIsIl9maW5kUGF0dGVybiIsInRyeUhhcmRlciIsImJlc3RNYXRjaCIsImVwc2lsb24iLCJBVkdfQ09ERV9FUlJPUiIsIl9qIiwiX2ZpbmRTdGFydCIsInN0YXJ0SW5mbyIsIm5hcnJvd0JhcldpZHRoIiwibGVhZGluZ1doaXRlc3BhY2VTdGFydCIsIl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UiLCJlbmRJbmZvIiwidHJhaWxpbmdXaGl0ZXNwYWNlRW5kIiwiX2ZpbmRFbmQiLCJfdmVyaWZ5Q291bnRlckxlbmd0aCIsIl9kZWNvZGVDb2RlIiwiX2RlY29kZVBheWxvYWQiLCJkZWNvZGVkQ29kZXMiLCJjb3VudGVyTGVuZ3RoIiwiYmFyU3BhY2VSYXRpbyIsImNvZGFiYXJfcmVhZGVyX2NyZWF0ZVN1cGVyIiwiY29kYWJhcl9yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiQUxQSEFCRVQiLCJDSEFSQUNURVJfRU5DT0RJTkdTIiwiU1RBUlRfRU5EIiwiTUlOX0VOQ09ERURfQ0hBUlMiLCJNQVhfQUNDRVBUQUJMRSIsIlBBRERJTkciLCJjb2RhYmFyX3JlYWRlcl9OZXdDb2RhYmFyUmVhZGVyIiwiTmV3Q29kYWJhclJlYWRlciIsIl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQiLCJfY291bnRlcnMiLCJfdG9QYXR0ZXJuIiwiYmFyVGhyZXNob2xkIiwic3BhY2VUaHJlc2hvbGQiLCJiaXRtYXNrIiwiX2lzU3RhcnRFbmQiLCJfc3VtQ291bnRlcnMiLCJzdGFydENvdW50ZXIiLCJlbmRDb3VudGVyIiwiX3BhdHRlcm5Ub0NoYXIiLCJmcm9tQ2hhckNvZGUiLCJfY2FsY3VsYXRlUGF0dGVybkxlbmd0aCIsIl92ZXJpZnlXaGl0ZXNwYWNlIiwiX2NoYXJUb1BhdHRlcm4iLCJfY2hhciIsImNoYXJDb2RlIiwiX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4iLCJjYXRlZ29yaXphdGlvbiIsInNwYWNlIiwibmFycm93IiwiY291bnRzIiwid2lkZSIsImJhciIsImtpbmQiLCJjYXQiLCJuZXdraW5kIiwiX3ZhbGlkYXRlUmVzdWx0IiwidGhyZXNob2xkcyIsIm5leHRTdGFydCIsImRlY29kZWRDaGFyIiwiY29kZV8xMjhfcmVhZGVyX2NyZWF0ZVN1cGVyIiwiY29kZV8xMjhfcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsImNvZGVfMTI4X3JlYWRlcl9Db2RlMTI4UmVhZGVyIiwiQ29kZTEyOFJlYWRlciIsIl9jb3JyZWN0IiwiY2FsY3VsYXRlQ29ycmVjdGlvbiIsIk1PRFVMRV9JTkRJQ0VTIiwiU1RBUlRfQ09ERV9BIiwiU1RBUlRfQ09ERV9DIiwiX3RoaXMyIiwiY2hlY2tzdW0iLCJjb2Rlc2V0IiwiQ09ERV9BIiwiU1RBUlRfQ09ERV9CIiwiQ09ERV9CIiwiQ09ERV9DIiwic2hpZnROZXh0IiwicmVtb3ZlTGFzdENoYXJhY3RlciIsIm11bHRpcGxpZXIiLCJyYXdSZXN1bHQiLCJTVE9QX0NPREUiLCJDT0RFX1NISUZUIiwiZXhwZWN0ZWQiLCJub3JtYWxpemVkIiwic3VtTm9ybWFsaXplZCIsInN1bUV4cGVjdGVkIiwiZ2V0X2RlZmF1bHQiLCJ0b0NvbnN1bWFibGVBcnJheSIsInRvQ29uc3VtYWJsZUFycmF5X2RlZmF1bHQiLCJjb2RlXzM5X3JlYWRlcl9jcmVhdGVTdXBlciIsImNvZGVfMzlfcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIkFMUEhBQkVUSF9TVFJJTkciLCJjb2RlXzM5X3JlYWRlcl9BTFBIQUJFVCIsIlVpbnQxNkFycmF5IiwiY29kZV8zOV9yZWFkZXJfQ0hBUkFDVEVSX0VOQ09ESU5HUyIsIkFTVEVSSVNLIiwiY29kZV8zOV9yZWFkZXJfQ29kZTM5UmVhZGVyIiwiQ29kZTM5UmVhZGVyIiwicGF0dGVyblN0YXJ0Iiwid2hpdGVTcGFjZU11c3RTdGFydCIsIm1heE5hcnJvd1dpZHRoIiwibnVtV2lkZUJhcnMiLCJ3aWRlQmFyV2lkdGgiLCJfZmluZE5leHRXaWR0aCIsIm1pbldpZHRoIiwibGFzdFN0YXJ0IiwicGF0dGVyblNpemUiLCJjb2RlXzMyX3JlYWRlcl9jcmVhdGVTdXBlciIsImNvZGVfMzJfcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInBhdHRlcm5zIiwiQUVJTyIsIkFaMDkiLCJjb2RlMzJzZXQiLCJjb2RlXzMyX3JlYWRlcl9Db2RlMzJSZWFkZXIiLCJfQ29kZTM5UmVhZGVyIiwiQ29kZTMyUmVhZGVyIiwiX2RlY29kZUNvZGUzMiIsImNvZGUzMiIsIl9jaGVja0NoZWNrc3VtIiwiY29kZV8zOV92aW5fcmVhZGVyX2NyZWF0ZVN1cGVyIiwiY29kZV8zOV92aW5fcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsImNvZGVfMzlfdmluX3JlYWRlcl9wYXR0ZXJucyIsIklPUSIsImNvZGVfMzlfdmluX3JlYWRlcl9Db2RlMzlWSU5SZWFkZXIiLCJDb2RlMzlWSU5SZWFkZXIiLCJjb2RlXzkzX3JlYWRlcl9jcmVhdGVTdXBlciIsImNvZGVfOTNfcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsImNvZGVfOTNfcmVhZGVyX0FMUEhBQkVUSF9TVFJJTkciLCJjb2RlXzkzX3JlYWRlcl9BTFBIQUJFVCIsImNvZGVfOTNfcmVhZGVyX0NIQVJBQ1RFUl9FTkNPRElOR1MiLCJjb2RlXzkzX3JlYWRlcl9BU1RFUklTSyIsImNvZGVfOTNfcmVhZGVyX0NvZGU5M1JlYWRlciIsIkNvZGU5M1JlYWRlciIsIl92ZXJpZnlFbmQiLCJfZGVjb2RlRXh0ZW5kZWQiLCJjaGFyQXJyYXkiLCJfY2hhcjIiLCJuZXh0Q2hhciIsIm5leHRDaGFyQ29kZSIsIl9tYXRjaENoZWNrQ2hhciIsIm1heFdlaWdodCIsImFycmF5VG9DaGVjayIsIndlaWdodGVkU3VtcyIsIl9jaGFyMyIsIndlaWdodCIsImNoZWNrQ2hhciIsIl92ZXJpZnlDaGVja3N1bXMiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiX29iamVjdFNwcmVhZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZWFuX3JlYWRlcl9jcmVhdGVTdXBlciIsImVhbl9yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiQ09ERV9HX1NUQVJUIiwiZWFuX3JlYWRlcl9TVEFSVF9QQVRURVJOIiwiTUlERExFX1BBVFRFUk4iLCJFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiIsImVhbl9yZWFkZXJfQ09ERV9QQVRURVJOIiwiQ09ERV9GUkVRVUVOQ1kiLCJlYW5fcmVhZGVyX0VBTlJlYWRlciIsIkVBTlJlYWRlciIsImNvZGVyYW5nZSIsIl9jYWxjdWxhdGVGaXJzdERpZ2l0IiwiY29kZUZyZXF1ZW5jeSIsImluQ29kZSIsIm91dENvZGUiLCJmaXJzdERpZ2l0IiwibWlkZGxlUGF0dGVybiIsIl9jaGVja3N1bSIsIl9kZWNvZGVFeHRlbnNpb25zIiwicmVzdWx0SW5mbyIsInN1cHBsZW1lbnQiLCJsYXN0Q29kZSIsImVhbl8yX3JlYWRlcl9jcmVhdGVTdXBlciIsImVhbl8yX3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJlYW5fMl9yZWFkZXJfRUFOMlJlYWRlciIsIl9FQU5SZWFkZXIiLCJFQU4yUmVhZGVyIiwicGFyc2VJbnQiLCJlYW5fNV9yZWFkZXJfY3JlYXRlU3VwZXIiLCJlYW5fNV9yZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiQ0hFQ0tfRElHSVRfRU5DT0RJTkdTIiwiZGV0ZXJtaW5lQ2hlY2tEaWdpdCIsImV4dGVuc2lvbkNoZWNrc3VtIiwiZWFuXzVfcmVhZGVyX0VBTjVSZWFkZXIiLCJFQU41UmVhZGVyIiwiZWFuXzhfcmVhZGVyX2NyZWF0ZVN1cGVyIiwiZWFuXzhfcmVhZGVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsImVhbl84X3JlYWRlcl9FQU44UmVhZGVyIiwiRUFOOFJlYWRlciIsImkyb2Y1X3JlYWRlcl9jcmVhdGVTdXBlciIsImkyb2Y1X3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJpMm9mNV9yZWFkZXJfTiIsImkyb2Y1X3JlYWRlcl9XIiwiaTJvZjVfcmVhZGVyX0kyb2Y1UmVhZGVyIiwiSTJvZjVSZWFkZXIiLCJvcHRzIiwibm9ybWFsaXplQmFyU3BhY2VXaWR0aCIsImNvdW50ZXJTdW0iLCJjb2RlU3VtIiwiY29ycmVjdGlvblJhdGlvIiwiTUFYX0NPUlJFQ1RJT05fRkFDVE9SIiwiY29ycmVjdGlvblJhdGlvSW52ZXJzZSIsIl9kZWNvZGVQYWlyIiwiY291bnRlclBhaXIiLCJjb2RlcyIsInVwY19lX3JlYWRlcl9vd25LZXlzIiwidXBjX2VfcmVhZGVyX29iamVjdFNwcmVhZCIsInVwY19lX3JlYWRlcl9jcmVhdGVTdXBlciIsInVwY19lX3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJ1cGNfZV9yZWFkZXJfVVBDRVJlYWRlciIsIlVQQ0VSZWFkZXIiLCJfZGV0ZXJtaW5lUGFyaXR5IiwibnJTeXN0ZW0iLCJfY29udmVydFRvVVBDQSIsInVwY2EiLCJsYXN0RGlnaXQiLCJ1cGNfcmVhZGVyX2NyZWF0ZVN1cGVyIiwidXBjX3JlYWRlcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJ1cGNfcmVhZGVyX1VQQ1JlYWRlciIsIlVQQ1JlYWRlciIsInN1YnN0cmluZyIsIkJyZXNlbmhhbSIsIlNsb3BlIiwiVVAiLCJET1dOIiwiZ2V0QmFyY29kZUxpbmUiLCJ4MCIsInkwIiwieDEiLCJ5MSIsInN0ZWVwIiwicmVhZCIsImRlbHRhWCIsImRlbHRhWSIsInlTdGVwIiwidG9CaW5hcnlMaW5lIiwic2xvcGUiLCJzbG9wZTIiLCJleHRyZW1hIiwiY3VycmVudERpciIsInJUaHJlc2hvbGQiLCJwcmludEZyZXF1ZW5jeSIsInByaW50UGF0dGVybiIsImZpbGxDb2xvciIsImZpbGxSZWN0IiwiYnJlc2VuaGFtIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJhbGxvd0FycmF5TGlrZSIsIml0IiwiRiIsIl9lIiwibm9ybWFsQ29tcGxldGlvbiIsImRpZEVyciIsInN0ZXAiLCJfZTIiLCJSRUFERVJTIiwicmVnaXN0ZXJSZWFkZXIiLCJyZWFkZXIiLCJfY2FudmFzIiwiZnJlcXVlbmN5IiwiX2JhcmNvZGVSZWFkZXJzIiwiaW5pdFJlYWRlcnMiLCJpbml0Q29uZmlnIiwiJGRlYnVnIiwicmVhZGVycyIsInJlYWRlckNvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJyZWFkZXJPYmoiLCJ2aXMiLCJnZXRFeHRlbmRlZExpbmUiLCJhbmdsZSIsImV4dCIsImV4dGVuZExpbmUiLCJhbW91bnQiLCJleHRlbnNpb24iLCJnZXRMaW5lIiwidHJ5RGVjb2RlIiwiYmFyY29kZUxpbmUiLCJjb2RlUmVzdWx0IiwidHJ5RGVjb2RlQnJ1dGVGb3JjZSIsImxpbmVBbmdsZSIsInNpZGVMZW5ndGgiLCJwb3ciLCJzbGljZXMiLCJ4ZGlyIiwieWRpciIsImdldExpbmVMZW5ndGgiLCJfZGVjb2RlRnJvbUltYWdlMiIsIl9kZWNvZGVGcm9tSW1hZ2UiLCJfY2FsbGVlMiIsIl9pdGVyYXRvciIsIl9zdGVwIiwiX2NhbGxlZTIkIiwiX2NvbnRleHQyIiwidDAiLCJfZGVjb2RlRnJvbUJvdW5kaW5nQm94IiwibGluZUxlbmd0aCIsImF0YW4yIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94IiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMiLCJiYXJjb2RlcyIsIm11bHRpcGxlIiwiZGVjb2RlRnJvbUltYWdlIiwiaW1hZ2VXcmFwcGVySW4iLCJfY2FsbGVlIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInNldFJlYWRlcnMiLCJldmVudHMiLCJFdmVudEludGVyZmFjZSIsImdldEV2ZW50IiwiZXZlbnROYW1lIiwic3Vic2NyaWJlcnMiLCJjbGVhckV2ZW50cyIsInB1Ymxpc2hTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJfc3Vic2NyaWJlIiwiZXZlbnQiLCJzdWJzY3JpYmUiLCJwdWJsaXNoIiwic3Vic2NyaWJlciIsIm9uY2UiLCJ1bnN1YnNjcmliZSIsIl9ldmVudCIsInBpY2tfZGVmYXVsdCIsIndyYXBOYXRpdmVTdXBlciIsIndyYXBOYXRpdmVTdXBlcl9kZWZhdWx0IiwiRXhjZXB0aW9uX2NyZWF0ZVN1cGVyIiwiRXhjZXB0aW9uX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIkV4Y2VwdGlvbl9FeGNlcHRpb24iLCJfRXJyb3IiLCJFeGNlcHRpb24iLCJFUlJPUl9ERVNDIiwiZW51bWVyYXRlRGV2aWNlcyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImNvbnN0cmFpbnRzIiwic3RyZWFtUmVmIiwid2FpdEZvclZpZGVvIiwidmlkZW8iLCJhdHRlbXB0cyIsImNoZWNrVmlkZW8iLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJpbml0Q2FtZXJhIiwiX3gyIiwiX2luaXRDYW1lcmEiLCJfY2FsbGVlNCIsInN0cmVhbSIsIl9jYWxsZWU0JCIsIl9jb250ZXh0NCIsInNldEF0dHJpYnV0ZSIsInNyY09iamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwbGF5IiwiZGVwcmVjYXRlZENvbnN0cmFpbnRzIiwidmlkZW9Db25zdHJhaW50cyIsIm1pbkFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJsb2ciLCJmYWNpbmciLCJmYWNpbmdNb2RlIiwicGlja0NvbnN0cmFpbnRzIiwiZGV2aWNlSWQiLCJhdWRpbyIsImVudW1lcmF0ZVZpZGVvRGV2aWNlcyIsIl9lbnVtZXJhdGVWaWRlb0RldmljZXMiLCJfY2FsbGVlNSIsImRldmljZXMiLCJfY2FsbGVlNSQiLCJfY29udGV4dDUiLCJkZXZpY2UiLCJnZXRBY3RpdmVUcmFjayIsInRyYWNrcyIsImdldFZpZGVvVHJhY2tzIiwiUXVhZ2dhSlNDYW1lcmFBY2Nlc3MiLCJyZXF1ZXN0ZWRWaWRlb0VsZW1lbnQiLCJyZXF1ZXN0IiwibmV3Q29uc3RyYWludHMiLCJyZWxlYXNlIiwicGF1c2UiLCJ0cmFjayIsImdldEFjdGl2ZVN0cmVhbUxhYmVsIiwiZGlzYWJsZVRvcmNoIiwiYXBwbHlDb25zdHJhaW50cyIsImFkdmFuY2VkIiwidG9yY2giLCJPdmVyY29uc3RyYWluZWRFcnJvciIsImVuYWJsZVRvcmNoIiwiX2NhbGxlZTMiLCJfY2FsbGVlMyQiLCJfY29udGV4dDMiLCJjb250YWlucyIsInNvbWUiLCJldmVyeSIsInBhc3Nlc0ZpbHRlciIsIl9jb25maWckY2FwYWNpdHkiLCJyZXN1bHRzIiwiY2FwYWNpdHkiLCJjYXB0dXJlIiwibWF0Y2hlc0NvbnN0cmFpbnRzIiwiYmxhY2tsaXN0IiwiYWRkUmVzdWx0IiwiaW1hZ2VTaXplIiwidG9EYXRhVVJMIiwiZ2V0UmVzdWx0cyIsIkRldkNvbmZpZyIsIm51bU9mV29ya2VycyIsImRlY29kZXIiLCJkcmF3Qm91bmRpbmdCb3giLCJzaG93RnJlcXVlbmN5IiwiZHJhd1NjYW5saW5lIiwic2hvd1BhdHRlcm4iLCJsb2NhdG9yIiwic2hvd0NhbnZhcyIsInNob3dQYXRjaGVzIiwic2hvd0ZvdW5kUGF0Y2hlcyIsInNob3dTa2VsZXRvbiIsInNob3dMYWJlbHMiLCJzaG93UGF0Y2hMYWJlbHMiLCJzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMiLCJzaG93VHJhbnNmb3JtZWQiLCJzaG93VHJhbnNmb3JtZWRCb3giLCJzaG93QkIiLCJjb25maWdfZGV2IiwiTm9kZUNvbmZpZyIsInNlcXVlbmNlIiwiY29uZmlnX25vZGUiLCJQcm9kQ29uZmlnIiwiY29uZmlnX3Byb2QiLCJFeHBvcnRDb25maWciLCJRdWFnZ2FDb25maWciLCJjb25maWdfY29uZmlnIiwiZnJhbWVfZ3JhYmJlciIsImZyYW1lX2dyYWJiZXJfZGVmYXVsdCIsInNsaWNlZFRvQXJyYXkiLCJzbGljZWRUb0FycmF5X2RlZmF1bHQiLCJleHRlcm5hbF9nZXRfcGl4ZWxzXyIsImV4dGVybmFsX2dldF9waXhlbHNfZGVmYXVsdCIsImlucHV0U3RyZWFtRmFjdG9yeSIsImNyZWF0ZVZpZGVvU3RyZWFtIiwiY3JlYXRlTGl2ZVN0cmVhbSIsImNyZWF0ZUltYWdlU3RyZWFtIiwibG9hZGVkIiwiYmFzZVVybCIsIl9lbmRlZCIsImNhbGN1bGF0ZWRXaWR0aCIsImNhbGN1bGF0ZWRIZWlnaHQiLCJfZXZlbnROYW1lcyIsIl9ldmVudEhhbmRsZXJzIiwiZnJhbWVJZHgiLCJwYXVzZWQiLCJsb2FkSW1hZ2VzIiwiX2NvbmZpZzIiLCJtaW1lIiwicGl4ZWxzIiwiX2NvbmZpZzMiLCJfY29uZmlnNCIsIl9waXhlbHMkc2hhcGUiLCJwdWJsaXNoRXZlbnQiLCJoYW5kbGVycyIsInRyaWdnZXIiLCJ3Iiwic2V0SW5wdXRTdHJlYW0iLCJfY29uZmlnNSIsImVuZGVkIiwic2V0Q3VycmVudFRpbWUiLCJ0aW1lIiwiY2xlYXJFdmVudEhhbmRsZXJzIiwiaW5kIiwidG9wUmlnaHQiLCJzeiIsImlucHV0X3N0cmVhbSIsImJhcmNvZGVfbG9jYXRvciIsIlF1YWdnYUNvbnRleHRfUXVhZ2dhQ29udGV4dCIsIlF1YWdnYUNvbnRleHQiLCJRdWFnZ2FDb250ZXh0X0NhbnZhc0NvbnRhaW5lciIsIlF1YWdnYUNvbnRleHRfQ2FudmFzSW5mbyIsIkNhbnZhc0luZm8iLCJDYW52YXNDb250YWluZXIiLCJnZXRWaWV3UG9ydF9nZXRWaWV3UG9ydCIsIkhUTUxFbGVtZW50Iiwibm9kZU5hbWUiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJpbml0QnVmZmVyc19pbml0QnVmZmVycyIsImJveFNpemUiLCJmaW5kT3JDcmVhdGVDYW52YXMiLCJnZXRDYW52YXNBbmRDb250ZXh0Iiwib3B0aW9ucyIsImluaXRDYW52YXNlcyIsImNhbnZhc1NpemUiLCJpbWFnZSIsImluaXRDYW52YXNfaW5pdENhbnZhcyIsIl9jb250ZXh0JGNvbmZpZyIsIl9jb250ZXh0JGNvbmZpZyRpbnB1dCIsIl9jb250ZXh0JGNvbmZpZzIiLCJfY29udGV4dCRjb25maWcyJGlucHUiLCJfY29udGV4dCRjb25maWczIiwiX2NvbnRleHQkY29uZmlnMyRpbnB1Iiwidmlld3BvcnQiLCJjb250YWluZXIiLCJhcHBlbmRDaGlsZCIsInF3b3JrZXJfb3duS2V5cyIsInF3b3JrZXJfb2JqZWN0U3ByZWFkIiwid29ya2VyUG9vbCIsInVwZGF0ZVdvcmtlcnMiLCJmcmFtZUdyYWJiZXIiLCJhdmFpbGFibGVXb3JrZXIiLCJ3b3JrZXJUaHJlYWQiLCJidXN5Iiwid29ya2VyIiwicG9zdE1lc3NhZ2UiLCJjbWQiLCJjb25maWdGb3JXb3JrZXIiLCJ3b3JrZXJJbnRlcmZhY2UiLCJmYWN0b3J5IiwiUXVhZ2dhIiwibWVzc2FnZSIsIm9uUHJvY2Vzc2VkIiwid29ya2VySW50ZXJmYWNlUmVhZHkiLCJvbm1lc3NhZ2UiLCJnZW5lcmF0ZVdvcmtlckJsb2IiLCJibG9iIiwiZmFjdG9yeVNvdXJjZSIsIl9fZmFjdG9yeVNvdXJjZV9fIiwiQmxvYiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImluaXRXb3JrZXIiLCJjYiIsImJsb2JVUkwiLCJXb3JrZXIiLCJyZXZva2VPYmplY3RVUkwiLCJwdWJsaXNoUmVzdWx0IiwiYWRqdXN0V29ya2VyUG9vbCIsImluY3JlYXNlQnkiLCJ3b3JrZXJzVG9UZXJtaW5hdGUiLCJ0ZXJtaW5hdGUiLCJ3b3JrZXJJbml0aWFsaXplZCIsInF3b3JrZXJfc2V0UmVhZGVycyIsInF3b3JrZXJfcmVnaXN0ZXJSZWFkZXIiLCJzZXR1cElucHV0U3RyZWFtIiwiX3ZpZGVvIiwibW92ZUJveCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiY29ybmVyIiwibW92ZUxpbmUiLCJxdWFnZ2FfUXVhZ2dhIiwiX3RoaXMkY29udGV4dCRjb25maWciLCJmcmFtZWdyYWJiZXIiLCJjYW52YXNDb250YWluZXIiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzIiLCJpbml0aWFsaXplRGF0YSIsInJlYWR5Iiwib25VSVRocmVhZCIsIndvcmtlcnNVcGRhdGVkIiwiX3RoaXMkY29udGV4dCRpbnB1dEltIiwibG9jYXRlQW5kRGVjb2RlIiwiX3RoaXMkY29udGV4dCRpbnB1dEltMiIsIl9pbml0QnVmZmVyczIiLCJnZXRWaWV3UG9ydCIsImluaXRJbnB1dFN0cmVhbSIsIl90aGlzJGNvbnRleHQkY29uZmlnJCIsImlucHV0VHlwZSIsIl9zZXR1cElucHV0U3RyZWFtIiwiY2FuUmVjb3JkIiwiZ2V0Qm91bmRpbmdCb3hlcyIsIl90aGlzJGNvbnRleHQkY29uZmlnMyIsInRyYW5zZm9ybVJlc3VsdCIsImJhcmNvZGUiLCJfdGhpczMiLCJyZXN1bHRDb2xsZWN0b3IiLCJoYXNDb2RlUmVzdWx0IiwicmVzdWx0VG9QdWJsaXNoIiwiX3Jlc3VsdCRiYXJjb2RlcyIsIl9sb2NhdGVBbmREZWNvZGUiLCJfdGhpcyRjb250ZXh0JGlucHV0SW0zIiwiZGVjb2RlUmVzdWx0IiwiaW1hZ2VSZXN1bHQiLCJfdGhpcyRjb250ZXh0JGlucHV0SW00Iiwic3RhcnRDb250aW51b3VzVXBkYXRlIiwiX3RoaXMkY29udGV4dCRjb25maWc0IiwiX3RoaXM0IiwiZGVsYXkiLCJzdG9wcGVkIiwidGltZXN0YW1wIiwidXBkYXRlIiwicGVyZm9ybWFuY2UiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzUiLCJfdGhpcyRjb250ZXh0JGNvbmZpZzYiLCJfc3RvcCIsIl90aGlzJGNvbnRleHQkY29uZmlnNyIsIlF1YWdnYUpTU3RhdGljSW50ZXJmYWNlIiwicXVhZ2dhSW5zdGFuY2UiLCJwcm9taXNlIiwib25EZXRlY3RlZCIsIm9mZkRldGVjdGVkIiwib2ZmUHJvY2Vzc2VkIiwicmVnaXN0ZXJSZXN1bHRDb2xsZWN0b3IiLCJkZWNvZGVTaW5nbGUiLCJyZXN1bHRDYWxsYmFjayIsImRlZmF1bHQiLCJSZWFkZXJzIiwiQ2FtZXJhQWNjZXNzIiwiSW1hZ2VEZWJ1ZyIsIlJlc3VsdENvbGxlY3RvciIsInF1YWdnYSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ericblade/quagga2/lib/quagga.js\n");

/***/ })

};
;